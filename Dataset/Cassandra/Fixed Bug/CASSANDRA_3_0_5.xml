<?xml version="1.0" encoding="UTF-8"?>

<bugrepository name="CASSANDRA">
  <bug id="10331" opendate="2015-9-15 00:00:00" fixdate="2015-3-15 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Establish and implement canonical bulk reading workload(s)</summary>
      <description>Implement a client, use stress, or extend stress to a bulk reading workload that is indicative of the performance we are trying to improve.</description>
      <version>3.0.5,3.5</version>
      <fixedVersion>None</fixedVersion>
      <type>Sub-task</type>
    </buginformation>
    <fixedFiles>
      <file type="M">tools.stress.src.org.apache.cassandra.stress.WorkManager.java</file>
      <file type="M">tools.stress.src.org.apache.cassandra.stress.StressYaml.java</file>
      <file type="M">tools.stress.src.org.apache.cassandra.stress.StressProfile.java</file>
      <file type="M">tools.stress.src.org.apache.cassandra.stress.StressMetrics.java</file>
      <file type="M">tools.stress.src.org.apache.cassandra.stress.StressAction.java</file>
      <file type="M">tools.stress.src.org.apache.cassandra.stress.settings.StressSettings.java</file>
      <file type="M">tools.stress.src.org.apache.cassandra.stress.settings.SettingsCommandUser.java</file>
      <file type="M">tools.stress.src.org.apache.cassandra.stress.settings.SettingsCommandPreDefinedMixed.java</file>
      <file type="M">tools.stress.src.org.apache.cassandra.stress.settings.SettingsCommandPreDefined.java</file>
      <file type="M">tools.stress.src.org.apache.cassandra.stress.settings.CliOption.java</file>
      <file type="M">tools.stress.src.org.apache.cassandra.stress.operations.userdefined.ValidatingSchemaQuery.java</file>
      <file type="M">tools.stress.src.org.apache.cassandra.stress.operations.userdefined.SchemaStatement.java</file>
      <file type="M">tools.stress.src.org.apache.cassandra.stress.operations.SampledOpDistributionFactory.java</file>
      <file type="M">tools.stress.src.org.apache.cassandra.stress.operations.predefined.PredefinedOperation.java</file>
      <file type="M">tools.stress.src.org.apache.cassandra.stress.operations.OpDistributionFactory.java</file>
      <file type="M">tools.stress.src.org.apache.cassandra.stress.Operation.java</file>
      <file type="M">tools.stress.README.txt</file>
      <file type="M">tools.cqlstress-example.yaml</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="10748" opendate="2015-11-22 00:00:00" fixdate="2015-3-22 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>UTF8Validator.validate() wrong ??</summary>
      <description>The switch-statement in UTF8Validator.validate() can never go into case TWO_80 as the assignment state = State.TWO_80; in line 75 is dead.I assume that the TWO_80 case is completely superfluous - but would like to have a 2nd opinion on this./cc carlyeks (CASSANDRA-4495)</description>
      <version>2.2.6,3.0.5,3.5</version>
      <fixedVersion>Legacy/Core</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.serializers.UTF8Serializer.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="10809" opendate="2015-12-2 00:00:00" fixdate="2015-3-2 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Create a -D option to prevent gossip startup</summary>
      <description>In CASSANDRA-6961 we changed how join_ring=false works, to great benefit. However, sometimes you need to a node to come up, but not interact with other nodes whatsoever - for example if you have a schema problem, it will still pull the schema from another node because they still gossip even though we're in a dead state.We can add a way to restore the previous behavior by simply adding something like -Dcassandra.start_gossip=false.In the meantime we can workaround by setting listen_address to localhost, but that's kind of a pain.</description>
      <version>2.2.6,3.0.5,3.5</version>
      <fixedVersion>Legacy/DistributedMetadata</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.service.StorageService.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="10990" opendate="2016-1-8 00:00:00" fixdate="2016-3-8 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Support streaming of older version sstables in 3.0</summary>
      <description>In 2.0 we introduced support for streaming older versioned sstables (CASSANDRA-5772). In 3.0, because of the rewrite of the storage layer, this became no longer supported. So currently, while 3.0 can read sstables in the 2.1/2.2 format, it cannot stream the older versioned sstables. We should do some work to make this still possible to be consistent with what CASSANDRA-5772 provided.</description>
      <version>3.0.5,3.5</version>
      <fixedVersion>Legacy/StreamingandMessaging</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">test.unit.org.apache.cassandra.utils.BytesReadTrackerTest.java</file>
      <file type="M">test.unit.org.apache.cassandra.io.util.RandomAccessReaderTest.java</file>
      <file type="M">test.unit.org.apache.cassandra.io.util.BufferedRandomAccessFileTest.java</file>
      <file type="M">test.unit.org.apache.cassandra.io.sstable.LegacySSTableTest.java</file>
      <file type="M">test.unit.org.apache.cassandra.io.compress.CompressedSequentialWriterTest.java</file>
      <file type="M">test.unit.org.apache.cassandra.io.compress.CompressedRandomAccessReaderTest.java</file>
      <file type="M">test.unit.org.apache.cassandra.gms.SerializationsTest.java</file>
      <file type="M">test.unit.org.apache.cassandra.db.DirectoriesTest.java</file>
      <file type="M">test.unit.org.apache.cassandra.AbstractSerializationsTester.java</file>
      <file type="M">src.java.org.apache.cassandra.utils.CloseableIterator.java</file>
      <file type="M">src.java.org.apache.cassandra.utils.BytesReadTracker.java</file>
      <file type="M">src.java.org.apache.cassandra.tools.nodetool.Repair.java</file>
      <file type="M">src.java.org.apache.cassandra.streaming.StreamReader.java</file>
      <file type="M">src.java.org.apache.cassandra.streaming.messages.FileMessageHeader.java</file>
      <file type="M">src.java.org.apache.cassandra.streaming.compress.CompressedStreamReader.java</file>
      <file type="M">src.java.org.apache.cassandra.service.StorageService.java</file>
      <file type="M">src.java.org.apache.cassandra.io.util.SequentialWriter.java</file>
      <file type="M">src.java.org.apache.cassandra.io.util.RandomAccessReader.java</file>
      <file type="M">src.java.org.apache.cassandra.io.util.FileSegmentInputStream.java</file>
      <file type="M">src.java.org.apache.cassandra.io.util.FileMark.java</file>
      <file type="M">src.java.org.apache.cassandra.io.util.FileDataInput.java</file>
      <file type="M">src.java.org.apache.cassandra.io.sstable.SSTableSimpleIterator.java</file>
      <file type="M">src.java.org.apache.cassandra.io.sstable.format.SSTableWriter.java</file>
      <file type="M">src.java.org.apache.cassandra.io.sstable.format.SSTableReader.java</file>
      <file type="M">src.java.org.apache.cassandra.io.sstable.format.big.BigTableWriter.java</file>
      <file type="M">src.java.org.apache.cassandra.io.compress.CompressedSequentialWriter.java</file>
      <file type="M">src.java.org.apache.cassandra.hints.HintMessage.java</file>
      <file type="M">src.java.org.apache.cassandra.hints.ChecksummedDataInput.java</file>
      <file type="M">src.java.org.apache.cassandra.db.Serializers.java</file>
      <file type="M">src.java.org.apache.cassandra.db.SerializationHeader.java</file>
      <file type="M">src.java.org.apache.cassandra.db.Directories.java</file>
      <file type="M">src.java.org.apache.cassandra.db.columniterator.AbstractSSTableIterator.java</file>
      <file type="M">src.java.org.apache.cassandra.db.ColumnFamilyStore.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="11053" opendate="2016-1-21 00:00:00" fixdate="2016-3-21 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>COPY FROM on large datasets: fix progress report and optimize performance part 4</summary>
      <description>DescriptionRunning COPY from on a large dataset (20G divided in 20M records) revealed two issues: The progress report is incorrect, it is very slow until almost the end of the test at which point it catches up extremely quickly. The performance in rows per second is similar to running smaller tests with a smaller cluster locally (approx 35,000 rows per second). As a comparison, cassandra-stress manages 50,000 rows per second under the same set-up, therefore resulting 1.5 times faster.See attached file copy_from_large_benchmark.txt for the benchmark details.Doc-impacting changes to COPY FROM options A new option was added: PREPAREDSTATEMENTS - it indicates if prepared statements should be used; it defaults to true. The default value of CHUNKSIZE changed from 1000 to 5000. The default value of MINBATCHSIZE changed from 2 to 10.</description>
      <version>2.1.14,2.2.6,3.0.5,3.5</version>
      <fixedVersion>Legacy/Tools</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">pylib.setup.py</file>
      <file type="M">pylib.cqlshlib.util.py</file>
      <file type="M">CHANGES.txt</file>
      <file type="M">bin.cqlsh</file>
      <file type="M">pylib.cqlshlib.copyutil.py</file>
    </fixedFiles>
  </bug>
  <bug id="11093" opendate="2016-1-29 00:00:00" fixdate="2016-3-29 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>processs restarts are failing becase native port and jmx ports are in use</summary>
      <description>A process restart should automatically take care of this. But it is not and it is a problem.The ports are are considered in use even if the process has quit/died/killed but the socket is in a TIME_WAIT state in the TCP FSM (http://tcpipguide.com/free/t_TCPOperationalOverviewandtheTCPFiniteStateMachineF-2.htm).tcp 0 0 127.0.0.1:7199 0.0.0.0:* LISTEN 30099/javatcp 0 0 192.168.1.2:9160 0.0.0.0:* LISTEN 30099/javatcp 0 0 10.130.128.131:58263 10.130.128.131:9042 TIME_WAIT -tcp 0 0 10.130.128.131:58262 10.130.128.131:9042 TIME_WAIT -tcp 0 0 ::ffff:10.130.128.131:9042 :::* LISTEN 30099/javatcp 0 0 ::ffff:10.130.128.131:9042 ::ffff:10.130.128.131:57191 ESTABLISHED 30099/javatcp 0 0 ::ffff:10.130.128.131:9042 ::ffff:10.130.128.131:57190 ESTABLISHED 30099/javatcp 0 0 ::ffff:10.130.128.131:9042 ::ffff:10.176.70.226:37105 ESTABLISHED 30099/javatcp 0 0 ::ffff:127.0.0.1:42562 ::ffff:127.0.0.1:7199 TIME_WAIT -tcp 0 0 ::ffff:10.130.128.131:57190 ::ffff:10.130.128.131:9042 ESTABLISHED 30138/javatcp 0 0 ::ffff:10.130.128.131:57198 ::ffff:10.130.128.131:9042 ESTABLISHED 30138/javatcp 0 0 ::ffff:10.130.128.131:9042 ::ffff:10.176.70.226:37106 ESTABLISHED 30099/javatcp 0 0 ::ffff:10.130.128.131:57197 ::ffff:10.130.128.131:9042 ESTABLISHED 30138/javatcp 0 0 ::ffff:10.130.128.131:57191 ::ffff:10.130.128.131:9042 ESTABLISHED 30138/javatcp 0 0 ::ffff:10.130.128.131:9042 ::ffff:10.130.128.131:57198 ESTABLISHED 30099/javatcp 0 0 ::ffff:10.130.128.131:9042 ::ffff:10.130.128.131:57197 ESTABLISHED 30099/javatcp 0 0 ::ffff:127.0.0.1:42567 ::ffff:127.0.0.1:7199 TIME_WAIT -I had to write a restart handler that does a netstat call and looks to make sure all the TIME_WAIT states exhaust before starting the node back up. This happened on 26 of the 56 when a rolling restart was performed. The issue was mostly around JMX port 7199. There was another rollling restart done on the 26 nodes to remediate the JMX ports issue in that restart one node had the issue where port 9042 was considered used after the restart and the process died after a bit of time.What needs to be done for port the native port 9042 and JMX port 7199 is to create the underlying TCP socket with SO_REUSEADDR. This eases the restriction and allows the port to be bound by process even if there are sockets open to that port in the TCP FSM, as long as there is no other process listening on that port. There is a Java method available to set this option in java.net.Socket https://docs.oracle.com/javase/7/docs/api/java/net/Socket.html#setReuseAddress%28boolean%29.native port 9042: https://github.com/apache/cassandra/blob/4a0d1caa262af3b6f2b6d329e45766b4df845a88/tools/stress/src/org/apache/cassandra/stress/settings/SettingsPort.java#L38JMX port 7199: https://github.com/apache/cassandra/blob/4a0d1caa262af3b6f2b6d329e45766b4df845a88/tools/stress/src/org/apache/cassandra/stress/settings/SettingsPort.java#L40Looking in the code itself this option is being set on thrift (9160 (default)) and internode communication ports, uncrypted (7000 (default)) and SSL encrypted (7001 (default)) .https://github.com/apache/cassandra/search?utf8=%E2%9C%93&amp;q=setReuseAddressThis needs to be set to native and jmx ports as well.References:https://unix.stackexchange.com/questions/258379/when-is-a-port-considered-being-used/258380?noredirect=1https://stackoverflow.com/questions/23531558/allow-restarting-java-application-with-jmx-monitoring-enabled-immediatelyhttps://docs.oracle.com/javase/8/docs/technotes/guides/rmi/socketfactory/https://github.com/apache/cassandra/search?utf8=%E2%9C%93&amp;q=setReuseAddresshttps://docs.oracle.com/javase/7/docs/api/java/net/Socket.html#setReuseAddress%28boolean%293https://github.com/apache/cassandra/blob/4a0d1caa262af3b6f2b6d329e45766b4df845a88/tools/stress/src/org/apache/cassandra/stress/settings/SettingsPort.java#L38https://github.com/apache/cassandra/blob/4a0d1caa262af3b6f2b6d329e45766b4df845a88/tools/stress/src/org/apache/cassandra/stress/settings/SettingsPort.java#L40</description>
      <version>None</version>
      <fixedVersion>Local/Config</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.utils.RMIServerSocketFactoryImpl.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="11179" opendate="2016-2-17 00:00:00" fixdate="2016-3-17 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Parallel cleanup can lead to disk space exhaustion</summary>
      <description>In CASSANDRA-5547, we made cleanup (among other things) run in parallel across multiple sstables. There have been reports on IRC of this leading to disk space exhaustion, because multiple sstables are (almost entirely) rewritten at the same time. This seems particularly problematic because cleanup is frequently run after a cluster is expanded due to low disk space.I'm not really familiar with how we perform free disk space checks now, but it sounds like we can make some improvements here. It would be good to reduce the concurrency of cleanup operations if there isn't enough free disk space to support this.</description>
      <version>2.1.14,2.2.6,3.0.5,3.5</version>
      <fixedVersion>Legacy/Tools,Local/Compaction</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">test.unit.org.apache.cassandra.db.ScrubTest.java</file>
      <file type="M">test.unit.org.apache.cassandra.db.compaction.LeveledCompactionStrategyTest.java</file>
      <file type="M">test.unit.org.apache.cassandra.db.CleanupTest.java</file>
      <file type="M">src.java.org.apache.cassandra.tools.NodeTool.java</file>
      <file type="M">src.java.org.apache.cassandra.tools.NodeProbe.java</file>
      <file type="M">src.java.org.apache.cassandra.service.StorageServiceMBean.java</file>
      <file type="M">src.java.org.apache.cassandra.service.StorageService.java</file>
      <file type="M">src.java.org.apache.cassandra.db.compaction.CompactionManager.java</file>
      <file type="M">src.java.org.apache.cassandra.db.ColumnFamilyStore.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="11210" opendate="2016-2-23 00:00:00" fixdate="2016-3-23 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Unresolved hostname in replace address</summary>
      <description>If you provide a hostname which could not be resolved by DNS, it leads to replace args being ignored. If you provide an IP which is not in the cluster, it does the right thing and complain.</description>
      <version>2.2.6,3.0.5,3.5,3.11.5</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.config.DatabaseDescriptor.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="11215" opendate="2016-2-23 00:00:00" fixdate="2016-3-23 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Reference leak with parallel repairs on the same table</summary>
      <description>When starting multiple repairs on the same table Cassandra starts to log about reference leak as:ERROR [Reference-Reaper:1] 2016-02-23 15:02:05,516 Ref.java:187 - LEAK DETECTED: a reference (org.apache.cassandra.utils.concurrent.Ref$State@5213f926) to class org.apache.cassandra.io.sstable.format.SSTableReader$InstanceTidier@605893242:.../testrepair/standard1-dcf311a0da3411e5a5c0c1a39c091431/la-30-big was not released before the reference was garbage collectedReproducible with:ccm create repairtest -v 2.2.5 -n 3ccm startccm stress write n=1000000 -schema replication(strategy=SimpleStrategy,factor=3) keyspace=testrepair# And then perform two repairs concurrently with:ccm node1 nodetool repair testrepairI know that starting multiple repairs in parallel on the same table isn't very wise, but this shouldn't result in reference leaks.</description>
      <version>2.2.6,3.0.5,3.5</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.db.compaction.CompactionManager.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="11217" opendate="2016-2-23 00:00:00" fixdate="2016-3-23 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Only log yaml config once, at startup</summary>
      <description>CASSANDRA-6456 introduced a feature where the yaml is dumped in the log. At startup this is a nice feature, but I see that itâ€™s actually triggered every time it handshakes with a node and fails to connect and the node happens to be a seed (see here). Calling DD.getseeds() calls the SeedProvider, and if you happen to use SimpleSeedProvider it will reload the yaml config, and once again dump it out to the log.It's debatable if DD.getseeds() should trigger a reload (which I added in CASSANDRA-5459) or whether reloading the seeds should be a different method (it probably should), but we shouldn't keep logging the yaml config on every connection failure to a seed.</description>
      <version>2.2.6,3.0.5,3.5</version>
      <fixedVersion>Legacy/Core,Local/Config</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.config.YamlConfigurationLoader.java</file>
      <file type="M">src.java.org.apache.cassandra.config.DatabaseDescriptor.java</file>
      <file type="M">src.java.org.apache.cassandra.config.Config.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="11302" opendate="2016-3-4 00:00:00" fixdate="2016-3-4 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Invalid time unit conversion causing write timeouts</summary>
      <description>We've been debugging a write timeout that we saw after upgrading from the 2.0.x release line, with our particular workload. Details of that process can be found in this thread:https://www.mail-archive.com/user@cassandra.apache.org/msg46064.htmlAfter bisecting various patch release versions, and then commits, on the 2.1.x release line we've identified version 2.1.5 and this commit as the point where the timeouts first start appearing:https://github.com/apache/cassandra/commit/828496492c51d7437b690999205ecc941f41a0a9After examining the commit we believe this line was a typo:https://github.com/apache/cassandra/commit/828496492c51d7437b690999205ecc941f41a0a9#diff-c7ef124561c4cde1c906f28ad3883a88L467as it doesn't properly convert the timeout value from milliseconds to nanoseconds.After testing with the attached patch applied, we do not see timeouts on version 2.1.5 nor against 2.2.5 when we bring the patch forward. While we've tested our workload against this and we are fairly confident in the patch, we are not experts with the code base so we would prefer additional review.</description>
      <version>2.1.14,2.2.6,3.0.5,3.5</version>
      <fixedVersion>Legacy/Core</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.net.OutboundTcpConnection.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="11321" opendate="2016-3-9 00:00:00" fixdate="2016-3-9 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>&amp;#39;sstabledump -d&amp;#39; omits static rows and partition level deletions</summary>
      <description>The new sstabledump tool currently omits a partition's static row and partition level deletions.Attached patch 0001-Include-static-row-and-partition-level-deletes.patch that fixes this.Static row example:[CORP:2016]@0 Row[info=[ts=-9223372036854775808] ]: STATIC | [idx=NASDAQ ts=1457484225583260 ttl=604800 ldt=1458089025]Partition delete example:[CORP:2015]@0 deletedAt=1457491759491826, localDeletion=1457491759</description>
      <version>3.0.5,3.5</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.tools.SSTableExport.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="11330" opendate="2016-3-9 00:00:00" fixdate="2016-3-9 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Enable sstabledump to be used on 2i tables</summary>
      <description>It is sometimes useful to be able to inspect the sstables backing 2i tables, which requires a small tweak to the way the partitioner is created.Although this is an improvement rather than a bugfix, I've marked it for 3.0.x as it's really very non-invasive.</description>
      <version>3.0.5,3.5</version>
      <fixedVersion>Legacy/Tools</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.tools.SSTableExport.java</file>
      <file type="M">src.java.org.apache.cassandra.db.SerializationHeader.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="11331" opendate="2016-3-9 00:00:00" fixdate="2016-3-9 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Create Index IF NOT EXISTS throws error when index already exists</summary>
      <description>While testing with trunk, I see that issuing the following queries throws an InvalidRequest, despite being valid.CREATE KEYSPACE k WITH replication = {'class': 'SimpleStrategy', 'replication_factor': '1'} AND durable_writes = true;USE k;CREATE TABLE k.t ( id int PRIMARY KEY, v int, v2 int, v3 text);CREATE INDEX IF NOT EXISTS ON t (v2);CREATE INDEX IF NOT EXISTS ON t (v2);InvalidRequest: code=2200 [Invalid query] message="Index t_v2_idx_1 is a duplicate of existing index t_v2_idx"The second CREATE INDEX IF NOT EXISTS should work fine.</description>
      <version>3.0.5,3.5</version>
      <fixedVersion>Legacy/CQL</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">test.unit.org.apache.cassandra.cql3.validation.entities.SecondaryIndexTest.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.CreateIndexStatement.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="11344" opendate="2016-3-11 00:00:00" fixdate="2016-3-11 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Fix bloom filter sizing with LCS</summary>
      <description>Since CASSANDRA-7272 we most often over allocate the bloom filter size with LCS</description>
      <version>2.2.6,3.0.5,3.5</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.db.compaction.writers.MaxSSTableSizeWriter.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="11373" opendate="2016-3-17 00:00:00" fixdate="2016-3-17 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Cancelled compaction leading to infinite loop in compaction strategy getNextBackgroundTask</summary>
      <description>Our test is basically running nodetool repair on specific keyspaces (such as keyspace1) and the test is also triggering nodetool compact keyspace1 standard1 in the background. And so it looks like running major compactions &amp; repairs lead to that issue when using LCS.Below is an excerpt from the thread dump (the rest is attached)"CompactionExecutor:2" #33 daemon prio=1 os_prio=4 tid=0x00007f5363e64f10 nid=0x3c4e waiting for monitor entry [0x00007f53340d8000] java.lang.Thread.State: BLOCKED (on object monitor) at org.apache.cassandra.db.compaction.CompactionStrategyManager.handleNotification(CompactionStrategyManager.java:252) - waiting to lock &lt;0x00000006c9362c80&gt; (a org.apache.cassandra.db.compaction.CompactionStrategyManager) at org.apache.cassandra.db.lifecycle.Tracker.notifySSTableRepairedStatusChanged(Tracker.java:434) at org.apache.cassandra.db.compaction.CompactionManager.performAnticompaction(CompactionManager.java:550) at org.apache.cassandra.db.compaction.CompactionManager$7.runMayThrow(CompactionManager.java:465) at org.apache.cassandra.utils.WrappedRunnable.run(WrappedRunnable.java:28) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at java.lang.Thread.run(Thread.java:745) Locked ownable synchronizers: - &lt;0x00000006c9362ca8&gt; (a java.util.concurrent.ThreadPoolExecutor$Worker)"CompactionExecutor:1" #32 daemon prio=1 os_prio=4 tid=0x00007f5363e618b0 nid=0x3c4d runnable [0x00007f5334119000] java.lang.Thread.State: RUNNABLE at com.google.common.collect.Iterators$7.computeNext(Iterators.java:650) at com.google.common.collect.AbstractIterator.tryToComputeNext(AbstractIterator.java:143) at com.google.common.collect.AbstractIterator.hasNext(AbstractIterator.java:138) at com.google.common.collect.Iterators.addAll(Iterators.java:361) at com.google.common.collect.Iterables.addAll(Iterables.java:354) at org.apache.cassandra.db.compaction.LeveledManifest.getCandidatesFor(LeveledManifest.java:589) at org.apache.cassandra.db.compaction.LeveledManifest.getCompactionCandidates(LeveledManifest.java:349) - locked &lt;0x00000006d0f7a6a8&gt; (a org.apache.cassandra.db.compaction.LeveledManifest) at org.apache.cassandra.db.compaction.LeveledCompactionStrategy.getNextBackgroundTask(LeveledCompactionStrategy.java:98) - locked &lt;0x00000006d0f7a568&gt; (a org.apache.cassandra.db.compaction.LeveledCompactionStrategy) at org.apache.cassandra.db.compaction.CompactionStrategyManager.getNextBackgroundTask(CompactionStrategyManager.java:95) - locked &lt;0x00000006c9362c80&gt; (a org.apache.cassandra.db.compaction.CompactionStrategyManager) at org.apache.cassandra.db.compaction.CompactionManager$BackgroundCompactionCandidate.run(CompactionManager.java:257) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at java.lang.Thread.run(Thread.java:745)CPU usage is at 100%top -p 15386top - 12:12:40 up 1:28, 1 user, load average: 1.08, 1.11, 1.16Tasks: 1 total, 0 running, 1 sleeping, 0 stopped, 0 zombie%Cpu(s): 0.3 us, 0.0 sy, 12.4 ni, 87.2 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem: 16433792 total, 8947336 used, 7486456 free, 89552 buffersKiB Swap: 0 total, 0 used, 0 free. 3326796 cached Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND15386 automat+ 20 0 7891448 5.004g 290184 S 102.9 31.9 80:07.06 javattop shows that the compaction thread consumes all the CPU$ java -jar sjk.jar ttop -p 15386Monitoring threads ...2016-03-17T12:17:13.514+0000 Process summary process cpu=126.34% application cpu=102.81% (user=102.46% sys=0.35%) other: cpu=23.53% heap allocation rate 375mb/s[000002] user= 0.00% sys= 0.00% alloc= 0b/s - Reference Handler[000003] user= 0.00% sys= 0.00% alloc= 0b/s - Finalizer[000005] user= 0.00% sys= 0.00% alloc= 0b/s - Signal Dispatcher[000012] user= 0.00% sys= 0.00% alloc= 0b/s - RMI TCP Accept-7199[000013] user= 0.00% sys= 0.00% alloc= 0b/s - RMI TCP Accept-0[000015] user= 0.00% sys= 0.00% alloc= 476b/s - AsyncAppender-Worker-ASYNCDEBUGLOG[000016] user= 0.00% sys= 0.05% alloc= 1070b/s - ScheduledTasks:1[000017] user= 0.00% sys= 0.00% alloc= 33b/s - EXPIRING-MAP-REAPER:1[000018] user= 0.00% sys= 0.02% alloc= 1932b/s - Background_Reporter:1[000022] user= 0.00% sys= 0.00% alloc= 0b/s - MemtablePostFlush:1[000023] user= 0.00% sys= 0.00% alloc= 0b/s - MemtableReclaimMemory:1[000026] user= 0.00% sys= 0.00% alloc= 0b/s - SlabPoolCleaner[000027] user= 0.00% sys= 0.00% alloc= 0b/s - PERIODIC-COMMIT-LOG-SYNCER[000028] user= 0.00% sys= 0.00% alloc= 0b/s - COMMIT-LOG-ALLOCATOR[000029] user= 0.00% sys= 0.01% alloc= 7086b/s - OptionalTasks:1[000030] user= 0.00% sys= 0.00% alloc= 0b/s - Reference-Reaper:1[000031] user= 0.00% sys= 0.00% alloc= 0b/s - Strong-Reference-Leak-Detector:1[000032] user=99.45% sys= 0.07% alloc= 374mb/s - CompactionExecutor:1[000033] user= 0.00% sys= 0.00% alloc= 0b/s - CompactionExecutor:2[000036] user= 0.00% sys= 0.00% alloc= 0b/s - NonPeriodicTasks:1[000037] user= 0.00% sys= 0.00% alloc= 0b/s - LocalPool-Cleaner:1[000041] user= 0.00% sys= 0.00% alloc= 0b/s - IndexSummaryManager:1[000043] user= 0.00% sys= 0.01% alloc= 2705b/s - GossipTasks:1[000044] user= 0.00% sys= 0.00% alloc= 0b/s - ACCEPT-/10.200.182.146[000045] user= 0.00% sys= 0.01% alloc= 2283b/s - BatchlogTasks:1[000055] user= 0.00% sys= 0.02% alloc= 9494b/s - GossipStage:1[000056] user= 0.00% sys= 0.00% alloc= 0b/s - AntiEntropyStage:1[000057] user= 0.00% sys= 0.00% alloc= 0b/s - MigrationStage:1[000058] user= 0.00% sys= 0.00% alloc= 0b/s - MiscStage:1[000067] user= 0.00% sys= 0.02% alloc= 2445b/s - MessagingService-Incoming-/10.200.182.144[000068] user= 0.00% sys= 0.01% alloc= 968b/s - MessagingService-Outgoing-/10.200.182.144[000069] user= 0.00% sys= 0.00% alloc= 0b/s - MessagingService-Outgoing-/10.200.182.144[000070] user= 0.00% sys= 0.02% alloc= 512b/s - MessagingService-Outgoing-/10.200.182.144[000072] user= 0.00% sys= 0.00% alloc= 0b/s - NanoTimeToCurrentTimeMillis updater[000073] user= 0.00% sys= 0.02% alloc= 3113b/s - MessagingService-Incoming-/10.200.182.144[000074] user= 0.00% sys= 0.00% alloc= 0b/s - PendingRangeCalculator:1[000075] user= 0.00% sys= 0.41% alloc= 66kb/s - SharedPool-Worker-1[000076] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-2[000077] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-3[000078] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-4[000079] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-5[000080] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-6[000081] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-7[000082] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-8[000084] user= 0.00% sys= 0.00% alloc= 0b/s - Thread-2[000085] user= 0.00% sys= 0.00% alloc= 181b/s - HintsWriteExecutor:1[000091] user= 0.00% sys= 0.00% alloc= 0b/s - PO-thread-0[000092] user= 0.00% sys= 0.00% alloc= 0b/s - NodeHealthPlugin-Scheduler-thread-0[000093] user= 0.00% sys= 0.00% alloc= 0b/s - pool-10-thread-1[000094] user= 0.00% sys= 0.00% alloc= 0b/s - pool-10-thread-2[000097] user= 0.00% sys= 0.00% alloc= 0b/s - Lease RemoteMessageServer acceptor-2-1[000104] user= 0.00% sys= 0.00% alloc= 0b/s - RemoteMessageClient worker-4-1[000120] user= 0.00% sys= 0.00% alloc= 0b/s - RemoteMessageClient connection limiter - 0[000121] user= 0.00% sys= 0.00% alloc= 0b/s - threadDeathWatcher-5-1[000122] user= 0.00% sys= 0.00% alloc= 0b/s - PO-thread scheduler[000123] user= 0.00% sys= 0.00% alloc= 0b/s - JOB-TRACKER[000124] user= 0.00% sys= 0.01% alloc= 1276b/s - TASK-TRACKER[000127] user= 0.00% sys= 0.00% alloc= 0b/s - epollEventLoopGroup-6-1[000128] user= 0.00% sys= 0.00% alloc= 0b/s - epollEventLoopGroup-6-2[000129] user= 0.00% sys= 0.00% alloc= 0b/s - epollEventLoopGroup-6-3[000130] user= 0.00% sys= 0.00% alloc= 0b/s - epollEventLoopGroup-6-4[000131] user= 0.00% sys= 0.00% alloc= 0b/s - epollEventLoopGroup-6-5[000132] user= 0.00% sys= 0.00% alloc= 0b/s - epollEventLoopGroup-6-6[000133] user= 0.00% sys= 0.00% alloc= 0b/s - epollEventLoopGroup-6-7[000134] user= 0.00% sys= 0.00% alloc= 0b/s - epollEventLoopGroup-6-8[000135] user= 0.00% sys= 0.00% alloc= 0b/s - epollEventLoopGroup-6-9[000136] user= 0.00% sys= 0.00% alloc= 0b/s - epollEventLoopGroup-6-10[000137] user= 0.19% sys=-0.18% alloc= 0b/s - epollEventLoopGroup-6-11[000138] user= 0.00% sys= 0.00% alloc= 0b/s - epollEventLoopGroup-6-12[000139] user= 0.19% sys=-0.19% alloc= 0b/s - epollEventLoopGroup-6-13[000140] user= 0.00% sys= 0.00% alloc= 0b/s - epollEventLoopGroup-6-14[000141] user= 0.00% sys= 0.00% alloc= 0b/s - epollEventLoopGroup-6-15[000142] user= 0.00% sys= 0.00% alloc= 0b/s - epollEventLoopGroup-6-16[000143] user= 0.19% sys=-0.04% alloc= 13kb/s - Thread-7[000144] user= 0.00% sys= 0.00% alloc= 0b/s - taskCleanup[000145] user= 0.00% sys= 0.00% alloc= 0b/s - DseGossipStateUpdater[000146] user= 0.00% sys= 0.00% alloc= 0b/s - DestroyJavaVM[000149] user= 0.00% sys= 0.00% alloc= 0b/s - Thread-10[000150] user= 0.00% sys= 0.00% alloc= 0b/s - Thread-11[000151] user= 0.00% sys= 0.00% alloc= 0b/s - Directory/File cleanup thread[000153] user= 0.00% sys= 0.00% alloc= 0b/s - pool-15-thread-1[000190] user= 0.00% sys= 0.00% alloc= 0b/s - pool-18-thread-1[000215] user= 0.00% sys= 0.00% alloc= 0b/s - pool-10-thread-3[000217] user= 0.00% sys= 0.00% alloc= 0b/s - RMI Scheduler(0)[000220] user= 0.00% sys= 0.00% alloc= 0b/s - RMI TCP Connection(335)-10.200.182.146[000222] user= 0.00% sys= 0.00% alloc= 0b/s - pool-10-thread-4[000223] user= 0.00% sys= 0.00% alloc= 0b/s - taskCleanup[000224] user= 0.00% sys= 0.00% alloc= 0b/s - Thread-69[000225] user= 0.00% sys= 0.00% alloc= 0b/s - Thread-70[000227] user= 0.00% sys= 0.00% alloc= 0b/s - pool-19-thread-1[000254] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-9[000255] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-11[000256] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-10[000269] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-13[000270] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-12[000272] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-14[000273] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-15[000274] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-18[000275] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-19[000276] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-20[000277] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-17[000278] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-16[000279] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-22[000280] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-21[000281] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-23[000282] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-24[000283] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-25[000284] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-26[000285] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-27[000286] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-28[000287] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-29[000288] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-30[000289] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-31[000290] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-32[000296] user= 0.00% sys= 0.00% alloc= 1970b/s - pool-2-thread-1[000297] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-33[000298] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-34[000302] user= 0.00% sys= 0.01% alloc= 1576b/s - MessagingService-Incoming-/10.200.182.145[000303] user= 0.00% sys= 0.00% alloc= 451b/s - MessagingService-Outgoing-/10.200.182.145[000304] user= 0.00% sys= 0.00% alloc= 0b/s - MessagingService-Outgoing-/10.200.182.145[000305] user= 0.00% sys= 0.01% alloc= 206b/s - MessagingService-Outgoing-/10.200.182.145[000308] user= 0.00% sys= 0.00% alloc= 424b/s - MessagingService-Incoming-/10.200.182.145[000314] user= 0.00% sys= 0.00% alloc= 0b/s - StreamingTransferTaskTimeouts:1[000324] user= 0.00% sys= 0.00% alloc= 0b/s - MessagingService-Outgoing-/10.200.182.146[000325] user= 0.00% sys= 0.00% alloc= 0b/s - MessagingService-Outgoing-/10.200.182.146[000326] user= 0.00% sys= 0.00% alloc= 0b/s - MessagingService-Outgoing-/10.200.182.146[000328] user= 0.00% sys= 0.00% alloc= 0b/s - MessagingService-Incoming-/10.200.182.146[000329] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-35[000330] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-37[000331] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-36[000332] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-39[000333] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-38[000334] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-42[000335] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-41[000336] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-40[000337] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-46[000338] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-44[000339] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-45[000340] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-43[000341] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-47[000342] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-48[000343] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-50[000344] user= 0.00% sys= 0.00% alloc= 0b/s - SharedPool-Worker-49[000375] user= 0.00% sys= 0.00% alloc= 0b/s - StreamConnectionEstablisher:1[000376] user= 0.00% sys= 0.00% alloc= 0b/s - StreamConnectionEstablisher:2[000406] user= 0.00% sys= 0.00% alloc= 0b/s - MessagingService-Incoming-/10.200.182.145[000408] user= 0.00% sys= 0.00% alloc= 0b/s - MessagingService-Incoming-/10.200.182.146[000409] user= 0.00% sys= 0.00% alloc= 0b/s - MessagingService-Incoming-/10.200.182.144[000415] user= 0.00% sys= 0.00% alloc= 0b/s - StreamConnectionEstablisher:3[000418] user= 0.00% sys= 0.00% alloc= 0b/s - StreamConnectionEstablisher:4[000435] user= 0.00% sys= 0.00% alloc= 0b/s - StreamConnectionEstablisher:5[000438] user= 0.00% sys= 0.00% alloc= 0b/s - StreamConnectionEstablisher:6[000439] user= 0.00% sys= 0.00% alloc= 0b/s - StreamConnectionEstablisher:7[000444] user= 0.00% sys= 0.00% alloc= 0b/s - StreamConnectionEstablisher:8[000687] user= 0.00% sys= 0.00% alloc= 0b/s - JMX server connection timeout 687[000688] user= 2.44% sys= 0.16% alloc= 1380kb/s - RMI TCP Connection(401)-10.200.182.146[000694] user= 0.00% sys= 0.00% alloc= 0b/s - Attach Listener[000726] user= 0.00% sys= 0.00% alloc= 0b/s - RMI TCP Connection(400)-10.200.182.146[000743] user=-0.00% sys=-0.16% alloc=-109800b/s - MemtableFlushWriter:112[000745] user= 0.00% sys= 0.00% alloc= 0b/s - MemtableFlushWriter:113[000746] user= 0.00% sys= 0.03% alloc= 4295b/s - JMX server connection timeout 746</description>
      <version>2.2.6,3.0.5,3.5</version>
      <fixedVersion>Local/Compaction</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">test.unit.org.apache.cassandra.io.sstable.SSTableRewriterTest.java</file>
      <file type="M">src.java.org.apache.cassandra.db.lifecycle.LifecycleTransaction.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="11390" opendate="2016-3-21 00:00:00" fixdate="2016-3-21 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Too big MerkleTrees allocated during repair</summary>
      <description>Since CASSANDRA-5220 we create one merkle tree per range, but each of those trees is allocated to hold all the keys on the node, taking up too much memory</description>
      <version>3.0.5,3.5</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.db.compaction.CompactionManager.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="11411" opendate="2016-3-23 00:00:00" fixdate="2016-3-23 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Reduce the amount of logging during repair</summary>
      <description>We should move some repair logging to trace - currently this generates 13MB of logs on a vnode cluster for a single table</description>
      <version>2.2.6,3.0.5,3.5</version>
      <fixedVersion>Legacy/StreamingandMessaging</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.service.StorageService.java</file>
    </fixedFiles>
  </bug>
  <bug id="11444" opendate="2016-3-28 00:00:00" fixdate="2016-3-28 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Upgrade ohc to 0.4.3</summary>
      <description></description>
      <version>3.0.5,3.5</version>
      <fixedVersion>Legacy/Core</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">lib.ohc-core-j8-0.4.2.jar</file>
      <file type="M">lib.ohc-core-0.4.2.jar</file>
      <file type="M">CHANGES.txt</file>
      <file type="M">build.xml</file>
    </fixedFiles>
  </bug>
  <bug id="11451" opendate="2016-3-29 00:00:00" fixdate="2016-3-29 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Don&amp;#39;t mark sstables as repairing when doing sub range repair</summary>
      <description>Since CASSANDRA-10422 we don't do anticompaction when a user issues a sub range repair (-st X -et Y), but we still mark sstables as repairing.We should avoid marking them as users might want to run many sub range repair sessions in parallel. The reason we mark sstables is that we don't want another repair session to steal the sstables before we do anticompaction, and since we do no anticompaction with sub range repair we have no benefit from the marking.</description>
      <version>2.2.6,3.0.5,3.5</version>
      <fixedVersion>Legacy/StreamingandMessaging</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.service.ActiveRepairService.java</file>
      <file type="M">src.java.org.apache.cassandra.repair.RepairMessageVerbHandler.java</file>
      <file type="M">src.java.org.apache.cassandra.db.compaction.CompactionManager.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="6377" opendate="2013-11-19 00:00:00" fixdate="2013-3-19 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>ALLOW FILTERING should allow seq scan filtering</summary>
      <description>CREATE TABLE emp_table2 ( empID int PRIMARY KEY, firstname text, lastname text, b_mon text, b_day text, b_yr text,);INSERT INTO emp_table2 (empID,firstname,lastname,b_mon,b_day,b_yr) VALUES (100,'jane','doe','oct','31','1980');INSERT INTO emp_table2 (empID,firstname,lastname,b_mon,b_day,b_yr) VALUES (101,'john','smith','jan','01','1981');INSERT INTO emp_table2 (empID,firstname,lastname,b_mon,b_day,b_yr) VALUES (102,'mary','jones','apr','15','1982');INSERT INTO emp_table2 (empID,firstname,lastname,b_mon,b_day,b_yr) VALUES (103,'tim','best','oct','25','1982');SELECT b_mon,b_day,b_yr,firstname,lastname FROM emp_table2 WHERE b_mon='oct' ALLOW FILTERING;Bad Request: No indexed columns present in by-columns clause with Equal operator</description>
      <version>2.2.6,3.0.5,3.5</version>
      <fixedVersion>Legacy/CQL</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">test.unit.org.apache.cassandra.index.internal.CassandraIndexTest.java</file>
      <file type="M">test.unit.org.apache.cassandra.index.CustomIndexTest.java</file>
      <file type="M">test.unit.org.apache.cassandra.cql3.validation.operations.UpdateTest.java</file>
      <file type="M">test.unit.org.apache.cassandra.cql3.validation.operations.DeleteTest.java</file>
      <file type="M">src.java.org.apache.cassandra.index.internal.CassandraIndex.java</file>
      <file type="M">src.java.org.apache.cassandra.db.filter.RowFilter.java</file>
      <file type="M">test.unit.org.apache.cassandra.db.index.PerRowSecondaryIndexTest.java</file>
      <file type="M">test.unit.org.apache.cassandra.cql3.validation.operations.SelectTest.java</file>
      <file type="M">test.unit.org.apache.cassandra.cql3.validation.operations.SelectSingleColumnRelationTest.java</file>
      <file type="M">test.unit.org.apache.cassandra.cql3.validation.operations.SelectMultiColumnRelationTest.java</file>
      <file type="M">test.unit.org.apache.cassandra.cql3.validation.entities.UFIdentificationTest.java</file>
      <file type="M">test.unit.org.apache.cassandra.cql3.validation.entities.UFAuthTest.java</file>
      <file type="M">test.unit.org.apache.cassandra.cql3.validation.entities.SecondaryIndexTest.java</file>
      <file type="M">test.unit.org.apache.cassandra.cql3.validation.entities.FrozenCollectionsTest.java</file>
      <file type="M">src.java.org.apache.cassandra.db.index.SecondaryIndexManager.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.SelectStatement.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.SingleColumnRelation.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.restrictions.StatementRestrictions.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.restrictions.AbstractRestriction.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="9325" opendate="2015-5-7 00:00:00" fixdate="2015-3-7 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>cassandra-stress requires keystore for SSL but provides no way to configure it</summary>
      <description>Even though it shouldn't be required unless client certificate authentication is enabled, the stress tool is looking for a keystore in the default location of conf/.keystore with the default password of cassandra. There is no command line option to override these defaults so you have to provide a keystore that satisfies the default. It looks for conf/.keystore in the working directory, so you need to create this in the directory you are running cassandra-stress from.It doesn't really matter what's in the keystore; it just needs to exist in the expected location and have a password of cassandra.Since the keystore might be required if client certificate authentication is enabled, we need to add -transport parameters for keystore and keystore-password. Ideally, these should be optional and stress shouldn't require the keystore unless client certificate authentication is enabled on the server.In case it wasn't apparent, this is for Cassandra 2.1 and later's stress tool. I actually had even more problems getting Cassandra 2.0's stress tool working with SSL and gave up on it. We probably don't need to fix 2.0; we can just document that it doesn't support SSL and recommend using 2.1 instead.</description>
      <version>2.2.6,3.0.5,3.5</version>
      <fixedVersion>Legacy/Tools</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">tools.stress.src.org.apache.cassandra.stress.settings.SettingsTransport.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
</bugrepository>
