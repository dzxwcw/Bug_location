<?xml version="1.0" encoding="UTF-8"?>

<bugrepository name="CASSANDRA">
  <bug id="1974" opendate="2011-1-12 00:00:00" fixdate="2011-5-12 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>PFEPS-like snitch that uses gossip instead of a property file</summary>
      <description>Now that we have an ec2 snitch that propagates its rack/dc info via gossip from CASSANDRA-1654, it doesn't make a lot of sense to use PFEPS where you have to rsync the property file across all the machines when you add a node. Instead, we could have a snitch where you specify its rack/dc in a property file, and propagate this via gossip like the ec2 snitch. In order to not break PFEPS, this should probably be a new snitch.</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>New Feature</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.locator.PropertyFileSnitch.java</file>
      <file type="M">conf.cassandra.yaml</file>
    </fixedFiles>
  </bug>
  <bug id="2261" opendate="2011-3-2 00:00:00" fixdate="2011-2-2 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>During Compaction, Corrupt SSTables with rows that cause failures should be identified and blacklisted.</summary>
      <description>When a compaction of a set of SSTables fails because of corruption it will continue to try to compact that SSTable causing pending compactions to build up.One way to mitigate this problem would be to log the error, then identify the specific SSTable that caused the failure, subsequently blacklisting that SSTable and ensuring that it is no longer included in future compactions. For this we could simply store the problematic SSTable's name in memory.If it's not possible to identify the SSTable that caused the issue, then perhaps blacklisting the (ordered) permutation of SSTables to be compacted together is something that can be done to solve this problem in a more general case, and avoid issues where two (or more) SSTables have trouble compacting a particular row. For this option we would probably want to store the lists of the bad combinations in the system table somewhere s.t. these can survive a node failure (there have been a few cases where I have seen a compaction cause a node failure).</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">test.unit.org.apache.cassandra.db.compaction.CompactionsTest.java</file>
      <file type="M">src.java.org.apache.cassandra.io.sstable.SSTableScanner.java</file>
      <file type="M">src.java.org.apache.cassandra.io.sstable.SSTableReader.java</file>
      <file type="M">src.java.org.apache.cassandra.io.sstable.SSTableIdentityIterator.java</file>
      <file type="M">src.java.org.apache.cassandra.io.sstable.SSTableBoundedScanner.java</file>
      <file type="M">src.java.org.apache.cassandra.db.compaction.SizeTieredCompactionStrategy.java</file>
      <file type="M">src.java.org.apache.cassandra.db.compaction.LeveledManifest.java</file>
      <file type="M">src.java.org.apache.cassandra.db.compaction.AbstractCompactionStrategy.java</file>
      <file type="M">src.java.org.apache.cassandra.db.columniterator.SSTableSliceIterator.java</file>
      <file type="M">src.java.org.apache.cassandra.db.columniterator.SSTableNamesIterator.java</file>
      <file type="M">src.java.org.apache.cassandra.db.columniterator.SimpleSliceReader.java</file>
      <file type="M">src.java.org.apache.cassandra.db.columniterator.IndexedSliceReader.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="2506" opendate="2011-4-19 00:00:00" fixdate="2011-2-19 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Push read repair setting down to the DC-level</summary>
      <description>Currently, read repair is a global setting. However, when you have two DCs and use one for analytics, it would be nice to turn it off only for that DC so the live DC serving the application can still benefit from it.</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>New Feature</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.resources.org.apache.cassandra.cli.CliHelp.yaml</file>
      <file type="M">src.java.org.apache.cassandra.service.ReadCallback.java</file>
      <file type="M">src.java.org.apache.cassandra.service.DatacenterReadCallback.java</file>
      <file type="M">src.java.org.apache.cassandra.cql.CreateColumnFamilyStatement.java</file>
      <file type="M">src.java.org.apache.cassandra.cql.CFPropDefs.java</file>
      <file type="M">src.java.org.apache.cassandra.cql.AlterTableStatement.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.CreateColumnFamilyStatement.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.AlterTableStatement.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.CFPropDefs.java</file>
      <file type="M">src.java.org.apache.cassandra.config.CFMetaData.java</file>
      <file type="M">src.java.org.apache.cassandra.cli.CliClient.java</file>
      <file type="M">src.avro.internode.genavro</file>
      <file type="M">interface.thrift.gen-java.org.apache.cassandra.thrift.CfDef.java</file>
      <file type="M">interface.thrift.gen-java.org.apache.cassandra.thrift.Cassandra.java</file>
      <file type="M">interface.cassandra.thrift</file>
    </fixedFiles>
  </bug>
  <bug id="2635" opendate="2011-5-11 00:00:00" fixdate="2011-4-11 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>make cache skipping optional</summary>
      <description>We've applied this patch locally in order to turn of page skipping; not completely but only for compaction/repair situations where it can be directly detrimental in the sense of causing data to become cold even though your entire data set fits in memory.It's better than completely disabling DONTNEED because the cache skipping does make sense and has no relevant (that I can see) detrimental effects in some cases, like when dumping caches.The patch is against 0.7.5 right now but if the change is desired I can make a patch for trunk. Also, the name of the configuration option is dubious since saying 'false' does not actually turn it off completely. I wasn't able to figure out a good name that conveyed the functionality in a short brief name however.A related concern as discussed in CASSANDRA-1902 is that the cache skipping isn't fsync:ing and so won't work reliably on writes. If the feature is to be retained that's something to fix in a different ticket.A question is also whether to retain the default to true or change it to false. I'm kinda leaning to false since it's detrimental in the "easy" cases of little data. In "big" cases with lots of data people will have to think and tweak anyway, so better to put the burden on that end.</description>
      <version>1.1.1,1.2.0beta1</version>
      <fixedVersion>None</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.io.sstable.SSTableWriter.java</file>
      <file type="M">src.java.org.apache.cassandra.config.DatabaseDescriptor.java</file>
      <file type="M">src.java.org.apache.cassandra.config.Config.java</file>
      <file type="M">conf.cassandra.yaml</file>
    </fixedFiles>
  </bug>
  <bug id="2889" opendate="2011-7-12 00:00:00" fixdate="2011-4-12 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Avoids having replicate on write tasks stacking up at CL.ONE</summary>
      <description>The counter design involves a read on the first replica during a write. At CL.ONE, this read is not involved in the latency of the operation (the write is acknowledged before). This means it is fairly easy to insert too quickly at CL.ONE and have the replicate on write tasks falling behind. The goal of this ticket is to protect against that.An option could be to bound the replicate on write task queue so that write start to block once we have too much of those in the queue. Another option could be to drop the oldest tasks when they are too old, but it's probably a more unsafe option.</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.concurrent.StageManager.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="3012" opendate="2011-8-10 00:00:00" fixdate="2011-2-10 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>cassandra-cli list &lt;CF&gt; limit number of columns returned</summary>
      <description>Right now in the CLI, running: list MyColumnFamily; will return the first 100 rows and quite easily the bazillion columns associated with those rows. Often times you're interested in just the row keys in the CF and less interested in all the columns or perhaps only a subset of columns.Hence it would be nice to have the limit option take a second, optional parameter limiting the number of columns to return:list MyCF&amp;#91;startkey:&amp;#93; limit 10, 30;would limit the columns per row to 30 while limiting the number of rows to 10 and starting at key "startkey". It should also take values 0 (no columns) and -1 (all columns). -1 should also be acceptable as a row limit also denoting "all rows" rather then requiring the user to type a large positive number.</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">test.unit.org.apache.cassandra.cli.CliTest.java</file>
      <file type="M">src.resources.org.apache.cassandra.cli.CliHelp.yaml</file>
      <file type="M">src.java.org.apache.cassandra.cli.CliClient.java</file>
      <file type="M">src.java.org.apache.cassandra.cli.Cli.g</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="3412" opendate="2011-10-27 00:00:00" fixdate="2011-2-27 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>make nodetool ring ownership smarter</summary>
      <description>just a thought.. the ownership info currently just look at the token and calculate the % between nodes. It would be nice if it could do more, such as discriminate nodes of each DC, replica set, etc. ticket is open for suggestion...</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.tools.NodeProbe.java</file>
      <file type="M">src.java.org.apache.cassandra.tools.NodeCmd.java</file>
      <file type="M">src.java.org.apache.cassandra.service.StorageServiceMBean.java</file>
      <file type="M">src.java.org.apache.cassandra.service.StorageService.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="3721" opendate="2012-1-10 00:00:00" fixdate="2012-2-10 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Staggering repair</summary>
      <description>Currently repair runs on all the nodes at once and causing the range of data to be hot (higher latency on reads).Sequence:1) Send a repair request to all of the nodes so we can hold the references of the SSTables (point at which repair was initiated)2) Send Validation on one node at a time (once completed will release references).3) Hold the reference of the tree in the requesting node and once everything is complete start diff.We can also serialize the streaming part not more than 1 node is involved in the streaming.</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">test.unit.org.apache.cassandra.io.CompactSerializerTest.java</file>
      <file type="M">CHANGES.txt</file>
      <file type="M">src.java.org.apache.cassandra.tools.NodeProbe.java</file>
      <file type="M">src.java.org.apache.cassandra.tools.NodeCmd.java</file>
      <file type="M">src.java.org.apache.cassandra.service.StorageServiceMBean.java</file>
      <file type="M">src.java.org.apache.cassandra.service.StorageService.java</file>
      <file type="M">src.java.org.apache.cassandra.service.AntiEntropyService.java</file>
      <file type="M">src.java.org.apache.cassandra.db.Directories.java</file>
      <file type="M">src.java.org.apache.cassandra.db.compaction.CompactionManager.java</file>
      <file type="M">src.java.org.apache.cassandra.db.ColumnFamilyStore.java</file>
    </fixedFiles>
  </bug>
  <bug id="3741" opendate="2012-1-13 00:00:00" fixdate="2012-5-13 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>OOMs because delete operations are not accounted</summary>
      <description>Currently we are moving to new data format where new format is written into new CFs and old one is deleted key-by-key. I have started getting OOMs and found out that delete operations are not accounted and so, column families are not flushed (changed == 0 with delete only operations) by storage manager.This is pull request that fixed this problem for me: https://github.com/apache/cassandra/pull/5</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.db.ColumnFamily.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="3771" opendate="2012-1-23 00:00:00" fixdate="2012-5-23 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Allow paging through non-ordered partitioner results in CQL3</summary>
      <description>CQL &lt; 3 silently turns a "key &gt;= X" into "token(key) &gt;= token(X)". This is not what users will expect, since many of the rows returned will not in fact satisfy the requested key inequality. We should add syntax that makes the difference between keys and tokens explicit, possibly with a token() "function" as imagined here.</description>
      <version>1.1.1</version>
      <fixedVersion>Legacy/CQL</fixedVersion>
      <type>Sub-task</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.cql3.Term.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.SelectStatement.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.Relation.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.Cql.g</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="3867" opendate="2012-2-6 00:00:00" fixdate="2012-2-6 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Disablethrift and Enablethrift can leaves behind zombie connections on THSHA server</summary>
      <description>While doing nodetool disable thrift we disable selecting threads and close them... but the connections are still active...Enable thrift creates a new Selector threads because we create new ThriftServer() which will cause the old connections to be zombies.I think the right fix will be to call server.interrupt(); and then close the connections when they are done selecting.</description>
      <version>1.0.8,1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.thrift.CustomTHsHaServer.java</file>
    </fixedFiles>
  </bug>
  <bug id="3882" opendate="2012-2-9 00:00:00" fixdate="2012-6-9 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>avoid distributed deadlock in migration stage</summary>
      <description>This is follow-up work for the remainders of CASSANDRA-3832 which was only a partial fix. The deadlock in the migration stage needs to be fixed, as it can cause bootstrap (at least) to take potentially a very very long time to complete, and might also cause a lack of schema propagation until otherwise "poked".</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.service.MigrationManager.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="3909" opendate="2012-2-14 00:00:00" fixdate="2012-4-14 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Pig should handle wide rows</summary>
      <description>Pig should be able to use the wide row support in CFIF.</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.hadoop.pig.CassandraStorage.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="3912" opendate="2012-2-15 00:00:00" fixdate="2012-4-15 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>repair user provided custom token range (support incremental repair controlled by external agent)</summary>
      <description>As a poor man's pre-cursor to CASSANDRA-2699, exposing the ability to repair small parts of a range is extremely useful because it allows (with external scripting logic) to slowly repair a node's content over time. Other than avoiding the bulkyness of complete repairs, it means that you can safely do repairs even if you absolutely cannot afford e.g. disk spaces spikes (see CASSANDRA-2699 for what the issues are).Attaching a patch that exposes a "repairincremental" command to nodetool, where you specify a step and the number of total steps. Incrementally performing a repair in 100 steps, for example, would be done by:nodetool repairincremental 0 100nodetool repairincremental 1 100...nodetool repairincremental 99 100An external script can be used to keep track of what has been repaired and when. This should allow (1) allow incremental repair to happen now/soon, and (2) allow experimentation and evaluation for an implementation of CASSANDRA-2699 which I still think is a good idea. This patch does nothing to help the average deployment, but at least makes incremental repair possible given sufficient effort spent on external scripting.The big "no-no" about the patch is that it is entirely specific to RandomPartitioner and BigIntegerToken. If someone can suggest a way to implement this command generically using the Range/Token abstractions, I'd be happy to hear suggestions.An alternative would be to provide a nodetool command that allows you to simply specify the specific token ranges on the command line. It makes using it a bit more difficult, but would mean that it works for any partitioner and token type.Unless someone can suggest a better way to do this, I think I'll provide a patch that does this. I'm still leaning towards supporting the simple "step N out of M" form though.</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>New Feature</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.tools.NodeProbe.java</file>
      <file type="M">src.java.org.apache.cassandra.service.StorageServiceMBean.java</file>
      <file type="M">src.java.org.apache.cassandra.service.StorageService.java</file>
      <file type="M">src.java.org.apache.cassandra.service.AntiEntropyService.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="3936" opendate="2012-2-21 00:00:00" fixdate="2012-3-21 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Gossip should have a &amp;#39;goodbye&amp;#39; command to indicate shutdown</summary>
      <description>Cassandra is crash-only, however there are times when you know you are taking the node down (rolling restarts, for instance) where it would be advantageous to instantly have the node marked down rather than wait on the FD. We could also improve the efficacy of the 'disablegossip' command this way as well.</description>
      <version>1.1.1,1.2.0beta1</version>
      <fixedVersion>None</fixedVersion>
      <type>New Feature</type>
    </buginformation>
    <fixedFiles>
      <file type="M">test.unit.org.apache.cassandra.dht.BootStrapperTest.java</file>
      <file type="M">src.java.org.apache.cassandra.service.StorageService.java</file>
      <file type="M">src.java.org.apache.cassandra.gms.IFailureDetector.java</file>
      <file type="M">src.java.org.apache.cassandra.gms.Gossiper.java</file>
      <file type="M">src.java.org.apache.cassandra.gms.FailureDetector.java</file>
    </fixedFiles>
  </bug>
  <bug id="3949" opendate="2012-2-23 00:00:00" fixdate="2012-2-23 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>[patch] presize arraylists where possible</summary>
      <description>many places the size of an ArrayList is easily predetermined, in those cases pre size them as appropriate, to avoid reallocations.</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.thrift.CassandraServer.java</file>
      <file type="M">src.java.org.apache.cassandra.streaming.StreamRequestMessage.java</file>
      <file type="M">src.java.org.apache.cassandra.service.StorageService.java</file>
      <file type="M">src.java.org.apache.cassandra.service.StorageProxy.java</file>
      <file type="M">src.java.org.apache.cassandra.service.MigrationManager.java</file>
      <file type="M">src.java.org.apache.cassandra.service.CacheService.java</file>
      <file type="M">src.java.org.apache.cassandra.net.MessagingService.java</file>
      <file type="M">src.java.org.apache.cassandra.locator.SimpleSeedProvider.java</file>
      <file type="M">src.java.org.apache.cassandra.io.sstable.ReducingKeyIterator.java</file>
      <file type="M">src.java.org.apache.cassandra.gms.GossipDigestSynVerbHandler.java</file>
      <file type="M">src.java.org.apache.cassandra.dht.Range.java</file>
      <file type="M">src.java.org.apache.cassandra.dht.OrderPreservingPartitioner.java</file>
      <file type="M">src.java.org.apache.cassandra.dht.AbstractByteOrderedPartitioner.java</file>
      <file type="M">src.java.org.apache.cassandra.db.Table.java</file>
      <file type="M">src.java.org.apache.cassandra.db.SystemTable.java</file>
      <file type="M">src.java.org.apache.cassandra.db.SliceByNamesReadCommand.java</file>
      <file type="M">src.java.org.apache.cassandra.db.RowMutation.java</file>
      <file type="M">src.java.org.apache.cassandra.db.marshal.AbstractCompositeType.java</file>
      <file type="M">src.java.org.apache.cassandra.db.index.SecondaryIndexManager.java</file>
      <file type="M">src.java.org.apache.cassandra.db.DefsTable.java</file>
      <file type="M">src.java.org.apache.cassandra.db.compaction.SizeTieredCompactionStrategy.java</file>
      <file type="M">src.java.org.apache.cassandra.db.compaction.ParallelCompactionIterable.java</file>
      <file type="M">src.java.org.apache.cassandra.db.compaction.CompactionManager.java</file>
      <file type="M">src.java.org.apache.cassandra.db.ColumnFamilyStore.java</file>
      <file type="M">src.java.org.apache.cassandra.cql.QueryProcessor.java</file>
      <file type="M">src.java.org.apache.cassandra.cql.DeleteStatement.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.SelectStatement.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.DeleteStatement.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.CreateColumnFamilyStatement.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.BatchStatement.java</file>
      <file type="M">src.java.org.apache.cassandra.config.KSMetaData.java</file>
    </fixedFiles>
  </bug>
  <bug id="3969" opendate="2012-2-28 00:00:00" fixdate="2012-2-28 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>[patch] remove duplicate code</summary>
      <description>code does ColumnFamilyStore cfs = Table.open(command.keyspace).getColumnFamilyStore(command.column_family);twice in a row.(executeLocally is the only code that needs to do this, not doVerb)</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.service.RangeSliceVerbHandler.java</file>
    </fixedFiles>
  </bug>
  <bug id="3971" opendate="2012-2-28 00:00:00" fixdate="2012-2-28 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>[patch] make hasSameReplication safer/more readable</summary>
      <description>code was iterating over passed in list parameter, and using the list indices on a seemingly unrelated list. However, in the one case where this method is used the passed in list and the referenced list in the method were actually the same. Change code to just reference the method parameter list, so it's clear what's going on.patch against trunk.</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.service.StorageService.java</file>
    </fixedFiles>
  </bug>
  <bug id="3978" opendate="2012-2-29 00:00:00" fixdate="2012-3-29 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>[patch] quell all the warnings around DecoratorKey and generics</summary>
      <description>against trunk</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">test.unit.org.apache.cassandra.db.KeyCollisionTest.java</file>
      <file type="M">src.java.org.apache.cassandra.service.RowRepairResolver.java</file>
      <file type="M">src.java.org.apache.cassandra.service.DigestMismatchException.java</file>
      <file type="M">src.java.org.apache.cassandra.service.AbstractRowResolver.java</file>
      <file type="M">src.java.org.apache.cassandra.io.sstable.SSTableWriter.java</file>
      <file type="M">src.java.org.apache.cassandra.io.sstable.SSTableScanner.java</file>
      <file type="M">src.java.org.apache.cassandra.io.sstable.SSTableReader.java</file>
      <file type="M">src.java.org.apache.cassandra.io.sstable.SSTableIdentityIterator.java</file>
      <file type="M">src.java.org.apache.cassandra.io.sstable.SSTable.java</file>
      <file type="M">src.java.org.apache.cassandra.io.sstable.ReducingKeyIterator.java</file>
      <file type="M">src.java.org.apache.cassandra.io.sstable.KeyIterator.java</file>
      <file type="M">src.java.org.apache.cassandra.io.sstable.IndexSummary.java</file>
      <file type="M">src.java.org.apache.cassandra.dht.RandomPartitioner.java</file>
      <file type="M">src.java.org.apache.cassandra.dht.OrderPreservingPartitioner.java</file>
      <file type="M">src.java.org.apache.cassandra.dht.LocalPartitioner.java</file>
      <file type="M">src.java.org.apache.cassandra.dht.IPartitioner.java</file>
      <file type="M">src.java.org.apache.cassandra.dht.AbstractByteOrderedPartitioner.java</file>
      <file type="M">src.java.org.apache.cassandra.db.Table.java</file>
      <file type="M">src.java.org.apache.cassandra.db.SliceFromReadCommand.java</file>
      <file type="M">src.java.org.apache.cassandra.db.SliceByNamesReadCommand.java</file>
      <file type="M">src.java.org.apache.cassandra.db.Row.java</file>
      <file type="M">src.java.org.apache.cassandra.db.migration.Migration.java</file>
      <file type="M">src.java.org.apache.cassandra.db.index.SecondaryIndexManager.java</file>
      <file type="M">src.java.org.apache.cassandra.db.index.SecondaryIndexBuilder.java</file>
      <file type="M">src.java.org.apache.cassandra.db.index.PerRowSecondaryIndex.java</file>
      <file type="M">src.java.org.apache.cassandra.db.index.PerColumnSecondaryIndex.java</file>
      <file type="M">src.java.org.apache.cassandra.db.index.keys.KeysIndex.java</file>
      <file type="M">src.java.org.apache.cassandra.db.HintedHandOffManager.java</file>
      <file type="M">src.java.org.apache.cassandra.db.filter.SliceQueryFilter.java</file>
      <file type="M">src.java.org.apache.cassandra.db.filter.QueryFilter.java</file>
      <file type="M">src.java.org.apache.cassandra.db.filter.NamesQueryFilter.java</file>
      <file type="M">src.java.org.apache.cassandra.db.filter.IFilter.java</file>
      <file type="M">src.java.org.apache.cassandra.db.DecoratedKey.java</file>
      <file type="M">src.java.org.apache.cassandra.db.compaction.PrecompactedRow.java</file>
      <file type="M">src.java.org.apache.cassandra.db.compaction.AbstractCompactedRow.java</file>
      <file type="M">src.java.org.apache.cassandra.db.ColumnFamilyStore.java</file>
    </fixedFiles>
  </bug>
  <bug id="3982" opendate="2012-2-29 00:00:00" fixdate="2012-5-29 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Explore not returning range ghosts</summary>
      <description>This ticket proposes to remove range ghosts in CQL3.The basic argument is that range ghosts confuses users a lot and don't add any value since range ghost don't allow to distinguish between the two following case: the row is deleted the row is not deleted but don't have data for the provided filter</description>
      <version>1.1.1</version>
      <fixedVersion>Legacy/CQL</fixedVersion>
      <type>Sub-task</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.SelectStatement.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="4004" opendate="2012-3-6 00:00:00" fixdate="2012-5-6 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Add support for ReversedType</summary>
      <description>It would be nice to add a native syntax for the use of ReversedType. I'm sure there is anything in SQL that we inspired ourselves from, so I would propose something like:CREATE TABLE timeseries ( key text, time uuid, value text, PRIMARY KEY (key, time DESC))Alternatively, the DESC could also be put after the column name definition but one argument for putting it in the PK instead is that this only apply to keys.</description>
      <version>1.1.1</version>
      <fixedVersion>Legacy/CQL</fixedVersion>
      <type>Sub-task</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.cql.SelectStatement.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.SelectStatement.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.CreateColumnFamilyStatement.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.Cql.g</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="4010" opendate="2012-3-7 00:00:00" fixdate="2012-5-7 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Report thrift status in nodetool info</summary>
      <description>Improve nodetool info command by reporting thrift status. Add following line:Thrift active: true</description>
      <version>1.0.11,1.1.1</version>
      <fixedVersion>Tool/nodetool</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.tools.NodeCmd.java</file>
    </fixedFiles>
  </bug>
  <bug id="4045" opendate="2012-3-13 00:00:00" fixdate="2012-4-13 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>BOF fails when some nodes are down</summary>
      <description>As the summary says, we should allow jobs to complete when some targets are unavailable.</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.hadoop.BulkRecordWriter.java</file>
    </fixedFiles>
  </bug>
  <bug id="4052" opendate="2012-3-15 00:00:00" fixdate="2012-4-15 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Add way to force the cassandra-cli to refresh it&amp;#39;s schema</summary>
      <description>By design, the cassandra-cli caches the schema and doesn't refresh it when various commands like "describe keyspaces" are run. This is reasonable, and it is easy enough to restart the cli if necessary. However, this does lead to confusion since a new user can reasonably assume that describe keyspaces will always show an accurate current represention of the ring. We should find a way to reduce the surprise (and lack of easy discoverability) of this behaviour.I propose any one of the following(#1 is probably the easiest and most likely):1) Add a command (that would be documented in the cli's help) to explicitly refresh the schema ("schema refresh", "refresh schema", or anything similar).2) Always force a refresh of the schema when performing at least the "describe keyspaces" command.3) Add a flag to cassandra-cli to explicitly enable schema caching. If that flag is not passed, then schema caching will be disabled for that session. This suggestion assumes that for simple deployments (few CFs, etc), schema caching isn't very important to the performance of the cli.</description>
      <version>1.1.1</version>
      <fixedVersion>Legacy/Tools</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">CHANGES.txt</file>
      <file type="M">src.java.org.apache.cassandra.cli.CliClient.java</file>
    </fixedFiles>
  </bug>
  <bug id="4079" opendate="2012-3-23 00:00:00" fixdate="2012-4-23 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Check SSTable range before running cleanup</summary>
      <description>Before running a cleanup compaction on an SSTable we should check the range to see if the SSTable falls into the range we want to remove. If it doesn't we can just mark the SSTable as compacted and be done with it, if it does, we can no-op.Will not help with STCS, but for LCS, and perhaps some others we may see a benefit here after topology changes.</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.dht.Range.java</file>
      <file type="M">src.java.org.apache.cassandra.dht.AbstractBounds.java</file>
      <file type="M">src.java.org.apache.cassandra.db.compaction.CompactionManager.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="4080" opendate="2012-3-23 00:00:00" fixdate="2012-3-23 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Cut down on the comparisons needed during shouldPurge and needDeserialize</summary>
      <description>shouldPurge in particular is still a performance sore point with LCS.</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.db.ColumnFamilyStore.java</file>
    </fixedFiles>
  </bug>
  <bug id="4092" opendate="2012-3-27 00:00:00" fixdate="2012-4-27 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Allow getting a simple Token-&gt;node map over thrift</summary>
      <description>Right now the thrift describe_ring call is intended to be used to determine ownership for a keyspace. It can also (and often is) be used by clients to just get a view of what the ring looks like. Since it requires a keyspace as an argument though, it can sometimes be impossible to see what the ring looks like. For example, in a 2 DC/2 node ring where keyspace X exists only dc1. The results of 'describe_ring X' would look something like (with tokens 0 and 10):{[0,10]: [node0], [10,0]: [node0]}This is indicating that node0 owns everything for that keyspace since it only exists in 1 datacenter. From this output though it is impossible to tell which token (0 or 10) node0 owns, as well as what the other node in the cluster is.There are two options here. Allow running describe_ring with no parameters to get a view of token-&gt;ip without taking replication into consideration. Add a new thrift call to achieve this.</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">test.system.test.thrift.server.py</file>
      <file type="M">src.java.org.apache.cassandra.thrift.CassandraServer.java</file>
      <file type="M">interface.thrift.gen-java.org.apache.cassandra.thrift.Cassandra.java</file>
      <file type="M">interface.cassandra.thrift</file>
    </fixedFiles>
  </bug>
  <bug id="4098" opendate="2012-3-28 00:00:00" fixdate="2012-4-28 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Listing wide-rows from CLI crashes Cassandra</summary>
      <description>If a user attempts to list a column family from the CLI that contains a wide-row (e.g. 10 million columns). It crashes hangs the CLI and then Cassandra eventually crashes with an OoM. We should introduce a default limit on columns when listing a column family.(patch on its way)</description>
      <version>1.1.1</version>
      <fixedVersion>Legacy/Tools</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.net.IncomingTcpConnection.java</file>
      <file type="M">src.java.org.apache.cassandra.cli.CliClient.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="4100" opendate="2012-3-28 00:00:00" fixdate="2012-4-28 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Make scrub and cleanup operations throttled</summary>
      <description>Looks like scrub and cleanup operations are not throttled and it will be nice to throttle else we are likely to run into IO issues while running it on live cluster.</description>
      <version>1.1.1,1.2.0beta1</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.db.compaction.ParallelCompactionIterable.java</file>
      <file type="M">src.java.org.apache.cassandra.db.compaction.CompactionManager.java</file>
      <file type="M">src.java.org.apache.cassandra.db.compaction.CompactionIterable.java</file>
      <file type="M">src.java.org.apache.cassandra.db.compaction.CompactionController.java</file>
      <file type="M">src.java.org.apache.cassandra.db.compaction.AbstractCompactionIterable.java</file>
    </fixedFiles>
  </bug>
  <bug id="4115" opendate="2012-4-4 00:00:00" fixdate="2012-5-4 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>UNREACHABLE schema after decommissioning a non-seed node</summary>
      <description>decommission a non-seed node, sleep 30 seconds, then use thrift to check the schema. UNREACHABLE is listed:{'75dc4c07-3c1a-3013-ad7d-11fb34208465': ['127.0.0.1'], 'UNREACHABLE': ['127.0.0.2']}</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.service.StorageService.java</file>
      <file type="M">src.java.org.apache.cassandra.gms.Gossiper.java</file>
    </fixedFiles>
  </bug>
  <bug id="4116" opendate="2012-4-4 00:00:00" fixdate="2012-5-4 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>check most recent TS values in SSTables when a row tombstone has already been encountered</summary>
      <description>once C* comes across a row tombstone, C* should check the TS on the tombstone against all SSTables. If the most recent TS in an SST is older than the row tombstone, that entire SST (or the remainder of it) can be safely ignored.There are two drivers for this. avoid checking column values that could not possibly be in the result set avoid OOMing because all the tombstones are temporarily kept in memory.</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.db.ColumnFamily.java</file>
      <file type="M">src.java.org.apache.cassandra.db.CollationController.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="4146" opendate="2012-4-13 00:00:00" fixdate="2012-4-13 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>sstableloader should detect and report failures</summary>
      <description>There are three cases where we have observed the abnormal termination1) In case of exception while loading.2) User terminates the loading process.3) If some node is down OR un-reachable then sstableloader get stucked.In this case user have to terminate the process in between.In case of abnormal termination, sstables (which are added in this session) remains as it is on the cluster.In case user starts the process all over again by fixing the exception, it results in duplication of the data till Major compaction is triggered.sstableloader can maintain the session while loading the sstables in cluster.So in case of abnormal termination sstableloader triggers the event that will delete the sstables loaded in that session.Also It would be great to have timeout in case of sstableloader.That can be kept configurable.So if sstableloader process got stucked for period longer than timeout, it can terminate itself.</description>
      <version>1.1.1</version>
      <fixedVersion>Legacy/Tools</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.tools.BulkLoader.java</file>
      <file type="M">src.java.org.apache.cassandra.streaming.FileStreamTask.java</file>
      <file type="M">src.java.org.apache.cassandra.io.sstable.SSTableLoader.java</file>
    </fixedFiles>
  </bug>
  <bug id="4153" opendate="2012-4-15 00:00:00" fixdate="2012-4-15 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Optimize truncate when snapshots are disabled or keyspace not durable</summary>
      <description>My goal is to make truncate to be less IO intensive so that my junit tests run faster (as already explained in CASSANDRA-3710). I think I have now a solution which does not change too much:I created a patch that optimizes three things within truncate: Skip the whole Commitlog.forceNewSegment/discardCompletedSegments, if durable_writes are disabled for the keyspace. With CASSANDRA-3710 implemented, truncate does not need to flush memtables to disk when snapshots are disabled. Reduce the sleep intervalThe patch works nicely for me. Applying it and disabling durable_writes/autoSnapshot increased the speed of my testsuite vastly. I hope I did not overlook something.Let me know if my patch needs cleanup. I'd be glad to change it, if it means the patch will get accepted.</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.db.ColumnFamilyStore.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="4160" opendate="2012-4-17 00:00:00" fixdate="2012-5-17 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>ORDER BY ... DESC reverses comparrison predicates in WHERE</summary>
      <description>When issuing a cql select statement with an ORDER BY ... DESC clause the comparison predicates in the WHERE clause gets reversed. Example: (see also attached)SELECT number FROM test WHERE number &lt; 3 ORDER BY number DESCreturns the results expected of WHERE number &gt; 3</description>
      <version>1.1.1</version>
      <fixedVersion>Legacy/CQL</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.tools.NodeCmd.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.SelectStatement.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="4164" opendate="2012-4-18 00:00:00" fixdate="2012-5-18 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Cqlsh should support DESCRIBE on cql3-style composite CFs</summary>
      <description>There is a discrepancy between create column family commands and then the output of the describe command:cqlsh:test&gt; CREATE TABLE timeline ( ... user_id varchar, ... tweet_id uuid, ... author varchar, ... body varchar, ... PRIMARY KEY (user_id, tweet_id) ... );cqlsh:test&gt; describe columnfamily timeline;CREATE COLUMNFAMILY timeline ( user_id text PRIMARY KEY) WITH comment='' AND comparator='CompositeType(org.apache.cassandra.db.marshal.UUIDType,org.apache.cassandra.db.marshal.UTF8Type)' AND read_repair_chance=0.100000 AND gc_grace_seconds=864000 AND default_validation=text AND min_compaction_threshold=4 AND max_compaction_threshold=32 AND replicate_on_write=True AND compaction_strategy_class='SizeTieredCompactionStrategy' AND compression_parameters:sstable_compression='org.apache.cassandra.io.compress.SnappyCompressor';</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">pylib.cqlshlib.cqlhandling.py</file>
      <file type="M">bin.cqlsh</file>
    </fixedFiles>
  </bug>
  <bug id="4168" opendate="2012-4-18 00:00:00" fixdate="2012-5-18 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>"Setup" section of tools/stress/README.txt needs update</summary>
      <description>The README.txt file states "Run `ant` from the Cassandra source directory, then Run `ant` from the contrib/stress directory."The file needs to reflect the changes in the way stress is built.</description>
      <version>1.0.10,1.1.1</version>
      <fixedVersion>Legacy/Tools</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">build.xml</file>
    </fixedFiles>
  </bug>
  <bug id="4173" opendate="2012-4-19 00:00:00" fixdate="2012-5-19 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>cqlsh: in cql3 mode, use cql3 quoting when outputting cql</summary>
      <description>when cqlsh needs to output a column name or other term which needs quoting (say, if you run DESCRIBE KEYSPACE and some column name has a space in it), it currently only knows how to quote in the cql2 way. That is,cqlsh:foo&gt; describe columnfamily barCREATE COLUMNFAMILY bar ( a int PRIMARY KEY, 'b c' text) WITH...cql3 does not recognize single quotes around column names, or columnfamily or keyspace names either. cqlsh ought to learn how to use double-quotes instead when in cql3 mode.</description>
      <version>1.1.1</version>
      <fixedVersion>Legacy/Tools</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">pylib.cqlshlib.cql3handling.py</file>
      <file type="M">bin.cqlsh</file>
    </fixedFiles>
  </bug>
  <bug id="4178" opendate="2012-4-20 00:00:00" fixdate="2012-5-20 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>JNA link failure logging confusing on OSX</summary>
      <description>I was somewhat surprised to learn that even though "Unable to link C library. Native methods will be disabled." was logged on startup, some JNA native calls were made.</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.utils.CLibrary.java</file>
    </fixedFiles>
  </bug>
  <bug id="4183" opendate="2012-4-25 00:00:00" fixdate="2012-5-25 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Fix dependency versions in generated pos</summary>
      <description>Some of the versions of dependencies have fallen out of sync</description>
      <version>1.1.1</version>
      <fixedVersion>Packaging</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">build.xml</file>
    </fixedFiles>
  </bug>
  <bug id="4184" opendate="2012-4-25 00:00:00" fixdate="2012-4-25 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Make identifier and value grammar for CQL3 stricter</summary>
      <description>The current grammar for CQL3 allows: uuid and integer constants as identifiers identifier as value (aka term in the grammar)I think both of those should be removed.For 1, mostly because this feels useless and slightly complicates the grammar which is annoying for the documentation of CQL3 for instance (note that this doesn't mean forbidding integer or uuid as identifier, but means they have to be double-quoted when used as such).For 2, I think that allowing identifier as value is actually misleading, typically if you write things like SELECT foo WHERE foo=foo. It suggests we support JOIN when we do not.Also, if both are done, then one will always be able to distinguish between identifier and value even without any context, which is a nice property.</description>
      <version>1.1.1</version>
      <fixedVersion>Legacy/CQL</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.cql3.Cql.g</file>
    </fixedFiles>
  </bug>
  <bug id="4185" opendate="2012-4-25 00:00:00" fixdate="2012-5-25 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Minor CQL3 fixes</summary>
      <description>The goal of this ticket is to be the home for a number of minor fixes/improvements in CQL3 that I didn't felt warranted a ticket each. It includes 4 patches: The first one fixes the grammar for float constants, so as to not recognize 3.-3, but to actually allow 3. (i.e, with radix point but with the fractional part left blank) The second one correctly detect the (invalid) case where a table is created with COMPACT STORAGE but without any 'clustering keys'. The third one fixes COUNT, first by making sure both COUNT and COUNT(1) are correctly recognized and also by "processing" the internal row before counting, are there isn't a 1-to-1 correspondence between internal rows and CQL rows in CQL3. The grammar change in this patch actually rely on CASSANDRA-4184 The fourth and last patch disallows the counter type for keys (i.e. any column part of the PRIMARY KEY) as it is completely non-sensical and will only led to confusion.</description>
      <version>1.1.1</version>
      <fixedVersion>Legacy/CQL</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.SelectStatement.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.CreateColumnFamilyStatement.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.AlterTableStatement.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.Cql.g</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="4186" opendate="2012-4-25 00:00:00" fixdate="2012-5-25 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>CQL3: make some keywords unreserved</summary>
      <description>CQL has quite a few keywords. Currently all of them are reserved, but this is not always necessary. PostreSQL for instance distinguish between reserved keywords and non-reserved ones, and allow things like key, timestamp or type as identifiers. I suggest we do the same as convenience for the user.</description>
      <version>1.1.1</version>
      <fixedVersion>Legacy/CQL</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.cql3.Cql.g</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="4187" opendate="2012-4-25 00:00:00" fixdate="2012-5-25 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>CQL3: move {max/min}_compaction_thresholds to compaction options</summary>
      <description>It makes way more sense to have min_compaction_threshold and max_compaction_threshold be parts of the compaction_strategy_options. They are not in thrift (and CQL2) only for historical reasons, but there is no reason not to fix it. Especially given that they don't make sense for all compaction strategy (Leveled compaction ignores them).</description>
      <version>1.1.1</version>
      <fixedVersion>Legacy/CQL</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.CreateColumnFamilyStatement.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.AlterTableStatement.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.CFPropDefs.java</file>
      <file type="M">src.java.org.apache.cassandra.config.CFMetaData.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="4190" opendate="2012-4-25 00:00:00" fixdate="2012-4-25 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Apparent data loss using super columns and row cache via ConcurrentLinkedHashCacheProvider</summary>
      <description>Tested on a vanilla single-node cassandra 1.0.9 installation.When using super columns along with row caching via ConcurrentLinkedHashCacheProvider (default if no JNA available, or explicitly configured even if JNA available), there's what appears as transient data loss.Given this script executed in cassandra-cli:create keyspace Test;use Test;create column family Users with column_type='Super' and key_validation_class='UTF8Type' and comparator='UTF8Type' and subcomparator='UTF8Type' and default_validation_class='UTF8Type' and rows_cached=75000 and row_cache_provider='ConcurrentLinkedHashCacheProvider';set Users&amp;#91;&amp;#39;mina&amp;#39;&amp;#93;&amp;#91;&amp;#39;attrs&amp;#39;&amp;#93;&amp;#91;&amp;#39;name&amp;#39;&amp;#93; = 'Mina';get Users&amp;#91;&amp;#39;mina&amp;#39;&amp;#93;;set Users&amp;#91;&amp;#39;mina&amp;#39;&amp;#93;&amp;#91;&amp;#39;attrs&amp;#39;&amp;#93;&amp;#91;&amp;#39;country&amp;#39;&amp;#93; = 'Canada';get Users&amp;#91;&amp;#39;mina&amp;#39;&amp;#93;;set Users&amp;#91;&amp;#39;mina&amp;#39;&amp;#93;&amp;#91;&amp;#39;attrs&amp;#39;&amp;#93;&amp;#91;&amp;#39;region&amp;#39;&amp;#93; = 'Quebec';get Users&amp;#91;&amp;#39;mina&amp;#39;&amp;#93;;The output from the 3 gets above is as follows:=&gt; (super_column=attrs, (column=name, value=Mina, timestamp=1335377788441000))Returned 1 results.=&gt; (super_column=attrs, (column=name, value=Mina, timestamp=1335377788441000))Returned 1 results.=&gt; (super_column=attrs, (column=name, value=Mina, timestamp=1335377788441000))Returned 1 results.It's clear that the second and third set commands (country, region) are missing in the returned results.If the row cache is explicitly invalidated (in a second terminal, via `nodetool -h localhost invalidaterowcache Test Users`), the missing data springs to life on next 'get':&amp;#91;default@Test&amp;#93; get Users&amp;#91;&amp;#39;mina&amp;#39;&amp;#93;;=&gt; (super_column=attrs, (column=country, value=Canada, timestamp=1335377839592000) (column=name, value=Mina, timestamp=1335377788441000) (column=region, value=Quebec, timestamp=1335377871353000))Returned 1 results.From cursory checks, this does not to appear to happen with regular columns, nor with JNA enabled + SerializingCacheProvider.</description>
      <version>1.0.10,1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.db.ColumnFamily.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="4192" opendate="2012-4-26 00:00:00" fixdate="2012-5-26 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>CQL3: fix index dropping and assign default name if none provided at index creation</summary>
      <description>This ticket proposes to fix two problems of CQL3 index handling: DROP INDEX is broken (because the code forgot to clone the metadata before doing modification which break the schema update path) If an index is created with a name (which CREATE INDEX allow), there is no way to drop the index (note that we will internally assign a name to the index ColumnFamilyStore, but we don't assign a name in the ColumnDefinition object, which is the only one checked by DROP INDEX).</description>
      <version>1.1.1</version>
      <fixedVersion>Legacy/CQL</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.DropIndexStatement.java</file>
      <file type="M">src.java.org.apache.cassandra.config.CFMetaData.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="4197" opendate="2012-4-30 00:00:00" fixdate="2012-5-30 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Index caching</summary>
      <description>Currently, the "hidden" CFs backing secondary indexes are created with Caching.NONE, which can result in slower-than-expected index queries.</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.db.index.keys.KeysIndex.java</file>
      <file type="M">src.java.org.apache.cassandra.config.CFMetaData.java</file>
    </fixedFiles>
  </bug>
  <bug id="4198" opendate="2012-4-30 00:00:00" fixdate="2012-5-30 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>cqlsh: update recognized syntax for cql3</summary>
      <description>cqlsh should recognize cql3 syntax when in cql3 mode; this includes tab completing proper syntax and properly quoting any terms in single- or double-quotes (current version only knows how to use single quotes).also, prefer using the term "TABLE" over "COLUMNFAMILY" wherever one of those is generated from cqlsh (like in DESCRIBE output).and if it's not too bad, it would help to have the online help strings reflect cql3 syntax (maybe with a nod to cql2 restrictions where appropriate).</description>
      <version>1.1.1</version>
      <fixedVersion>Legacy/Tools</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">pylib.cqlshlib.pylexotron.py</file>
      <file type="M">pylib.cqlshlib.cqlhandling.py</file>
      <file type="M">pylib.cqlshlib.cql3handling.py</file>
      <file type="M">bin.cqlsh</file>
    </fixedFiles>
  </bug>
  <bug id="4199" opendate="2012-4-30 00:00:00" fixdate="2012-5-30 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>There should be an easy way to find out which sstables a key lives in</summary>
      <description>When debugging, often times on a live server you want to extract a certain key with sst2j, but unfortunately you can't know which sstable(s) you need to run this on, causing you to iterate over much more data than necessary.</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.tools.NodeProbe.java</file>
      <file type="M">src.java.org.apache.cassandra.tools.NodeCmd.java</file>
      <file type="M">src.java.org.apache.cassandra.io.sstable.SSTableReader.java</file>
      <file type="M">src.java.org.apache.cassandra.db.ColumnFamilyStoreMBean.java</file>
      <file type="M">src.java.org.apache.cassandra.db.ColumnFamilyStore.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="4205" opendate="2012-5-1 00:00:00" fixdate="2012-5-1 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>SSTables are not updated with max timestamp on upgradesstables/compaction leading to non-optimal performance.</summary>
      <description>We upgraded from 0.7.9 to 1.0.7 on a cluster with a heavy update load. After converting all the reads to named column reads instead of get_slice calls, we noticed that we still weren't getting the performance improvements implemented in CASSANDRA-2498. A single named column read was still touching multiple SSTables according to nodetool cfhistograms. To verify whether or not this was a reporting issue or a real issue, we ran multiple tests with stress and noticed that it worked as expected. After changing stress so that it ran the read/write test directly in the CF having issues (3 times stress &amp; flush), we noticed that stress also touched multiple SSTables (according to cfhistograms).So, the root of the problem is "something" left over from our pre-1.0 days. All SSTables were upgraded with upgradesstables, and have been written and compacted many times since the upgrade (4 months ago). The usage pattern for this CF is that it is constantly read and updated (overwritten), but no deletes. After discussing the problem with Brandon Williams on #cassandra, it seems the problem might be because a max timestamp has never been written for the old SSTables that were upgraded from pre 1.0. They have only been compacted, and the max timestamp is not recorded during compactions. A suggested fix is to special case this in upgradesstables so that a max timestamp always exists for all SSTables. 06:08 &lt; driftx&gt; thorkild_: tx. The thing is we don't record the max timestamp on compactions, but we can do it specially for upgradesstables.06:08 &lt; driftx&gt; so, nothing in... nothing out.06:10 &lt; thorkild_&gt; driftx: ah, so when you upgrade from before the metadata was written, and that data is only feed through upgradesstables and compactions -&gt; never properly written?06:10 &lt; thorkild_&gt; that makes sense.06:11 &lt; driftx&gt; right, we never create it, we just reuse it</description>
      <version>1.0.10,1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.io.sstable.SSTableMetadata.java</file>
      <file type="M">src.java.org.apache.cassandra.io.sstable.Descriptor.java</file>
    </fixedFiles>
  </bug>
  <bug id="4224" opendate="2012-5-7 00:00:00" fixdate="2012-5-7 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>more user friendly error messages from nodetool on common connection failures</summary>
      <description>(Since I actually whined about this one in my Cassandra Europe talk i might as well fix it)Typing 'nodetool -h localhos ring' gives me 37 lines of scary looking call traces with the significant information embeded in line 11 from the end. Just because I mistyped my hostname.I propose we catch common exceptions, print a more user friendly message to stderr and exit.</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.tools.NodeCmd.java</file>
    </fixedFiles>
  </bug>
  <bug id="4233" opendate="2012-5-9 00:00:00" fixdate="2012-5-9 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>overlapping sstables in leveled compaction strategy</summary>
      <description>CASSANDRA-4142 introduces test failures, that are caused by overlapping tables within a level, which Shouldn't Happen.</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.db.compaction.LeveledManifest.java</file>
      <file type="M">src.java.org.apache.cassandra.db.compaction.LeveledCompactionTask.java</file>
      <file type="M">src.java.org.apache.cassandra.db.compaction.LeveledCompactionStrategy.java</file>
      <file type="M">src.java.org.apache.cassandra.db.ColumnFamilyStore.java</file>
      <file type="M">src.java.org.apache.cassandra.db.CollationController.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="4246" opendate="2012-5-15 00:00:00" fixdate="2012-5-15 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>cql3 ORDER BY not ordering</summary>
      <description>Creating the simplest composite-key cql3 table I can think of, populating it with a few rows of data, then trying to do a query with an ORDER BY does not yield ordered results.Here's a cql script:create keyspace test with strategy_class = 'SimpleStrategy' and strategy_options:replication_factor = 1;use test;create table moo (a int, b int, c int, primary key (a, b));insert into moo (a, b, c) values (123, 12, 3400);insert into moo (a, b, c) values (122, 13, 3500);insert into moo (a, b, c) values (124, 10, 3600);insert into moo (a, b, c) values (121, 11, 3700);select * from moo;select * from moo order by b;Here is the output of those two queries: a | b | c-----+----+------ 121 | 11 | 3700 122 | 13 | 3500 124 | 10 | 3600 123 | 12 | 3400 a | b | c-----+----+------ 121 | 11 | 3700 122 | 13 | 3500 124 | 10 | 3600 123 | 12 | 3400I also tried these using the bare thrift interface, to make sure it wasn't python-cql or cqlsh doing something stupid. Same results. Am I totally missing something important here about how this is supposed to work?</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.SelectStatement.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="4252" opendate="2012-5-16 00:00:00" fixdate="2012-5-16 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Set operation mode to MOVING earlier</summary>
      <description>Right now when moving a node we set the OperationMode only once we've calculated the necessary ranges to transfer and if there actually are ranges to transfer. Due to the sleep for ring settling this means there are 30 seconds where the node is moving but the operation mode isn't set accordingly. Additionally if it turns out no data needs to be transferred then the move will complete without ever switching the OperationMode to moving.</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.service.StorageService.java</file>
    </fixedFiles>
  </bug>
  <bug id="4264" opendate="2012-5-21 00:00:00" fixdate="2012-6-21 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>live ratio limit 64.0 is way too low</summary>
      <description>Currently live ratio is limited to 64.0. This is way too low.WARN &amp;#91;MemoryMeter:1&amp;#93; Memtable.java (line 181) setting live ratio to maximum of 64 instead of xxxxvalues seen in log are ofter larger than 64.0 limit. I propose to use 100.0 as new limit.ponto:(admin)log/cassandra&gt;grep "to maximum of 64" system.log.1 WARN &amp;#91;MemoryMeter:1&amp;#93; 2012-02-03 00:00:19,444 Memtable.java (line 181) setting live ratio to maximum of 64 instead of 64.9096047648211 WARN &amp;#91;MemoryMeter:1&amp;#93; 2012-02-08 00:00:17,379 Memtable.java (line 181) setting live ratio to maximum of 64 instead of 68.81016452376322 WARN &amp;#91;MemoryMeter:1&amp;#93; 2012-02-08 00:00:32,358 Memtable.java (line 181) setting live ratio to maximum of 64 instead of 88.49747308025415 WARN &amp;#91;MemoryMeter:1&amp;#93; 2012-02-09 00:00:08,448 Memtable.java (line 181) setting live ratio to maximum of 64 instead of 76.2444888765154 WARN &amp;#91;MemoryMeter:1&amp;#93; 2012-02-10 18:18:52,677 Memtable.java (line 181) setting live ratio to maximum of 64 instead of 142.22477982642255 WARN &amp;#91;MemoryMeter:1&amp;#93; 2012-02-20 00:00:53,753 Memtable.java (line 181) setting live ratio to maximum of 64 instead of 88.19832386767173 WARN &amp;#91;MemoryMeter:1&amp;#93; 2012-03-02 10:41:00,232 Memtable.java (line 181) setting live ratio to maximum of 64 instead of 419.9607495592804 WARN &amp;#91;MemoryMeter:1&amp;#93; 2012-03-07 14:13:15,141 Memtable.java (line 181) setting live ratio to maximum of 64 instead of Infinity WARN &amp;#91;MemoryMeter:1&amp;#93; 2012-03-08 00:01:12,766 Memtable.java (line 181) setting live ratio to maximum of 64 instead of 94.20215772717702 WARN &amp;#91;MemoryMeter:1&amp;#93; 2012-03-09 00:00:38,633 Memtable.java (line 181) setting live ratio to maximum of 64 instead of 98.54003447121715 WARN &amp;#91;MemoryMeter:1&amp;#93; 2012-03-11 00:00:13,243 Memtable.java (line 181) setting live ratio to maximum of 64 instead of 193.14262214179965 WARN &amp;#91;MemoryMeter:1&amp;#93; 2012-03-14 00:00:26,709 Memtable.java (line 181) setting live ratio to maximum of 64 instead of 103.88360138951437</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.db.SuperColumn.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="4266" opendate="2012-5-21 00:00:00" fixdate="2012-5-21 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Validate compression parameters</summary>
      <description>compression_parameters doesn't warn when unknown options are specified; see http://ac31004.blogspot.co.uk/2012/05/snappy-compression-fails-for-apache.html</description>
      <version>1.0.11,1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.io.compress.SnappyCompressor.java</file>
      <file type="M">src.java.org.apache.cassandra.io.compress.ICompressor.java</file>
      <file type="M">src.java.org.apache.cassandra.io.compress.DeflateCompressor.java</file>
      <file type="M">src.java.org.apache.cassandra.io.compress.CompressionParameters.java</file>
      <file type="M">src.java.org.apache.cassandra.cql.CFPropDefs.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.CFPropDefs.java</file>
      <file type="M">src.java.org.apache.cassandra.config.CFMetaData.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="4278" opendate="2012-5-23 00:00:00" fixdate="2012-5-23 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Can&amp;#39;t specify certain keyspace properties in CQL</summary>
      <description>A user using EC2MultiRegionSnitch, where the datacenter name has to match the AWS region names, will not be able to specify a keyspace's replica counts for those datacenters using CQL. AWS region names contain hyphens, which are not valid identifiers in CQL, and CQL keyspace/columnfamily properties must be identifiers or identifiers separated by colons.Example:CREATE KEYSPACE Foo WITH strategy_class = 'NetworkTopologyStrategy' AND strategy_options:"us-east"=1 AND strategy_options:"us-west"=1;(see http://mail-archives.apache.org/mod_mbox/cassandra-user/201205.mbox/browser for context)..will not currently work, with or without the double quotes.CQL should either allow hyphens in COMPIDENT, or allow quoted parts of a COMPIDENT token.</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.cql3.Cql.g</file>
      <file type="M">src.java.org.apache.cassandra.cql3.CFPropDefs.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="4279" opendate="2012-5-23 00:00:00" fixdate="2012-5-23 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>kick off background compaction when min/max changed</summary>
      <description>When the threshold changes, we may be eligible for a compaction immediately (without waiting for a flush to trigger the eligibility check).</description>
      <version>1.0.11,1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.db.ColumnFamilyStore.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="4280" opendate="2012-5-23 00:00:00" fixdate="2012-5-23 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>2I CFs should inherit parent compaction settings</summary>
      <description></description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.config.CFMetaData.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="4294" opendate="2012-5-29 00:00:00" fixdate="2012-6-29 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Upgrading encounters: &amp;#39;SimpleStrategy requires a replication_factor strategy option.&amp;#39; and refuses to start</summary>
      <description>I've seen this reported quite a few times now:ERROR [main] 2012-05-29 19:33:40,589 AbstractCassandraDaemon.java (line 370) Exception encountered during startupjava.lang.RuntimeException: org.apache.cassandra.config.ConfigurationException: SimpleStrategy requires a replication_factor strategy option. at org.apache.cassandra.db.Table.&lt;init&gt;(Table.java:275) at org.apache.cassandra.db.Table.open(Table.java:114) at org.apache.cassandra.db.Table.open(Table.java:97) at org.apache.cassandra.service.AbstractCassandraDaemon.setup(AbstractCassandraDaemon.java:204) at org.apache.cassandra.service.AbstractCassandraDaemon.activate(AbstractCassandraDaemon.java:353) at org.apache.cassandra.thrift.CassandraDaemon.main(CassandraDaemon.java:106)Caused by: org.apache.cassandra.config.ConfigurationException: SimpleStrategy requires a replication_factor strategy option. at org.apache.cassandra.locator.SimpleStrategy.validateOptions(SimpleStrategy.java:71) at org.apache.cassandra.locator.AbstractReplicationStrategy.createReplicationStrategy(AbstractReplicationStrategy.java:218) at org.apache.cassandra.db.Table.createReplicationStrategy(Table.java:295) at org.apache.cassandra.db.Table.&lt;init&gt;(Table.java:271) ... 5 moreThe common thread seems to be old lineage, from at least 0.7. 1.0.x works fine, but upgrading to 1.1 causes the problem.</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.config.Avro.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="4296" opendate="2012-5-30 00:00:00" fixdate="2012-5-30 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>CQL3: create table don&amp;#39;t always validate access to the right keyspace</summary>
      <description>Create table allows (like other queries) to override the currently set keyspace (CREATE TABLE foo.bar ...). However, when we do that, the access check is done on the wrong keyspace. In particular if no keyspace was set, this end up in a NPE.</description>
      <version>1.1.1</version>
      <fixedVersion>Legacy/CQL</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.service.ClientState.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.SchemaAlteringStatement.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="556" opendate="2009-11-14 00:00:00" fixdate="2009-4-14 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>nodeprobe snapshot to support specific column families</summary>
      <description>It would be good to support dumping specific column families via nodeprobe for backup purposes.In my particular case the majority of cassandra data doesn't need to be backed up except for a couple of column families containing user settings / profiles etc.</description>
      <version>1.1.1</version>
      <fixedVersion>None</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">test.unit.org.apache.cassandra.service.StorageServiceServerTest.java</file>
      <file type="M">src.java.org.apache.cassandra.tools.NodeProbe.java</file>
      <file type="M">src.java.org.apache.cassandra.tools.NodeCmd.java</file>
      <file type="M">src.java.org.apache.cassandra.service.StorageServiceMBean.java</file>
      <file type="M">src.java.org.apache.cassandra.service.StorageService.java</file>
      <file type="M">src.java.org.apache.cassandra.db.Table.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
</bugrepository>
