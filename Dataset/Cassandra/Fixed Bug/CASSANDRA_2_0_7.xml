<?xml version="1.0" encoding="UTF-8"?>

<bugrepository name="CASSANDRA">
  <bug id="5708" opendate="2013-6-26 00:00:00" fixdate="2013-3-26 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Add DELETE ... IF EXISTS to CQL3</summary>
      <description>I've been slightly lazy in CASSANDRA-5443 and didn't added a DELETE .. IF EXISTS syntax to CQL because it wasn't immediately clear what was the correct condition to use for the "IF EXISTS". But at least for CQL3 tables, this is in fact pretty easy to do using the row marker so we should probably add it.</description>
      <version>2.0.7,2.1beta2</version>
      <fixedVersion>None</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.UpdateStatement.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.ModificationStatement.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.DeleteStatement.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.CQL3CasConditions.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.BatchStatement.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.Cql.g</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="6168" opendate="2013-10-8 00:00:00" fixdate="2013-3-8 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>nodetool status should issue a warning when no keyspace is specified</summary>
      <description>Seen in 1.2.10.Apologies if this is expected behavior. Nodetool status reports 0% ownership unless I add a keyspace name.nodetool help docs says:..." status - Print cluster information (state, load, IDs, ...)"...output without keyspace nameDatacenter: DC1===============Status=Up/Down|/ State=Normal/Leaving/Joining/Moving-- Address Load Tokens Owns Host ID RackUN 10.x.x.146 81.96 GB 256 0.0% a70c59b3-a667-4d76-ba5b-ba849ad672da r1UN 10.x.x.63 95.32 GB 256 0.0% f8cb7b10-4ebe-484a-a1c0-6cb2d053901b r1UN 10.x.x.184 89.54 GB 256 0.1% cd86c420-55e2-4d99-8ed9-d9ee8d6a9d9c r1UN 10.x.x.190 79.68 GB 256 0.0% 544c3906-bc02-400d-9fd2-1e39ecadd6ff r1UN 10.x.x.168 93.44 GB 256 0.7% 33be316f-1276-475d-90cf-2667950d3a2c r1UN 10.x.x.132 84.4 GB 256 0.0% b327d9f1-cab0-4583-8e5e-95c50b4074fd r1Datacenter: DCOFFLINE=====================Status=Up/Down|/ State=Normal/Leaving/Joining/Moving-- Address Load Tokens Owns Host ID RackUN 10.x.x.62 56.09 GB 256 32.4% c8994d27-767b-431f-bdc2-9196eeeb6f44 r1UN 10.x.x.131 60.11 GB 256 32.8% 0b9d3314-039e-4f88-8ba6-d0f2885d9a30 r1UN 10.x.x.167 56.45 GB 256 34.0% ba76f4fe-4250-4839-a37d-c1a7c24e585d r1and with keyspace. Example: nodetool status MYKSPSDatacenter: DC1===============Status=Up/Down|/ State=Normal/Leaving/Joining/Moving-- Address Load Tokens Owns (effective) Host ID RackUN 10.x.x.184 89.51 GB 256 50.0% cd86c420-55e2-4d99-8ed9-d9ee8d6a9d9c r1UN 10.x.x.146 81.96 GB 256 50.0% a70c59b3-a667-4d76-ba5b-ba849ad672da r1UN 10.x.x.168 93.44 GB 256 50.0% 33be316f-1276-475d-90cf-2667950d3a2c r1UN 10.x.x.63 95.32 GB 256 50.0% f8cb7b10-4ebe-484a-a1c0-6cb2d053901b r1UN 10.x.x.190 79.68 GB 256 50.0% 544c3906-bc02-400d-9fd2-1e39ecadd6ff r1UN 10.x.x.132 84.4 GB 256 50.0% b327d9f1-cab0-4583-8e5e-95c50b4074fd r1Datacenter: DCOFFLINE=====================Status=Up/Down|/ State=Normal/Leaving/Joining/Moving-- Address Load Tokens Owns (effective) Host ID RackUN 10.x.x.131 60.11 GB 256 32.8% 0b9d3314-039e-4f88-8ba6-d0f2885d9a30 r1UN 10.x.x.167 56.45 GB 256 34.7% ba76f4fe-4250-4839-a37d-c1a7c24e585d r1UN 10.x.x.62 56.09 GB 256 32.5% c8994d27-767b-431f-bdc2-9196eeeb6f44 r1</description>
      <version>1.2.16,2.0.7,2.1beta2</version>
      <fixedVersion>Tool/nodetool</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.tools.NodeCmd.java</file>
    </fixedFiles>
  </bug>
  <bug id="6376" opendate="2013-11-19 00:00:00" fixdate="2013-3-19 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Pig tests are failing</summary>
      <description>On my box, all pig tests are failing with the following stack: [junit] Testcase: org.apache.cassandra.pig.CqlTableDataTypeTest: Caused an ERROR [junit] null [junit] java.lang.ExceptionInInitializerError [junit] at org.apache.cassandra.pig.PigTestBase.startHadoopCluster(PigTestBase.java:104) [junit] at org.apache.cassandra.pig.CqlTableDataTypeTest.setup(CqlTableDataTypeTest.java:198) [junit] Caused by: java.lang.NullPointerException [junit] at org.apache.hadoop.hdfs.MiniDFSCluster.startDataNodes(MiniDFSCluster.java:422) [junit] at org.apache.hadoop.hdfs.MiniDFSCluster.&lt;init&gt;(MiniDFSCluster.java:280) [junit] at org.apache.hadoop.hdfs.MiniDFSCluster.&lt;init&gt;(MiniDFSCluster.java:124) [junit] at org.apache.pig.test.MiniCluster.setupMiniDfsAndMrClusters(MiniCluster.java:50) [junit] at org.apache.pig.test.MiniGenericCluster.&lt;init&gt;(MiniGenericCluster.java:49) [junit] at org.apache.pig.test.MiniCluster.&lt;init&gt;(MiniCluster.java:31) [junit] at org.apache.pig.test.MiniGenericCluster.&lt;clinit&gt;(MiniGenericCluster.java:45)On CASSANDRA-6375, Brandon reported that it was the case on his box too, so I don't think it's a local to my machine. Seems to be a relatively basic setup thing though, not an actual test failure.I'll also note that we have a specific target for pig tests and that this target uses a longer timeout than the one for the test target. If that's because pig tests typically don't finish within the test timeout, then it would be nice to exclude them from the normal test target (and maybe include them in the long-test target).</description>
      <version>1.2.16,2.0.7,2.1beta2</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">test.unit.org.apache.cassandra.pig.CqlTableTest.java</file>
    </fixedFiles>
  </bug>
  <bug id="6514" opendate="2013-12-19 00:00:00" fixdate="2013-3-19 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Nodetool Refresh / CFS.loadNewSSTables() can Lose New SSTables</summary>
      <description>When nodetool refresh / CFS.loadNewSSTables() renames the newly loaded SSTables, it doesn't check to make sure the new name doesn't already exist. It's easy for one of the newly loaded files themselves to have one of these names, so the rename will wipe out one of the SSTables you intended to load.For example, if you create a new, empty table, move two SSTables with generations 1 and 2 into the data directory, and then call nodetool refresh, you might see this:INFO 15:37:42,587 Loading new SSTables for duration_test/ints... INFO 15:37:42,601 Renaming new SSTable /var/lib/cassandra/data/duration_test/ints/duration_test-ints-jb-2 to /var/lib/cassandra/data/duration_test/ints/duration_test-ints-jb-1 INFO 15:37:42,605 Opening /var/lib/cassandra/data/duration_test/ints/duration_test-ints-jb-1 (424005 bytes) INFO 15:37:42,614 Renaming new SSTable /var/lib/cassandra/data/duration_test/ints/duration_test-ints-jb-1 to /var/lib/cassandra/data/duration_test/ints/duration_test-ints-jb-2 INFO 15:37:42,615 Opening /var/lib/cassandra/data/duration_test/ints/duration_test-ints-jb-2 (424005 bytes) INFO 15:37:42,617 Loading new SSTables and building secondary indexes for duration_test/ints: [SSTableReader(path='/var/lib/cassandra/data/duration_test/ints/duration_test-ints-jb-1-Data.db'), SSTableReader(path='/var/lib/cassandra/data/duration_test/ints/duration_test-ints-jb-2-Data.db')] INFO 15:37:42,618 Done loading load new SSTables for duration_test/intsERROR 15:38:09,428 Exception in thread Thread[ReadStage:40,5,main]java.lang.RuntimeException: java.lang.RuntimeException: java.io.FileNotFoundException: /var/lib/cassandra/data/duration_test/ints/duration_test-ints-jb-1-Data.db (No such file or directory) at org.apache.cassandra.service.StorageProxy$DroppableRunnable.run(StorageProxy.java:1939) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) at java.lang.Thread.run(Thread.java:724)</description>
      <version>2.0.7,2.1beta2</version>
      <fixedVersion>Tool/nodetool</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">test.unit.org.apache.cassandra.db.ColumnFamilyStoreTest.java</file>
      <file type="M">src.java.org.apache.cassandra.db.ColumnFamilyStore.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="6646" opendate="2014-2-3 00:00:00" fixdate="2014-3-3 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Disk Failure Policy ignores CorruptBlockException</summary>
      <description>If Cassandra is using compression and has a bad drive or stable, it will throw an CorruptBlockException. Disk Failure Policy only works if it is an FSError and does not work for IOExceptions like this. We need to better handle such exceptions as it causes nodes to not respond to the co-ordinator causing the client to timeout.</description>
      <version>2.0.7,2.1beta2</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.service.CassandraDaemon.java</file>
      <file type="M">src.java.org.apache.cassandra.io.util.FileUtils.java</file>
      <file type="M">src.java.org.apache.cassandra.config.Config.java</file>
      <file type="M">conf.cassandra.yaml</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="6773" opendate="2014-2-26 00:00:00" fixdate="2014-3-26 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Delimiter not working for special characters in COPY command from CQLSH</summary>
      <description>COPY command from CQLSH which can be used to load data from CSV files is not working with option delimiter='\t'cqlsh&gt;CREATE TABLE airplanes (name text PRIMARY KEY,manufacturer ascii,year int,mach float);cqlsh&gt;INSERT INTO airplanes (name, manufacturer, year, mach) VALUES ('P38-Lightning', 'Lockheed', 1937, 7);cqlsh&gt; SELECT * FROM airplanes; name | mach | manufacturer | year -----------------------------+----- P38-Lightning | 0.7 | Lockheed | 1937cqlsh&gt; COPY airplanes (name, manufacturer, year, mach) TO 'temp.tsv' WITH DELIMITER = '\t';"delimiter" must be an 1-character stringcqlsh&gt; COPY airplanes (name, manufacturer, year, mach) FROM 'temp.csv' WITH DELIMITER = '\t';"delimiter" must be an 1-character string</description>
      <version>1.2.16,2.0.7,2.1beta2</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">bin.cqlsh</file>
    </fixedFiles>
  </bug>
  <bug id="6787" opendate="2014-3-1 00:00:00" fixdate="2014-4-1 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>assassinate should continue when the endpoint vanishes</summary>
      <description>Assassinate can NPE in various situations, most notably if the endpoint vanishes during the sleep-for-safety check.</description>
      <version>1.2.17,2.0.7</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.gms.Gossiper.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="6789" opendate="2014-3-1 00:00:00" fixdate="2014-3-1 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Triggers can not be added from thrift</summary>
      <description>While playing with groovy triggers, I determined that you can not add triggers from thrift, unless I am doing something wrong. (I see no coverage of this feature from thrift/python)https://github.com/edwardcapriolo/cassandra/compare/trigger_coverage?expand=1package org.apache.cassandra.triggers;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.util.ArrayList;import java.util.Arrays;import java.util.HashMap;import java.util.List;import java.util.Map;import junit.framework.Assert;import org.apache.cassandra.SchemaLoader;import org.apache.cassandra.config.Schema;import org.apache.cassandra.service.EmbeddedCassandraService;import org.apache.cassandra.thrift.CassandraServer;import org.apache.cassandra.thrift.CfDef;import org.apache.cassandra.thrift.ColumnParent;import org.apache.cassandra.thrift.KsDef;import org.apache.cassandra.thrift.ThriftSessionManager;import org.apache.cassandra.thrift.TriggerDef;import org.apache.cassandra.utils.ByteBufferUtil;import org.apache.thrift.TException;import org.junit.BeforeClass;import org.junit.Test;public class TriggerTest extends SchemaLoader{ private static CassandraServer server; @BeforeClass public static void setup() throws IOException, TException { Schema.instance.clear(); // Schema are now written on disk and will be reloaded new EmbeddedCassandraService().start(); ThriftSessionManager.instance.setCurrentSocket(new InetSocketAddress(9160)); server = new CassandraServer(); server.set_keyspace("Keyspace1"); } @Test public void createATrigger() throws TException { TriggerDef td = new TriggerDef(); td.setName("gimme5"); Map&lt;String,String&gt; options = new HashMap&lt;&gt;(); options.put("class", "org.apache.cassandra.triggers.ITriggerImpl"); td.setOptions(options); CfDef cfDef = new CfDef(); cfDef.setKeyspace("Keyspace1"); cfDef.setTriggers(Arrays.asList(td)); cfDef.setName("triggercf"); server.system_add_column_family(cfDef); KsDef keyspace1 = server.describe_keyspace("Keyspace1"); CfDef triggerCf = null; for (CfDef cfs :keyspace1.cf_defs){ if (cfs.getName().equals("triggercf")){ triggerCf=cfs; } } Assert.assertNotNull(triggerCf); Assert.assertEquals(1, triggerCf.getTriggers().size()); }}junit.framework.AssertionFailedError: expected:&lt;1&gt; but was:&lt;0&gt;</description>
      <version>2.0.7</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.config.CFMetaData.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="6800" opendate="2014-3-5 00:00:00" fixdate="2014-3-5 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>ant codecoverage no longer works</summary>
      <description>Code coverage does not run currently due to cobertura jdk incompatibility. Fix is coming.</description>
      <version>2.0.7,2.1beta2</version>
      <fixedVersion>Legacy/Testing</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">build.xml</file>
    </fixedFiles>
  </bug>
  <bug id="6803" opendate="2014-3-5 00:00:00" fixdate="2014-3-5 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>nodetool getsstables converts key from String incorrectly</summary>
      <description>Trivial fix, just need to get the bytebuffer from the CfMetaData's key validator as opposed to just calling String#getBytes (which is broken for most data types).</description>
      <version>1.2.16,2.0.7</version>
      <fixedVersion>Tool/nodetool</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.db.ColumnFamilyStore.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="6811" opendate="2014-3-6 00:00:00" fixdate="2014-3-6 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>nodetool no longer shows node joining</summary>
      <description>When we added effective ownership output to nodetool ring/status, we accidentally began excluding joining nodes because we iterate the ownership maps instead of the the endpoint to token map when printing the output, and the joining nodes don't have any ownership. The simplest thing to do is probably iterate the token map instead, and not output any ownership info for joining nodes.</description>
      <version>1.2.16,2.0.7</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.tools.NodeTool.java</file>
      <file type="M">src.java.org.apache.cassandra.tools.NodeCmd.java</file>
    </fixedFiles>
  </bug>
  <bug id="6825" opendate="2014-3-7 00:00:00" fixdate="2014-4-7 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Slice Queries Can Skip Intersecting SSTables</summary>
      <description>Investigating another problem, I needed to do COUNT on the several partitions of a table immediately after a test case ran, and I discovered that count on the full table and on each of the partitions returned different counts. In particular case, SELECT COUNT FROM sr LIMIT 1000000; returned the expected count from the test 99999 rows. The composite primary key splits the logical row into six distinct partitions, and when I issue a query asking for the total across all six partitions, the returned result is only 83999. Drilling down, I find that SELECT * from sr WHERE s = 5 AND l = 11 AND partition = 0; returns 30,000 rows, but a SELECT COUNT with the identical WHERE predicate reports only 14,000. This is failing immediately after running a single small test, such that there are only two SSTables, sr-jb-1 and sr-jb-2. Compaction never needed to run. In selectrowcounts.txt is a copy of the cqlsh output showing the incorrect count results.</description>
      <version>2.0.7,2.1beta2</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.service.pager.SliceQueryPager.java</file>
      <file type="M">src.java.org.apache.cassandra.service.pager.AbstractQueryPager.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.SelectStatement.java</file>
      <file type="M">CHANGES.txt</file>
      <file type="M">test.unit.org.apache.cassandra.db.marshal.CompositeTypeTest.java</file>
      <file type="M">src.java.org.apache.cassandra.db.marshal.CompositeType.java</file>
    </fixedFiles>
  </bug>
  <bug id="6837" opendate="2014-3-11 00:00:00" fixdate="2014-3-11 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Batch CAS does not support LOCAL_SERIAL</summary>
      <description>The batch CAS feature introduced in Cassandra 2.0.6 does not support the LOCAL_SERIAL consistency level, and always uses SERIAL.Create a cluster with 4 nodes with the following topology:Datacenter: DC2===============Status=Up/Down|/ State=Normal/Leaving/Joining/Moving-- Address Load Tokens Owns Host ID RackUN 127.0.0.3 269 KB 256 26.3% ae92d997-6042-42d9-b447-943080569742 RAC1UN 127.0.0.4 197.81 KB 256 25.1% 3edc92d7-9d1b-472a-8452-24dddbc4502c RAC1Datacenter: DC1===============Status=Up/Down|/ State=Normal/Leaving/Joining/Moving-- Address Load Tokens Owns Host ID RackUN 127.0.0.1 226.92 KB 256 24.8% dbc17bd7-1ede-47a2-9b31-6063752d6eb3 RAC1UN 127.0.0.2 179.27 KB 256 23.7% bb0ad285-34d2-4989-a664-b068986ab6fa RAC1In cqlsh:cqlsh&gt; CREATE KEYSPACE foo WITH replication = {'class': 'NetworkTopologyStrategy', 'DC1': 2, 'DC2': 2};cqlsh&gt; USE foo;cqlsh:foo&gt; CREATE TABLE bar (x text, y bigint, z bigint, t bigint, PRIMARY KEY(x,y));Kill nodes 127.0.0.3 and 127.0.0.4:Datacenter: DC2===============Status=Up/Down|/ State=Normal/Leaving/Joining/Moving-- Address Load Tokens Owns Host ID RackDN 127.0.0.3 262.37 KB 256 26.3% ae92d997-6042-42d9-b447-943080569742 RAC1DN 127.0.0.4 208.04 KB 256 25.1% 3edc92d7-9d1b-472a-8452-24dddbc4502c RAC1Datacenter: DC1===============Status=Up/Down|/ State=Normal/Leaving/Joining/Moving-- Address Load Tokens Owns Host ID RackUN 127.0.0.1 214.82 KB 256 24.8% dbc17bd7-1ede-47a2-9b31-6063752d6eb3 RAC1UN 127.0.0.2 178.23 KB 256 23.7% bb0ad285-34d2-4989-a664-b068986ab6fa RAC1Connect to 127.0.0.1 in DC1 and run a CAS batch at CL.LOCAL_SERIAL+LOCAL_QUORUM: final Cluster cluster = new Cluster.Builder() .addContactPoint("127.0.0.1") .withLoadBalancingPolicy(new DCAwareRoundRobinPolicy("DC1")) .build(); final Session session = cluster.connect("foo"); Batch batch = QueryBuilder.batch(); batch.add(new SimpleStatement("INSERT INTO bar (x,y,z) VALUES ('abc', 123, 1) IF NOT EXISTS")); batch.add(new SimpleStatement("UPDATE bar SET t=2 WHERE x='abc' AND y=123")); batch.setConsistencyLevel(ConsistencyLevel.LOCAL_QUORUM); batch.setSerialConsistencyLevel(ConsistencyLevel.LOCAL_SERIAL); session.execute(batch);The batch fails with:Caused by: com.datastax.driver.core.exceptions.UnavailableException: Not enough replica available for query at consistency SERIAL (3 required but only 2 alive) at com.datastax.driver.core.Responses$Error$1.decode(Responses.java:44) at com.datastax.driver.core.Responses$Error$1.decode(Responses.java:33) at com.datastax.driver.core.Message$ProtocolDecoder.decode(Message.java:182) at org.jboss.netty.handler.codec.oneone.OneToOneDecoder.handleUpstream(OneToOneDecoder.java:66) ... 21 more</description>
      <version>2.0.7</version>
      <fixedVersion>Feature/LightweightTransactions</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.BatchStatement.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="6844" opendate="2014-3-12 00:00:00" fixdate="2014-3-12 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Expired cells not converted to deleted cells during cleanup/scrub/compaction (sometimes)</summary>
      <description>On read path, we intentionally read expiring cells as expiring cells, never converting them to tombstones, to return consistent results to the clients.For compaction/cleanup/scrub we don't care about that, and are supposed to make the conversion as an optimization. However, somewhere along the way it got lost, and SSTII doesn't always do it now in 2.0 (and never does it in 2.1).SSTI.getColumnFamilyWithColumns() passes the correct expireBefore(), but SSTI.next() does not, and while we use both in 2.0, depending on the some factors, in 2.1 we only use SSTI.next(), and SSTI.getColumnFamilyWithColumns() is actually dead code (I will remove it during the 2.1 merge).</description>
      <version>2.0.7,2.1beta2</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.io.sstable.SSTableIdentityIterator.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="6857" opendate="2014-3-14 00:00:00" fixdate="2014-3-14 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>SELECT DISTINCT with a LIMIT is broken by paging</summary>
      <description>The paging for RangeSliceCommand only support the case where we count CQL3 rows . However, in the case of SELECT DISTINCT, we do actually want to use the "count partitions, not CQL3 row" path and that's currently broken when the paging commands are used (this was first reported on the Java driver JIRA and there is a reproduction script there).</description>
      <version>2.0.7</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">test.unit.org.apache.cassandra.db.ColumnFamilyStoreTest.java</file>
      <file type="M">src.java.org.apache.cassandra.service.pager.QueryPagers.java</file>
      <file type="M">src.java.org.apache.cassandra.db.PagedRangeCommand.java</file>
      <file type="M">src.java.org.apache.cassandra.db.ColumnFamilyStore.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="6864" opendate="2014-3-14 00:00:00" fixdate="2014-3-14 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Proceed with truncate, if there are unreachable non storage nodes</summary>
      <description>If there are unreachable client nodes, operator cannot truncate tables.Fixed by checking, there are unreachable token owners.</description>
      <version>2.0.7,2.1beta2</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.service.StorageProxy.java</file>
      <file type="M">src.java.org.apache.cassandra.gms.Gossiper.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="6882" opendate="2014-3-18 00:00:00" fixdate="2014-3-18 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Add triggers support to LWT operations</summary>
      <description>Currently, any triggers configured for a table are not executed during LWT operations. If we were to enable triggers support for conditional operations, we'd need to restrict the kinds of mutations that those triggers are permitted to generate. More specifically, we'd need to ensure that only mutations that apply to the same partition as the primary condition are allowed. If a configured trigger emits mutations for another partition, or a different table, then the whole operation should be aborted in the same way as we abort non-LWT updates when a trigger produces invalid mutations.</description>
      <version>2.0.7,2.1beta2</version>
      <fixedVersion>None</fixedVersion>
      <type>New Feature</type>
    </buginformation>
    <fixedFiles>
      <file type="M">test.unit.org.apache.cassandra.triggers.TriggersTest.java</file>
      <file type="M">src.java.org.apache.cassandra.triggers.TriggerExecutor.java</file>
      <file type="M">src.java.org.apache.cassandra.service.StorageProxy.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="6893" opendate="2014-3-20 00:00:00" fixdate="2014-4-20 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Unintended update with conditional statement</summary>
      <description>After updated to 2.0.6, I have encountered the strange behavior of conditional updates.When I executed CQL like UPDATE test SET value = ? WHERE id = ? IF value = ? in concurrent, sometimes cassandra returns true even if value is not satisfied the condition.I have attached the program which reproduce this issue. The program works fine in cassandra 2.0.5. But it seems that resets values while execution in 2.0.6.</description>
      <version>2.0.7</version>
      <fixedVersion>Feature/LightweightTransactions</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.CQL3CasConditions.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.ColumnCondition.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="6896" opendate="2014-3-20 00:00:00" fixdate="2014-3-20 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>status output is confused when hostname resolution is enabled</summary>
      <description>root@bw-2:/srv/cassandra# bin/nodetool status Datacenter: datacenter1=======================Status=Up/Down|/ State=Normal/Leaving/Joining/Moving-- Address Load Owns (effective) Host ID Token RackUN 10.208.35.225 40.85 KB 68.2% 57b21a16-3c71-4d20-a953-5c8ee84afc28 -9158741197235941893 rack1UN 10.208.8.123 73.33 KB 65.2% 2ce51e7c-0028-46d2-9177-23a506e6943c -8950424030780117621 rack1UN 10.208.8.63 40.93 KB 66.6% 830cd3cc-a609-4dec-90f5-65c65cc41816 -9133899597809185600 rack1root@bw-2:/srv/cassandra# bin/nodetool status -rDatacenter: datacenter1=======================Status=Up/Down|/ State=Normal/Leaving/Joining/Moving-- Address Load Owns (effective) Host ID Token Rack?N bw-2 ? 68.2% null -9158741197235941893 rack1?N bw-3 ? 66.6% null -9133899597809185600 rack1?N bw-1 ? 65.2% null -8950424030780117621 rack1Somewhere we must mistakenly be using the resolved name to look up endpoints.</description>
      <version>1.2.16,2.0.7</version>
      <fixedVersion>Legacy/Tools</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.tools.NodeCmd.java</file>
    </fixedFiles>
  </bug>
  <bug id="6902" opendate="2014-3-21 00:00:00" fixdate="2014-3-21 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Make cqlsh prompt for a password if the user doesn&amp;#39;t enter one</summary>
      <description>If the user specifies -u username and leaves off -p password, cqlsh should prompt for a password without echoing it to the screen instead of throwing an exception, which it currently does. I know that you can put a username and password in the .cqlshrc file but if a user wants to log in with multiple accounts and not have the password visible on the screen, there's no way to currently do that.</description>
      <version>2.0.7,2.1beta2</version>
      <fixedVersion>Legacy/Tools</fixedVersion>
      <type>New Feature</type>
    </buginformation>
    <fixedFiles>
      <file type="M">bin.cqlsh</file>
    </fixedFiles>
  </bug>
  <bug id="6906" opendate="2014-3-21 00:00:00" fixdate="2014-4-21 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Skip Replica Calculation for Range Slice on LocalStrategy Keyspace</summary>
      <description>For vnode-enabled clusters, the "Determining replicas to query" portion of range slice commands can be expensive. When querying LocalStrategy keyspaces, we can safely skip this step. On a 15 node cluster with vnodes, skipping this saves about 100ms. This makes a big difference for the drivers, which frequently execute queries like "select * from system.peers" and "select * from system.local".</description>
      <version>2.0.7,2.1beta2</version>
      <fixedVersion>None</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.service.StorageProxy.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="6907" opendate="2014-3-22 00:00:00" fixdate="2014-3-22 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>ignore snapshot repair flag on Windows</summary>
      <description>Per discussion in CASSANDRA-4050, we should ignore the snapshot repair flag on windows, and log a warning while proceeding to do non-snapshot repair.</description>
      <version>2.0.7,2.1beta2</version>
      <fixedVersion>Legacy/Tools</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.service.StorageService.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="6914" opendate="2014-3-24 00:00:00" fixdate="2014-4-24 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Map element is not allowed in CAS condition with DELETE/UPDATE query</summary>
      <description>CREATE TABLE test (id int, data map&lt;text,text&gt;, PRIMARY KEY(id));INSERT INTO test (id, data) VALUES (1,{'a':'1'});DELETE FROM test WHERE id=1 IF data['a']=null;Bad Request: line 1:40 missing EOF at '='UPDATE test SET data['b']='2' WHERE id=1 IF data['a']='1';Bad Request: line 1:53 missing EOF at '='These queries was successfuly executed with cassandra 2.0.5, but don't work in 2.0.6 release</description>
      <version>2.0.7</version>
      <fixedVersion>Feature/LightweightTransactions</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.utils.ByteBufferUtil.java</file>
      <file type="M">src.java.org.apache.cassandra.serializers.SetSerializer.java</file>
      <file type="M">src.java.org.apache.cassandra.serializers.MapSerializer.java</file>
      <file type="M">src.java.org.apache.cassandra.serializers.ListSerializer.java</file>
      <file type="M">src.java.org.apache.cassandra.serializers.CollectionSerializer.java</file>
      <file type="M">src.java.org.apache.cassandra.db.marshal.SetType.java</file>
      <file type="M">src.java.org.apache.cassandra.db.marshal.MapType.java</file>
      <file type="M">src.java.org.apache.cassandra.db.marshal.ListType.java</file>
      <file type="M">src.java.org.apache.cassandra.db.marshal.DynamicCompositeType.java</file>
      <file type="M">src.java.org.apache.cassandra.db.marshal.CompositeType.java</file>
      <file type="M">src.java.org.apache.cassandra.db.marshal.CollectionType.java</file>
      <file type="M">src.java.org.apache.cassandra.db.marshal.AbstractCompositeType.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.SelectStatement.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.Selection.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.ModificationStatement.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.statements.CQL3CasConditions.java</file>
      <file type="M">src.java.org.apache.cassandra.cql3.Cql.g</file>
      <file type="M">src.java.org.apache.cassandra.cql3.ColumnCondition.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="6923" opendate="2014-3-25 00:00:00" fixdate="2014-3-25 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Fix UnsupportedOperationException on CAS timeout</summary>
      <description>This is due to CASSANDRA-6595: we call blockFor() for the paxos consistency, but we never added SERIAL/LOCAL_SERIAL in that method. Attaching trivial patch to add it.</description>
      <version>2.0.7</version>
      <fixedVersion>Feature/LightweightTransactions</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.db.ConsistencyLevel.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="6945" opendate="2014-3-28 00:00:00" fixdate="2014-3-28 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Calculate liveRatio on per-memtable basis, non per-CF</summary>
      <description>Currently we recalculate live ratio every doubling of write ops to the CF, not to an individual memtable. The value itself is also CF-bound, not memtable-bound. This is causing at least several issues:1. Depending on what stage the current memtable is, the live ratio calculated can vary a lot2. That calculated live ratio will potentially stay that way for quite a while - the longer C* process is on, the longer it would stay incorrect3. Incorrect live ratio means inefficient MeteredFlusher - flushing less or more often than needed, picking bad candidates for flushing, etc.4. Incorrect live ratio means incorrect size returned to the metrics consumers5. Compaction strategies that rely on memtable size estimation are affected6. All of the above is slightly amplified by the fact that all the memtables pending flush would also use that one incorrect valueDepending on the stage the current memtable at the moment of live ratio recalculation is, the value calculated can be extremely wrong (say, a recently created, fresh memtable - would have a much higher than average live ratio).The suggested fix is to bind live ratio to individual memtables, not column families as a whole, with some optimizations to make recalculations run less often by inheriting previous memtable's stats.</description>
      <version>2.0.7</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.db.Memtable.java</file>
      <file type="M">src.java.org.apache.cassandra.db.DataTracker.java</file>
      <file type="M">src.java.org.apache.cassandra.db.ColumnFamilyStore.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="6956" opendate="2014-3-31 00:00:00" fixdate="2014-4-31 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>SELECT ... LIMIT offset by 1 with static columns</summary>
      <description>First, repro case:cqlsh:test&gt; create table test ( pk1 text, pk2 timeuuid, data1 text static, data2 text, PRIMARY KEY( pk1, pk2 ) );cqlsh:test&gt; update test set data1 = 'data1', data2 = 'data2' where pk1 = 'pk1' and pk2 = now();cqlsh:test&gt; update test set data1 = 'data1', data2 = 'data2' where pk1 = 'pk1' and pk2 = now();cqlsh:test&gt; select * from test limit 1; pk1 | pk2 | data1 | data2-----+------+-------+------- pk1 | null | data1 | null(1 rows)cqlsh:test&gt; select * from test limit 2; pk1 | pk2 | data1 | data2-----+--------------------------------------+-------+------- pk1 | 9b068ee0-b8b0-11e3-a345-49baa9ac32e6 | data1 | data2(1 rows)cqlsh:test&gt; select * from test limit 3; pk1 | pk2 | data1 | data2-----+--------------------------------------+-------+------- pk1 | 9b068ee0-b8b0-11e3-a345-49baa9ac32e6 | data1 | data2 pk1 | 0af67a40-b8ba-11e3-a345-49baa9ac32e6 | data1 | data2(2 rows)I think that: 1) if this is a static columns feature it should be documented so I can use it safely or 2) it should be fixed (return 2 rows with limit 2 for query above).</description>
      <version>2.0.7</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.db.filter.ColumnCounter.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="6958" opendate="2014-3-31 00:00:00" fixdate="2014-4-31 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>upgradesstables does not maintain levels for existing SSTables</summary>
      <description>Initially ran into this issue on a DSE 3.2 (C* 1.2) to DSE 4.0 (C* 2.0) upgrade, and then I was able to reproduce it when testing an upgrade from C* 2.0.5 to C* 2.1-beta so the problem still exists in the latest code.Basically after you've upgraded to the new version and run "nodetool upgradesstables" on a CF/table that has been using LCS, then all of the non-L0 SSTables will be changed to L0 in the upgraded SSTables. In other words, they don't maintain their level and will have to go through the compaction again. The problem is that if you've got thousands of non-L0 SSTables before the upgrade, then all of these files showing up in L0 will push the system to do STCS and start to build some huge L0 tables. If a user doesn't budget enough free space (for example, if they used the recommended guideline and only budgeted 10% of free space because LCS is in use), then this STCS in L0 effect will have them run out of space.</description>
      <version>2.0.7</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.db.compaction.Upgrader.java</file>
      <file type="M">src.java.org.apache.cassandra.db.compaction.LeveledCompactionStrategy.java</file>
      <file type="M">src.java.org.apache.cassandra.db.compaction.CompactionManager.java</file>
      <file type="M">CHANGES.txt</file>
      <file type="M">src.java.org.apache.cassandra.db.compaction.SizeTieredCompactionStrategy.java</file>
      <file type="M">src.java.org.apache.cassandra.db.compaction.AbstractCompactionStrategy.java</file>
    </fixedFiles>
  </bug>
  <bug id="6961" opendate="2014-3-31 00:00:00" fixdate="2014-4-31 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>nodes should go into hibernate when join_ring is false</summary>
      <description>The impetus here is this: a node that was down for some period and comes back can serve stale information. We know from CASSANDRA-768 that we can't just wait for hints, and know that tangentially related CASSANDRA-3569 prevents us from having the node in a down (from the FD's POV) state handle streaming.We can almost set join_ring to false, then repair, and then join the ring to narrow the window (actually, you can do this and everything succeeds because the node doesn't know it's a member yet, which is probably a bit of a bug.) If instead we modified this to put the node in hibernate, like replace_address does, it could work almost like replace, except you could run a repair (manually) while in the hibernate state, and then flip to normal when it's done.This won't prevent the staleness 100%, but it will greatly reduce the chance if the node has been down a significant amount of time.</description>
      <version>2.0.7,2.1beta2</version>
      <fixedVersion>None</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.service.StorageService.java</file>
    </fixedFiles>
  </bug>
  <bug id="6971" opendate="2014-4-1 00:00:00" fixdate="2014-4-1 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Schedule schema pulls onChange</summary>
      <description>The dtest suite is running a test which creates a 3 node cluster, then adds a keyspace and column family. For some reason the 3 nodes are not agreeing on the schema version. The problem is intermittent &amp;#8211; either the nodes all agree on schema quickly, or they seem to stay stuck in limbo.The simplest way to reproduce is to run the dtest (simple_increment_test):https://github.com/riptano/cassandra-dtest/blob/master/counter_tests.pyusing nosetests:nosetests -vs counter_tests.py:TestCounters.simple_increment_testIf the problem is reproduced nose will return this:ProgrammingError: Bad Request: Keyspace 'ks' does not existI am not yet sure if the bug is reproducible outside of the dtest suite.</description>
      <version>1.2.17,2.0.7,2.1beta2</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.service.StorageService.java</file>
      <file type="M">src.java.org.apache.cassandra.service.MigrationManager.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
  <bug id="6972" opendate="2014-4-1 00:00:00" fixdate="2014-4-1 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Throw an ERROR when auto_bootstrap: true and bootstrapping node is listed in seeds</summary>
      <description>Obviously when this condition exists the node will not bootstrap. But it is not obvious from the logs why it is not bootstrapping. Throwing an error would make it obvious and therefore faster to correct.</description>
      <version>1.2.17,2.0.7,2.1beta2</version>
      <fixedVersion>None</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.service.StorageService.java</file>
    </fixedFiles>
  </bug>
  <bug id="6980" opendate="2014-4-3 00:00:00" fixdate="2014-4-3 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Non-droppable verbs shouldn&amp;#39;t be dropped from OTC</summary>
      <description>In CASSANDRA-5393, a retry was added if there was an exception sending a non-droppable verb. However, the message can still be dropped if it has been in the queue longer than rpc timeout. When this happens for e.g. Merkle trees, the repair hangs. The message should not be dropped.</description>
      <version>1.2.17,2.0.7</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.java.org.apache.cassandra.net.OutboundTcpConnection.java</file>
      <file type="M">CHANGES.txt</file>
    </fixedFiles>
  </bug>
</bugrepository>
