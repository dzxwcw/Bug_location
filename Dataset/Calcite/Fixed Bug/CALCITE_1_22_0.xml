<?xml version="1.0" encoding="UTF-8"?>

<bugrepository name="CALCITE">
  <bug id="3799" opendate="2020-2-14 00:00:00" fixdate="2020-2-14 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Following CALCITE-3769, fix the slow tests</summary>
      <description></description>
      <version>1.22.0</version>
      <fixedVersion>1.22.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.test.LatticeTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.plan.RelOptMaterialization.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.enumerable.EnumerableTableScanRule.java</file>
    </fixedFiles>
  </bug>
  <bug id="3808" opendate="2020-2-20 00:00:00" fixdate="2020-3-20 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Release Calcite 1.22.0</summary>
      <description></description>
      <version>1.22.0</version>
      <fixedVersion>1.22.0</fixedVersion>
      <type>Task</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site..docs.howto.md</file>
      <file type="M">site..docs.history.md</file>
      <file type="M">README</file>
      <file type="M">NOTICE</file>
    </fixedFiles>
  </bug>
  <bug id="3813" opendate="2020-2-21 00:00:00" fixdate="2020-2-21 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Support hint option key as string literal</summary>
      <description>Add syntax:SELECT /*+ hint_name('k1'='v1', 'k2'='v2') ... */ FROM ...The "k1" and "k2" are both string literal.</description>
      <version>1.22.0</version>
      <fixedVersion>1.22.0</fixedVersion>
      <type>Sub-task</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.sql.parser.SqlParserTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlHint.java</file>
      <file type="M">core.src.main.codegen.templates.Parser.jj</file>
    </fixedFiles>
  </bug>
  <bug id="3814" opendate="2020-2-21 00:00:00" fixdate="2020-4-21 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Support JDK 14 and guava-28.2-jre</summary>
      <description>JDK 14 will be released on 2020/03/17.I tried building Calcite on an early access build and got an error from Gradle:$ java -versionopenjdk version "14" 2020-03-17OpenJDK Runtime Environment (build 14+36-1461)OpenJDK 64-Bit Server VM (build 14+36-1461, mixed mode, sharing)$ ./gradlew buildStarting a Gradle Daemon, 1 busy and 1 incompatible Daemons could not be reused, use --status for detailsjava.lang.NoClassDefFoundError: Could not initialize class org.codehaus.groovy.vmplugin.v7.Java7 at org.codehaus.groovy.vmplugin.VMPluginFactory.&lt;clinit&gt;(VMPluginFactory.java:43) at org.codehaus.groovy.reflection.GroovyClassValueFactory.&lt;clinit&gt;(GroovyClassValueFactory.java:35) at org.codehaus.groovy.reflection.ClassInfo.&lt;clinit&gt;(ClassInfo.java:107)...$ ./gradlew clean --stacktraceFAILURE: Build failed with an exception.* What went wrong:Could not initialize class org.codehaus.groovy.runtime.InvokerHelper* Try:Run with --info or --debug option to get more log output. Run with --scan to get full insights.* Exception is:java.lang.NoClassDefFoundError: Could not initialize class org.codehaus.groovy.runtime.InvokerHelper at org.gradle.internal.extensibility.DefaultExtraPropertiesExtension.&lt;init&gt;(DefaultExtraPropertiesExtension.java:29) at org.gradle.internal.extensibility.DefaultConvention.&lt;init&gt;(DefaultConvention.java:49) at org.gradle.internal.extensibility.ExtensibleDynamicObject.&lt;init&gt;(ExtensibleDynamicObject.java:60)...Problem appears to be https://github.com/gradle/gradle/issues/10248, which is related to (caused by) GROOVY-9211, and alrso related to NETBEANS-3876.</description>
      <version>None</version>
      <fixedVersion>1.23.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site..docs.history.md</file>
      <file type="M">core.src.main.java.org.apache.calcite.schema.Schemas.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.interpreter.Bindables.java</file>
    </fixedFiles>
  </bug>
  <bug id="3818" opendate="2020-2-25 00:00:00" fixdate="2020-2-25 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Upgrade Avatica version to 1.16.0</summary>
      <description></description>
      <version>1.22.0</version>
      <fixedVersion>1.22.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">gradle.properties</file>
    </fixedFiles>
  </bug>
  <bug id="3826" opendate="2020-2-26 00:00:00" fixdate="2020-2-26 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>UPDATE assigns wrong type to bind variables</summary>
      <description>In 1.22.0rc1 I have found a problem about EnumerableTableModify#getSourceExpressionListIt looks like it is not mapping correctly the expected datatypes ofbind variables in queries like UPDATE table set a=?,b=? where pk=?.You can see the full SQL here in this commit in my test branch herehttps://github.com/diennea/herddb/pull/563/commits/157f927c9efe85cf7cac1370e1637b1c7ec46dff#diff-5d7594bc81ae0c92bbd33dee6c0d189aR2301My case is the following:Create a table:CREATE TABLE t1 ( field0 int PRIMARY KEY, field1 VARCHAR(10), field2 VARCHAR(10), field3 INT, field4 INT, field5 VARCHAR(10))UPDATE t1 SET field3 =?, field2=?, field4=?, field5=? where field0=?The Update maps to this Calcite plan:EnumerableTableModify(table=[&amp;#91;tblspace1, ip&amp;#93;], operation=&amp;#91;UPDATE&amp;#93;,updateColumnList=[&amp;#91;field3, field2, field4, field5&amp;#93;],sourceExpressionList=[&amp;#91;?0, ?1, ?2, ?3&amp;#93;], flattened=&amp;#91;true&amp;#93;): rowcount =1.0, cumulative cost = {2.5 rows, 10.5 cpu, 0.0 io}, id = 62 EnumerableProject(field0=&amp;#91;$0&amp;#93;, field1=&amp;#91;$1&amp;#93;, field2=&amp;#91;$2&amp;#93;,field3=&amp;#91;$3&amp;#93;, field4=&amp;#91;$4&amp;#93;, field5=&amp;#91;$5&amp;#93;, EXPR$0=&amp;#91;?0&amp;#93;, EXPR$1=&amp;#91;?1&amp;#93;,EXPR$2=&amp;#91;?2&amp;#93;, EXPR$3=&amp;#91;?3&amp;#93;): rowcount = 1.0, cumulative cost = {1.5rows, 10.5 cpu, 0.0 io}, id = 61 EnumerableInterpreter: rowcount = 1.0, cumulative cost = {0.5rows, 0.5 cpu, 0.0 io}, id = 60 BindableTableScan(table=[&amp;#91;tblspace1, ip&amp;#93;], filters=[[=($0,?4)]]): rowcount = 1.0, cumulative cost = {0.005 rows, 0.01 cpu, 0.0io}, id = 45In particular the obeserved problem is: the updateColumnList field is: field3, field2, field4, field5 but the bind variables have wrong type: VARCHAR, VARCHAR, INT, INT,expecting INT VARCHAR, INT VARCHAReven by changing the UPDATE command the types of bind variables stays the same,and they are the in the same order as in the CREATE TABLE STATEMENT,skipping the PK.It may be a regression of CALCITE-3672</description>
      <version>1.22.0</version>
      <fixedVersion>1.22.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlToRelConverterTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlValidatorImpl.java</file>
    </fixedFiles>
  </bug>
  <bug id="3827" opendate="2020-2-26 00:00:00" fixdate="2020-4-26 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Reduce the time complexity of finding in-edges of a vertex in the graph</summary>
      <description>In the current graph implementation, it takes O(1) time to find the out-edges of a vertex, but O(e) time (where e is the total number of edges in the graph) to find the in-edges of a vertex. In some scenarios (e.g. clearing cache in hep planner), this may have severe performance penalty. To solve this problem, we add a inward edge table, in addition to the existing outward edge table, to the graph. This helps to reduce the time complexity for finding in-edges to O(1). Please note that, there is extra performance overhead for maintaining the in edge table, when adding/deleting vertices to the graph. However, the added overhead only takes O(1) time.Finally, it should be noted that, some existing operations can benefit from this improvement (e.g. topological sort).</description>
      <version>None</version>
      <fixedVersion>1.23.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.main.java.org.apache.calcite.util.graph.DirectedGraph.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.util.graph.DefaultDirectedGraph.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.util.graph.AttributedDirectedGraph.java</file>
    </fixedFiles>
  </bug>
  <bug id="3847" opendate="2020-3-9 00:00:00" fixdate="2020-3-9 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Decorrelation for join with lateral table outputs wrong plan if the join condition contains correlation variables</summary>
      <description>After CALCITE-2004, we can decorrelate plan for query:select deptno, r.num from dept joinlateral table(ramp(dept.deptno)) as r(num)on deptno=numto plan like:LogicalProject(DEPTNO=[$0], NUM=[$2]) LogicalJoin(condition=[=($0, $2)], joinType=[inner]) LogicalTableScan(table=[[CATALOG, SALES, DEPT]]) LogicalTableFunctionScan(invocation=[RAMP($cor0.DEPTNO)], rowType=[RecordType(INTEGER I)])See there was a correlate variable left.To fix this, i would suggest to stop decorrelating when we encounter the correlate variables in LogicalTableFunctionScan.</description>
      <version>1.22.0</version>
      <fixedVersion>1.23.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.org.apache.calcite.test.SqlToRelConverterTest.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlToRelConverterTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql2rel.RelDecorrelator.java</file>
    </fixedFiles>
  </bug>
  <bug id="3856" opendate="2020-3-12 00:00:00" fixdate="2020-3-12 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Remove code to be removed before 1.23</summary>
      <description></description>
      <version>1.22.0</version>
      <fixedVersion>1.23.0</fixedVersion>
      <type>Task</type>
    </buginformation>
    <fixedFiles>
      <file type="M">pig.src.main.java.org.apache.calcite.adapter.pig.PigRelFactories.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlValidatorTestCase.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlToRelConverterTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelOptTestBase.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.parser.SqlParserTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql2rel.SqlToRelConverter.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.stream.StreamRules.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.rel2sql.RelToSqlConverter.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.logical.LogicalTableScan.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.logical.LogicalProject.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.logical.LogicalJoin.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.core.RelFactories.java</file>
    </fixedFiles>
  </bug>
  <bug id="3872" opendate="2020-3-25 00:00:00" fixdate="2020-4-25 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Simplify expressions with unary minus</summary>
      <description>Support simplifying expression - ( - ( x ) ) as x.</description>
      <version>None</version>
      <fixedVersion>1.23.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.rex.RexProgramTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rex.RexProgramBuilderBase.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rex.RexSimplify.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rex.RexAnalyzer.java</file>
    </fixedFiles>
  </bug>
  <bug id="3878" opendate="2020-3-26 00:00:00" fixdate="2020-4-26 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Make ArrayList creation with initial capacity when size is fixed</summary>
      <description>I find many places in Calcite where new ArrayList&lt;&gt;() is used, if the list is expected to be immutable or not resizing, it is always a good manner to create with initial capacity, better for memory usage and performance.I search all occurrences, focus on the core module, to make it safe, I only update local variables with fixed size and not working in recursive method. If the local variable reference goes out of scope, if resizing is needed, things will work normally as well, so no side effect, but for the "escaping" case, I am very conservative and do not change them.   </description>
      <version>1.22.0</version>
      <fixedVersion>1.23.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.main.java.org.apache.calcite.rel.RelRoot.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.rel2sql.RelToSqlConverter.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.mutable.MutableRels.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.core.TableScan.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.prepare.Prepare.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.prepare.CalcitePrepareImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.jdbc.CalciteMetaImpl.java</file>
    </fixedFiles>
  </bug>
  <bug id="3892" opendate="2020-4-2 00:00:00" fixdate="2020-4-2 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Make junit test classes and methods non-public</summary>
      <description>In junit 4 and earlier versions, junit classes and methods must be public. In junit 5 (jupiter) this is no longer the case.This change makes classes and methods package-protected where possible (i.e. removes the "public" modifier). It makes tests a bit more concise, and gives us more freedom to refactor tests in future.</description>
      <version>None</version>
      <fixedVersion>1.23.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlOperatorTest.java</file>
      <file type="M">splunk.src.test.java.org.apache.calcite.test.SplunkAdapterTest.java</file>
      <file type="M">spark.src.test.java.org.apache.calcite.test.SparkAdapterTest.java</file>
      <file type="M">server.src.test.java.org.apache.calcite.test.ServerUnParserTest.java</file>
      <file type="M">server.src.test.java.org.apache.calcite.test.ServerTest.java</file>
      <file type="M">server.src.test.java.org.apache.calcite.test.ServerQuidemTest.java</file>
      <file type="M">server.src.test.java.org.apache.calcite.test.ServerParserTest.java</file>
      <file type="M">redis.src.test.java.org.apache.calcite.adapter.redis.RedisMiniServer.java</file>
      <file type="M">redis.src.test.java.org.apache.calcite.adapter.redis.RedisAdapterCaseBase.java</file>
      <file type="M">plus.src.test.java.org.apache.calcite.materialize.TpcdsLatticeSuggesterTest.java</file>
      <file type="M">plus.src.test.java.org.apache.calcite.chinook.RemotePreparedStatementParametersTest.java</file>
      <file type="M">plus.src.test.java.org.apache.calcite.chinook.EndToEndTest.java</file>
      <file type="M">plus.src.test.java.org.apache.calcite.adapter.tpch.TpchTest.java</file>
      <file type="M">plus.src.test.java.org.apache.calcite.adapter.tpcds.TpcdsTest.java</file>
      <file type="M">plus.src.test.java.org.apache.calcite.adapter.os.OsAdapterTest.java</file>
      <file type="M">pig.src.test.java.org.apache.calcite.test.PigRelBuilderStyleTest.java</file>
      <file type="M">pig.src.test.java.org.apache.calcite.test.PigAdapterTest.java</file>
      <file type="M">piglet.src.test.java.org.apache.calcite.test.PigScriptTest.java</file>
      <file type="M">piglet.src.test.java.org.apache.calcite.test.PigRelOpTest.java</file>
      <file type="M">piglet.src.test.java.org.apache.calcite.test.PigRelExTest.java</file>
      <file type="M">piglet.src.test.java.org.apache.calcite.test.PigletTest.java</file>
      <file type="M">mongodb.src.test.java.org.apache.calcite.adapter.mongodb.MongoAdapterTest.java</file>
      <file type="M">linq4j.src.test.java.org.apache.calcite.linq4j.tree.TypeTest.java</file>
      <file type="M">linq4j.src.test.java.org.apache.calcite.linq4j.test.PrimitiveTest.java</file>
      <file type="M">linq4j.src.test.java.org.apache.calcite.linq4j.test.OptimizerTest.java</file>
      <file type="M">linq4j.src.test.java.org.apache.calcite.linq4j.test.LookupImplTest.java</file>
      <file type="M">linq4j.src.test.java.org.apache.calcite.linq4j.test.Linq4jTest.java</file>
      <file type="M">linq4j.src.test.java.org.apache.calcite.linq4j.test.InlinerTest.java</file>
      <file type="M">linq4j.src.test.java.org.apache.calcite.linq4j.test.ExpressionTest.java</file>
      <file type="M">linq4j.src.test.java.org.apache.calcite.linq4j.test.DeterministicTest.java</file>
      <file type="M">linq4j.src.test.java.org.apache.calcite.linq4j.test.CorrelateJoinTest.java</file>
      <file type="M">linq4j.src.test.java.org.apache.calcite.linq4j.test.BlockBuilderTest.java</file>
      <file type="M">linq4j.src.test.java.org.apache.calcite.linq4j.MemoryEnumerableTest.java</file>
      <file type="M">linq4j.src.test.java.org.apache.calcite.linq4j.function.FunctionTest.java</file>
      <file type="M">kafka.src.test.java.org.apache.calcite.adapter.kafka.KafkaRowConverterTest.java</file>
      <file type="M">kafka.src.test.java.org.apache.calcite.adapter.kafka.KafkaAdapterTest.java</file>
      <file type="M">geode.src.test.java.org.apache.calcite.adapter.geode.simple.BookMasterRegionTest.java</file>
      <file type="M">geode.src.test.java.org.apache.calcite.adapter.geode.rel.GeodeZipsTest.java</file>
      <file type="M">geode.src.test.java.org.apache.calcite.adapter.geode.rel.GeodeBookstoreTest.java</file>
      <file type="M">geode.src.test.java.org.apache.calcite.adapter.geode.rel.GeodeAllDataTypesTest.java</file>
      <file type="M">file.src.test.java.org.apache.calcite.adapter.file.SqlTest.java</file>
      <file type="M">file.src.test.java.org.apache.calcite.adapter.file.FileReaderTest.java</file>
      <file type="M">example.function.src.test.java.org.apache.calcite.test.ExampleFunctionTest.java</file>
      <file type="M">example.csv.src.test.java.org.apache.calcite.test.CsvTest.java</file>
      <file type="M">elasticsearch.src.test.java.org.apache.calcite.adapter.elasticsearch.ScrollingTest.java</file>
      <file type="M">elasticsearch.src.test.java.org.apache.calcite.adapter.elasticsearch.QueryBuildersTest.java</file>
      <file type="M">elasticsearch.src.test.java.org.apache.calcite.adapter.elasticsearch.ProjectionTest.java</file>
      <file type="M">elasticsearch.src.test.java.org.apache.calcite.adapter.elasticsearch.Projection2Test.java</file>
      <file type="M">elasticsearch.src.test.java.org.apache.calcite.adapter.elasticsearch.MatchTest.java</file>
      <file type="M">elasticsearch.src.test.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchVersionTest.java</file>
      <file type="M">elasticsearch.src.test.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchJsonTest.java</file>
      <file type="M">elasticsearch.src.test.java.org.apache.calcite.adapter.elasticsearch.ElasticSearchAdapterTest.java</file>
      <file type="M">elasticsearch.src.test.java.org.apache.calcite.adapter.elasticsearch.BooleanLogicTest.java</file>
      <file type="M">elasticsearch.src.test.java.org.apache.calcite.adapter.elasticsearch.AggregationTest.java</file>
      <file type="M">druid.src.test.java.org.apache.calcite.test.DruidDateRangeRulesTest.java</file>
      <file type="M">druid.src.test.java.org.apache.calcite.test.DruidAdapterIT.java</file>
      <file type="M">druid.src.test.java.org.apache.calcite.test.DruidAdapter2IT.java</file>
      <file type="M">druid.src.test.java.org.apache.calcite.adapter.druid.DruidQueryFilterTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.UtilTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.TestUtilTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.SourceTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.ReflectVisitorTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.PrecedenceClimbingParserTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.PermutationTestCase.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.PartiallyOrderedSetTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.mapping.MappingTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.ImmutableBitSetTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.ImmutableBeanTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.graph.DirectedGraphTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.ChunkListTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.BitSetsTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.tools.PlannerTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.tools.FrameworksTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.UdtTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.UdfTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.TypeCoercionTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.TypeCoercionConverterTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.TableInRootSchemaTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.TableFunctionTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.StreamTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlXmlFunctionsTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlValidatorTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlValidatorFeatureTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlToRelConverterTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlToRelConverterExtendedTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlTestGen.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlStatisticProviderTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlOperatorBindingTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlLineTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlLimitsTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlJsonFunctionsTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlHintsConverterTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlFunctionsTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlAdvisorJdbcTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.ScannableTableTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RexTransformerTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RexShuttleTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RexImplicationCheckerTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelOptRulesTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelMetadataTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelMdPercentageOriginalRowsTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelMdColumnOriginsTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelBuilderTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.ReflectiveSchemaTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.PigRelBuilderTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.MutableRelTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.MultiJdbcSchemaJoinTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.ModelTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.MaterializationTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.LogicalProjectDigestTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.LinqFrontJdbcBackTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.LatticeTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.JdbcTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.JdbcFrontLinqBackTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.JdbcFrontJdbcBackTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.JdbcFrontJdbcBackLinqMiddleTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.JdbcAdapterTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.InterpreterTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.InduceGroupingTypeTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.HepPlannerTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.fuzzer.RexToTestCodeShuttle.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.fuzzer.RexProgramFuzzyTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.FoodmartTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.FilteratorTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.ExceptionMessageTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.enumerable.EnumerableRepeatUnionTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.enumerable.EnumerableRepeatUnionHierarchyTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.enumerable.EnumerableJoinTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.enumerable.EnumerableHashJoinTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.enumerable.EnumerableCorrelateTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.enumerable.EnumerableCalcTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.enumerable.EnumerableBatchNestedLoopJoinTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.CoreQuidemTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.concurrent.ConcurrentTestCommandGenerator.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.CollectionTypeTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.CalciteSqlOperatorTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.CalciteResourceTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.validate.SqlValidatorUtilTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.validate.LexEscapeTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.validate.LexCaseSensitiveTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.type.SqlTypeUtilTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.type.SqlTypeFactoryTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.type.RelDataTypeSystemTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlTypeNameTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlRuntimeTester.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlPrettyWriterTest.java</file>
      <file type="M">babel.src.test.java.org.apache.calcite.test.BabelParserTest.java</file>
      <file type="M">babel.src.test.java.org.apache.calcite.test.BabelQuidemTest.java</file>
      <file type="M">babel.src.test.java.org.apache.calcite.test.BabelTest.java</file>
      <file type="M">cassandra.src.test.java.org.apache.calcite.test.CassandraAdapterDataTypesTest.java</file>
      <file type="M">cassandra.src.test.java.org.apache.calcite.test.CassandraAdapterTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.adapter.clone.ArrayTableTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.adapter.enumerable.EnumUtilsTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.adapter.enumerable.PhysTypeTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.adapter.enumerable.TypeFinderTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.jdbc.CalciteRemoteDriverTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.jdbc.JavaTypeFactoryTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.materialize.LatticeSuggesterTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.plan.RelOptPlanReaderTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.plan.RelOptUtilTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.plan.RelTraitTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.plan.RelWriterTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.plan.volcano.CollationConversionTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.plan.volcano.ComboRuleTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.plan.volcano.TraitConversionTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.plan.volcano.TraitPropagationTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.plan.volcano.VolcanoPlannerTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.plan.volcano.VolcanoPlannerTraitTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.prepare.LookupOperatorOverloadsTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.profile.ProfilerTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rel.logical.ToLogicalConverterTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rel.rel2sql.RelToSqlConverterStructsTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rel.rel2sql.RelToSqlConverterTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rel.RelCollationTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rel.RelDistributionTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rel.rules.DateRangeRulesTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rel.rules.EnumerableLimitRuleTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rel.rules.SortRemoveRuleTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rex.RexBuilderTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rex.RexCallNormalizationTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rex.RexExecutorTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rex.RexLosslessCastTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rex.RexProgramTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rex.RexProgramTestBase.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rex.RexSqlStandardConvertletTableTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.runtime.AutomatonTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.runtime.BinarySearchTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.runtime.DeterministicAutomatonTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.runtime.EnumerablesTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.parser.parserextensiontesting.ExtensionSqlParserTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.parser.SqlParserTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.parser.SqlUnParserTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.SqlSetOptionOperatorTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.DocumentationTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlAdvisorTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlOperatorBaseTest.java</file>
    </fixedFiles>
  </bug>
  <bug id="3894" opendate="2020-4-3 00:00:00" fixdate="2020-4-3 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>SET operation between DATE and TIMESTAMP returns a wrong result</summary>
      <description>@Test public void testUnionTime() { CalciteAssert.AssertThat assertThat = CalciteAssert.that(); String query = "select * from (\n" + "select \"id\" from (VALUES(DATE '2018-02-03')) \"foo\"(\"id\")\n" + "union\n" + "select \"id\" from (VALUES(TIMESTAMP '2008-03-31 12:23:34')) \"foo\"(\"id\"))"; assertThat.query(query).returns("id=2108-03-12\nid=2018-02-03\n");}The test with wrong result passed. </description>
      <version>None</version>
      <fixedVersion>1.23.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.org.apache.calcite.test.TypeCoercionConverterTest.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.TypeCoercionTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.TypeCoercionConverterTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.JdbcTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.type.SqlTypeAssignmentRule.java</file>
    </fixedFiles>
  </bug>
  <bug id="3927" opendate="2020-4-15 00:00:00" fixdate="2020-4-15 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>RelSubset is not fired for rule when set gets merged</summary>
      <description>In VolcanoPlanner, when set gets merged, planner fires rules again for RelNodes in both sets, but not for RelSubset. We might miss something because of this. If all the logical transformation rules and physical implementation rules are separated out in different stage and physical rules don't do logical work, we might be OK. But the reality is that all the things are mixed together at the moment.</description>
      <version>None</version>
      <fixedVersion>1.23.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.plan.volcano.VolcanoPlannerTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.plan.volcano.PlannerTests.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.plan.volcano.RelSet.java</file>
    </fixedFiles>
  </bug>
  <bug id="3928" opendate="2020-4-16 00:00:00" fixdate="2020-5-16 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Canonicalization doesn&amp;#39;t do field trimming before materialized view matching</summary>
      <description>If we have query and materialized view as below:query:LogicalAggregate(group=[{4}], agg#0=[COUNT($3)]) LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], SAL=[$5], DEPTNO=[$7]) LogicalTableScan(table=[[scott, EMP]])mv logic:LogicalAggregate(group=[{1}], agg#0=[COUNT($0)]) LogicalProject(SAL=[$5], DEPTNO=[$7]) LogicalTableScan(table=[[scott, EMP]])The semantics of query and mv logic are the same. Materialized view matching failed, because field trimming is not done when canonicalizing the plans.Currently Calcite does field trimming  when convert sql to rel. But my company's internal system does materialization detection – – generates &amp; transforms &amp; stores the RelNode.Shall we add the field trimming when canonicalizing materialized view logic? </description>
      <version>None</version>
      <fixedVersion>1.23.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.main.java.org.apache.calcite.plan.RelOptMaterializations.java</file>
    </fixedFiles>
  </bug>
  <bug id="3934" opendate="2020-4-17 00:00:00" fixdate="2020-4-17 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Allow type-coercion in CONCAT operator</summary>
      <description>Supports implicit type coercion for operators with repeated type families, such as:CONCAT(123, 'abc', DATE '2020-04-17')</description>
      <version>1.22.0</version>
      <fixedVersion>1.23.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlValidatorTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.implicit.TypeCoercionImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.implicit.AbstractTypeCoercion.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.type.CompositeOperandTypeChecker.java</file>
    </fixedFiles>
  </bug>
  <bug id="3940" opendate="2020-4-20 00:00:00" fixdate="2020-4-20 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Hint item can not parse correctly if the name is right after token "/*+"</summary>
      <description>After parsing/*+OPTIONS('k1'='v1', 'k2'='v2')*/The parsed hint name is "PTIONS", while it is expected to be "OPTIONS".</description>
      <version>1.22.0</version>
      <fixedVersion>1.23.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlAdvisorTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.parser.SqlParserTest.java</file>
      <file type="M">core.src.main.codegen.templates.Parser.jj</file>
    </fixedFiles>
  </bug>
  <bug id="3954" opendate="2020-4-24 00:00:00" fixdate="2020-4-24 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Always compare types using equals</summary>
      <description>As discussed in CALCITE-3932, the intern of data type can not be guaranteed, so we must alway compare the data types using equals.</description>
      <version>1.22.0</version>
      <fixedVersion>1.23.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.main.java.org.apache.calcite.sql.type.SqlTypeUtil.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rex.RexUtil.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rex.RexLocalRef.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.type.RelDataTypeImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.plan.RelOptUtil.java</file>
    </fixedFiles>
  </bug>
  <bug id="3955" opendate="2020-4-24 00:00:00" fixdate="2020-1-24 01:00:00" resolution="Unresolved">
    <buginformation>
      <summary>Remove the first operand of RexCall from SqlWindowTableFunction</summary>
      <description>In CALCITE-3382, we introduced TUMBLE window function to replace the deprecated group tumble window.But for queryselect *from table(tumble(table Shipments, descriptor(rowtime), INTERVAL '1' MINUTE))the outputs plan isLogicalProject(ORDERID=[$0], ROWTIME=[$1], window_start=[$2], window_end=[$3]) LogicalTableFunctionScan(invocation=[TUMBLE($1, DESCRIPTOR($1), 60000:INTERVAL MINUTE)], rowType=[RecordType(INTEGER ORDERID, TIMESTAMP(0) ROWTIME, TIMESTAMP(0) window_start, TIMESTAMP(0) window_end)]) LogicalProject(ORDERID=[$0], ROWTIME=[$1]) LogicalTableScan(table=[[CATALOG, SALES, SHIPMENTS]])The first operand of TUMBLE rex call is always the last input field, but actually it represents the source table which is the input rel node.This issue remove the first operand from the RexCall because it is useless and confusing.</description>
      <version>1.22.0</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.org.apache.calcite.test.SqlToRelConverterTest.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlToRelConverterTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql2rel.StandardConvertletTable.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.enumerable.RexImpTable.java</file>
    </fixedFiles>
  </bug>
  <bug id="3962" opendate="2020-4-28 00:00:00" fixdate="2020-4-28 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Make JSON_VALUE operands varadic</summary>
      <description></description>
      <version>1.21.0,1.22.0</version>
      <fixedVersion>1.23.0</fixedVersion>
      <type>Sub-task</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.org.apache.calcite.test.SqlToRelConverterTest.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlValidatorTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlJsonFunctionsTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlOperatorBaseTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.parser.SqlParserTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rel.rel2sql.RelToSqlConverterTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.util.BuiltInMethod.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlJsonValueEmptyOrErrorBehavior.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlJsonExistsErrorBehavior.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlJsonEmptyOrError.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlInfixOperator.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.fun.SqlStdOperatorTable.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.fun.SqlRowOperator.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.fun.SqlJsonValueFunction.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.fun.SqlJsonExistsFunction.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.fun.SqlDatetimeSubtractionOperator.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.fun.SqlDatetimePlusOperator.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql2rel.StandardConvertletTable.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.runtime.JsonFunctions.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.enumerable.RexImpTable.java</file>
      <file type="M">core.src.main.codegen.templates.Parser.jj</file>
    </fixedFiles>
  </bug>
  <bug id="3981" opendate="2020-5-8 00:00:00" fixdate="2020-6-8 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Volcano.register should not return stale/merged subset</summary>
      <description>When a subset is registered, registerImpl() and registerSubset() currently simply returns the subset itself. The problem is that subset can become stale when relSets get merged (for example in ensureRegistered() and registerSubset() "merge(set, subset.set)"). As a result, a stale/merged subset might be returned from registerImpl, and the newly registering subtree might get registered recursively on top of the stale subset (see AbstractRelNode.onRegister()). This is a leak because once a relSet/subset is merged into others and becomes stale, it should not be used to connect new relNodes. With CALCITE-3755, subsets can now be directly matched by rules. This opens another source of stale subset leak: (1) An active subset gets matched, the RuleMatch gets queued in RuleQueue. (2) The subset becomes stale due to relSet merge. (3) The rule match in (1) is popped from queue and fired. (4) In OnMatch the rule gets the stale subset, builds new rels on top of it and regsiter the new rels. In this case, the entire new rel subtree will be registered on top of the stale subset as is.Rather than returning the registering subset itself, register should always use canonize() to find and return the equivalent active subset instead.</description>
      <version>None</version>
      <fixedVersion>1.24.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.main.java.org.apache.calcite.plan.volcano.VolcanoPlanner.java</file>
    </fixedFiles>
  </bug>
  <bug id="3989" opendate="2020-5-11 00:00:00" fixdate="2020-5-11 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Release Calcite 1.23.0</summary>
      <description></description>
      <version>None</version>
      <fixedVersion>1.23.0</fixedVersion>
      <type>Task</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site..docs.howto.md</file>
      <file type="M">site..docs.history.md</file>
      <file type="M">README</file>
    </fixedFiles>
  </bug>
</bugrepository>
