<?xml version="1.0" encoding="UTF-8"?>

<bugrepository name="CALCITE">
  <bug id="1864" opendate="2017-6-29 00:00:00" fixdate="2017-7-29 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Allow NULL literal as argument</summary>
      <description>Even though the SQL standard does not allow raw (non-casted) NULL literals, most databases do. So we should allow 1 = null or select * from emp where empno &gt; null. Of course, these expressions always return UNKNOWN.</description>
      <version>None</version>
      <fixedVersion>1.14.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.sql.misc.iq</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlValidatorTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlOperatorBaseTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlValidatorImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.type.SqlTypeUtil.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.type.SqlTypeFactoryImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.type.SameOperandTypeChecker.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlOperator.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.type.RelDataTypeFactory.java</file>
    </fixedFiles>
  </bug>
  <bug id="1866" opendate="2017-6-30 00:00:00" fixdate="2017-7-30 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>JDBC adapter generates incorrect SQL to implement FLOOR(dateTime to HOUR) on MySQL</summary>
      <description>I execute the sql "select FLOOR(trade_time TO HOUR) ..."then I get the ResultSet, if time hour is less than 10, I get the following exception:java.lang.RuntimeException: java.sql.SQLException: Bad format for Timestamp '2017-06-30 7:00:00' in column 1. at Baz$1$1.apply(Unknown Source) at org.apache.calcite.runtime.ResultSetEnumerable$ResultSetEnumerator.current(ResultSetEnumerable.java:187) at org.apache.calcite.linq4j.Linq4j$EnumeratorIterator.next(Linq4j.java:672) at org.apache.calcite.avatica.util.IteratorCursor.next(IteratorCursor.java:46) at org.apache.calcite.avatica.AvaticaResultSet.next(AvaticaResultSet.java:239) at TestCalcite.test028_jdbc(TestCalcite.java:75) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:606) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.junit.runners.Suite.runChild(Suite.java:128) at org.junit.runners.Suite.runChild(Suite.java:27) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:51) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)Caused by: java.sql.SQLException: Bad format for Timestamp '2017-06-30 7:00:00' in column 1. at com.mysql.jdbc.ResultSetRow.getTimestampFast(ResultSetRow.java:1157) at com.mysql.jdbc.ByteArrayRow.getTimestampFast(ByteArrayRow.java:130) at com.mysql.jdbc.ResultSetImpl.getTimestampInternal(ResultSetImpl.java:5946) at com.mysql.jdbc.ResultSetImpl.getTimestamp(ResultSetImpl.java:5616) at org.apache.commons.dbcp.DelegatingResultSet.getTimestamp(DelegatingResultSet.java:250) at org.apache.commons.dbcp.DelegatingResultSet.getTimestamp(DelegatingResultSet.java:250) ... 36 more</description>
      <version>1.14.0</version>
      <fixedVersion>1.17.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.rel.rel2sql.RelToSqlConverterTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.dialect.MysqlSqlDialect.java</file>
    </fixedFiles>
  </bug>
  <bug id="1893" opendate="2017-7-17 00:00:00" fixdate="2017-7-17 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Add MYSQL_5 conformance</summary>
      <description>Add MYSQL_5 conformance value, indicating that Calcite should accept the same SQL dialect extensions as MySQL 5.x.</description>
      <version>None</version>
      <fixedVersion>1.14.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlConformanceEnum.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlConformance.java</file>
    </fixedFiles>
  </bug>
  <bug id="1895" opendate="2017-7-19 00:00:00" fixdate="2017-8-19 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Substring operator broken for MSSQL</summary>
      <description>The format mssql uses looks like:SUBSTRING(input, start, length)but the default is currently to unparse to SUBSTRING(input FROM start FOR length)</description>
      <version>None</version>
      <fixedVersion>1.14.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.rel.rel2sql.RelToSqlConverterTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.dialect.MssqlHandler.java</file>
    </fixedFiles>
  </bug>
  <bug id="1896" opendate="2017-7-20 00:00:00" fixdate="2017-7-20 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>sqlsh: SQL access to shell commands, as a shell command</summary>
      <description>Bourne shell has a toolkit of commands that allow you to do relational processing: grep = WHERE, sort = ORDER BY, uniq = SELECT DISTINCT, head = OFFSET/LIMIT, and so forth. Shell hackers are accustomed to writing pipelines. For example, to find the 3 largest files one would type$ find . -type f -print0 |xargs -0 ls -l | sort -nr -k 5 | head -3-rw-r--r-- 1 jhyde staff 416028 Jul 16 10:06 ./core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java-rw-r--r-- 1 jhyde staff 325727 Jun 28 11:48 ./core/src/test/java/org/apache/calcite/test/JdbcTest.java-rw-r--r-- 1 jhyde staff 325106 Jul 16 10:06 ./core/src/test/resources/org/apache/calcite/test/RelOptRulesTest.xmlSQL is not quite as concise but nevertheless:$ sqlsh select \* from files where not directory order by size desc limit 3sqlsh is "SQL shell", a wrapper around Calcite JDBC. files is a view backed by a table function that calls "find .". Other commands: du table function - e.g. select path, size_k from du git_ls_files table function calls git-ls-files - e.g. select * from git_ls_files ps table function calls ps aux - e.g. select * from ps wc function calls wc - e.g. select path, lineCount from git_ls_files cross apply wc(path)SQL would run in a lexical mode which is case-sensitive, and identifiers are not upper-cased if not quoted.We could consider allowing shell-safe characters such as '-' in unquoted identifiers. (It's difficult to quote identifiers in SQL if the SQL has already passed through bash's quote handling, and had double-quotes and single-quotes removed.)It gets really interesting when commands accept arguments, and Calcite pushes down filters to become those arguments. For example, insqlsh select distinct author from git_ls_files join git_commit_files using \(path\) join git_commits using \(commit\)Calcite should rewrite to use git log.When accessing files, some kinds of files have implicit names (and types) for fields, and some don't. You should be able to access fields by name or position; the following are equivalent:sqlsh select gid from /etc/passwd where uid = 100sqlsh select $4 from /etc/passwd where $3 = 100</description>
      <version>None</version>
      <fixedVersion>1.14.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site..docs.adapter.md</file>
      <file type="M">pom.xml</file>
      <file type="M">plus.src.test.java.org.apache.calcite.test.PlusSuite.java</file>
      <file type="M">plus.pom.xml</file>
      <file type="M">core.src.main.java.org.apache.calcite.util.JsonBuilder.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.runtime.Hook.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.type.RelDataTypeFactory.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.jdbc.CalciteConnectionImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.DataContext.java</file>
    </fixedFiles>
  </bug>
  <bug id="1898" opendate="2017-7-23 00:00:00" fixdate="2017-7-23 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>LIKE must match &amp;#39;.&amp;#39; (period) literally</summary>
      <description>The LIKE operator must match '.' (period) literally, not treat it as a wild-card. Currently it treats it the same as '_'.For example, 'abc' LIKE 'a.c' currently evaluates to TRUE but should evaluate to FALSE.</description>
      <version>None</version>
      <fixedVersion>1.14.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlOperatorBaseTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.runtime.Like.java</file>
    </fixedFiles>
  </bug>
  <bug id="1931" opendate="2017-8-7 00:00:00" fixdate="2017-8-7 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Change the return type of RANK, NTILE and other aggregate functions</summary>
      <description>RANK, NTILE etc. functions should not always return INTEGER. For example, RANK() and PERCENT_RANK() both return INTEGER. For RANK(), it would be better to return BIGINT; for PERCENT_RANK(), we should actually return DOUBLE or FLOAT since it is a percent value. There are other rank functions that should return floating number instead of INTEGER.</description>
      <version>None</version>
      <fixedVersion>1.14.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site..docs.history.md</file>
      <file type="M">core.src.test.resources.org.apache.calcite.test.SqlToRelConverterTest.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.JdbcTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.type.ReturnTypes.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlRankFunction.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.fun.SqlStdOperatorTable.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.fun.SqlNtileAggFunction.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.type.RelDataTypeSystemImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.type.RelDataTypeSystem.java</file>
    </fixedFiles>
  </bug>
  <bug id="1936" opendate="2017-8-10 00:00:00" fixdate="2017-8-10 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Allow ROUND() and TRUNCATE() to take only one operand</summary>
      <description>Some databases (e.g. Oracle and MS Sqlserver) allow ROUND and TRUNCATE to take only one operand for ease of use. For example, we could allow ROUND(12.3) to mean ROUND(12.3, 0), TRUNCATE(12.3, 0) to mean TRUNCATE(12.3).</description>
      <version>None</version>
      <fixedVersion>1.14.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site..docs.reference.md</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlOperatorBaseTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.type.OperandTypes.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.fun.SqlStdOperatorTable.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.runtime.SqlFunctions.java</file>
    </fixedFiles>
  </bug>
  <bug id="1988" opendate="2017-9-18 00:00:00" fixdate="2017-10-18 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Various code quality issues</summary>
      <description></description>
      <version>None</version>
      <fixedVersion>1.15.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.util.UtilTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.util.XmlOutput.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.util.NlsString.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlValidatorUtil.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlValidatorImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlTimestampLiteral.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlTimeLiteral.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlNumericLiteral.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlNode.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlLiteral.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlIntervalLiteral.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlDateLiteral.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlCharStringLiteral.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlBinaryStringLiteral.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.fun.SqlNullifFunction.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.fun.SqlCoalesceFunction.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.interpreter.AggregateNode.java</file>
    </fixedFiles>
  </bug>
  <bug id="1989" opendate="2017-9-18 00:00:00" fixdate="2017-10-18 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Check dependencies for vulnerabilities each release</summary>
      <description>Check dependencies for vulnerabilities each release. Use OWASP Dependency Check, probably its maven plugin.</description>
      <version>None</version>
      <fixedVersion>1.15.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site..docs.howto.md</file>
      <file type="M">pom.xml</file>
    </fixedFiles>
  </bug>
  <bug id="2002" opendate="2017-10-5 00:00:00" fixdate="2017-2-5 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>DISTINCT applied to VALUES returns wrong result</summary>
      <description>The following output is clearly wrong:baddistinct.sql0: jdbc:calcite:model=inline:{"version":1.0,"&gt; SELECT DISTINCT T.B FROM (VALUES (1, 'X'),(2, 'Y'),(3, 'X'),(4, 'X')) AS T(A, B);+---+| B |+---+| X || Y || X || X |+---+4 rows selected (0.014 seconds)I'm guessing it is distinct-ing against the complete value tuple rather than the selected column, since the following is correct:gooddistinct.sql0: jdbc:calcite:model=inline:{"version":1.0,"&gt; SELECT DISTINCT T.B FROM (VALUES (1, 'X'),(2, 'Y'),(3, 'X'),(3, 'X')) AS T(A, B);+---+| B |+---+| X || Y |+---+2 rows selected (0.013 seconds)</description>
      <version>1.14.0</version>
      <fixedVersion>1.16.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.sql.misc.iq</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelMetadataTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.metadata.RelMdColumnUniqueness.java</file>
    </fixedFiles>
  </bug>
  <bug id="2004" opendate="2017-10-9 00:00:00" fixdate="2017-4-9 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>The TableFunction left outer join was improperly translated</summary>
      <description>Currently the TableFunction left outer join is translated to a LogicalCorrelate followed by a LogicalFilter. For instance, given a simple table WordCount(word:String, frequency:Int), a table function split: word:String =&gt; (letter:String, length:String), and a query SELECT word, letter, length FROM WordCount LEFT JOIN LATERAL TABLE(split(word)) AS T (letter, length) ON frequency = length OR length &lt; 5" the query will be translated to the logical plan below.LogicalProject(word=[$0], name=[$2], length=[$3]) LogicalFilter(condition=[OR(=($1, CAST($3):BIGINT), &lt;($3, 5))]) LogicalCorrelate(correlation=[$cor0], joinType=[left], requiredColumns=[{0}]) LogicalTableScan(table=[[WordCount]]) LogicalTableFunctionScan(invocation=[split($cor0.word)], rowType=[RecordType(VARCHAR(65536) _1, INTEGER _2)], elementType=[class [Ljava.lang.Object;])With this plan, an outer row might be completely filtered out (instead of being padded with null) if the join predicate filter filters out all join results produced by a correlate join for the outer row. Maybe we should attach the filter to the correlate operation.</description>
      <version>None</version>
      <fixedVersion>1.20.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.org.apache.calcite.test.SqlToRelConverterTest.xml</file>
      <file type="M">core.src.test.resources.org.apache.calcite.test.RelOptRulesTest.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.TableFunctionTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlToRelConverterTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelOptRulesTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql2rel.SqlToRelConverter.java</file>
    </fixedFiles>
  </bug>
  <bug id="2005" opendate="2017-10-9 00:00:00" fixdate="2017-11-9 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Core project failed during default-test on Windows</summary>
      <description>The following failure is generated when running "mvn clean install"[INFO] ------------------------------------------------------------------------[INFO] Reactor Summary:[INFO][INFO] Calcite ............................................ SUCCESS [ 2.728 s][INFO] Calcite Linq4j ..................................... SUCCESS [ 13.181 s][INFO] Calcite Core ....................................... FAILURE [03:31 min][INFO] Calcite Cassandra .................................. SKIPPED[INFO] Calcite Druid ...................................... SKIPPED[INFO] Calcite Elasticsearch .............................. SKIPPED[INFO] Calcite Elasticsearch5 ............................. SKIPPED[INFO] Calcite Examples ................................... SKIPPED[INFO] Calcite Example CSV ................................ SKIPPED[INFO] Calcite Example Function ........................... SKIPPED[INFO] Calcite File ....................................... SKIPPED[INFO] Calcite MongoDB .................................... SKIPPED[INFO] Calcite Pig ........................................ SKIPPED[INFO] Calcite Piglet ..................................... SKIPPED[INFO] Calcite Plus ....................................... SKIPPED[INFO] Calcite Spark ...................................... SKIPPED[INFO] Calcite Splunk ..................................... SKIPPED[INFO] Calcite Ubenchmark ................................. SKIPPED[INFO] ------------------------------------------------------------------------[INFO] BUILD FAILURE[INFO] ------------------------------------------------------------------------[INFO] Total time: 03:47 min[INFO] Finished at: 2017-10-09T14:10:17+03:00[INFO] Final Memory: 72M/1649M[INFO] ------------------------------------------------------------------------[ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.19.1:test (default-test) on project calcite-core: There are test failures.[ERROR][ERROR] Please refer to D:\Project\git\calcite\core\target\surefire-reports for the individual test results.[ERROR] -&gt; [Help 1]org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.19.1:test (default-test) on project calcite-core: There are test failures.Please refer to D:\Project\git\calcite\core\target\surefire-reports for the individual test results. at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:213) at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:154) at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:146) at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:117) at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:81) at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:51) at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128) at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:309) at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:194) at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:107) at org.apache.maven.cli.MavenCli.execute(MavenCli.java:993) at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:345) at org.apache.maven.cli.MavenCli.main(MavenCli.java:191) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289) at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229) at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415) at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356)Caused by: org.apache.maven.plugin.MojoFailureException: There are test failures.Please refer to D:\Project\git\calcite\core\target\surefire-reports for the individual test results. at org.apache.maven.plugin.surefire.SurefireHelper.reportExecution(SurefireHelper.java:91) at org.apache.maven.plugin.surefire.SurefirePlugin.handleSummary(SurefirePlugin.java:320) at org.apache.maven.plugin.surefire.AbstractSurefireMojo.executeAfterPreconditionsChecked(AbstractSurefireMojo.java:892) at org.apache.maven.plugin.surefire.AbstractSurefireMojo.execute(AbstractSurefireMojo.java:755) at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:134) at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:208) ... 20 more[ERROR][ERROR] Re-run Maven using the -X switch to enable full debug logging.[ERROR][ERROR] For more information about the errors and possible solutions, please read the following articles:[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException[ERROR][ERROR] After correcting the problems, you can resume the build with the command[ERROR] mvn &lt;goals&gt; -rf :calcite-core</description>
      <version>1.14.0</version>
      <fixedVersion>1.15.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">file.src.test.java.org.apache.calcite.adapter.file.FileReaderTest.java</file>
      <file type="M">file.pom.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.UtilTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelMetadataTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.CalciteAssert.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.interpreter.Interpreter.java</file>
    </fixedFiles>
  </bug>
  <bug id="2006" opendate="2017-10-10 00:00:00" fixdate="2017-10-10 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Push IS NULL and IS NOT NULL predicates to Druid</summary>
      <description>Using SelectorDimFilter with null value should be sufficient to push IS NULL/IS NOT NULL to druid as a selector filter.</description>
      <version>None</version>
      <fixedVersion>1.15.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">druid.src.test.java.org.apache.calcite.test.DruidAdapterIT.java</file>
      <file type="M">druid.src.main.java.org.apache.calcite.adapter.druid.DruidQuery.java</file>
    </fixedFiles>
  </bug>
  <bug id="2008" opendate="2017-10-12 00:00:00" fixdate="2017-10-12 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Fix braces in TRIM signature</summary>
      <description>The signature says [BOTH|LEADING|TRAILING} but it should be [BOTH|LEADING|TRAILING]</description>
      <version>None</version>
      <fixedVersion>1.15.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.main.java.org.apache.calcite.sql.fun.SqlTrimFunction.java</file>
    </fixedFiles>
  </bug>
  <bug id="2014" opendate="2017-10-17 00:00:00" fixdate="2017-10-17 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Look for saffron.properties file in classpath rather then in working directory</summary>
      <description>Calcite is using several saffron properties.There are two ways to set them:1. as system property;2. using saffron.properties file.Using saffron.properties file is very convenient when you need to set several properties at a time. In code saffron.properties location is expected to be working folder, i.e. the place where java process was started.For production systems it would much better is saffron.properties file was expected to be present in classpath rather then in working directory.</description>
      <version>1.14.0</version>
      <fixedVersion>1.15.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.main.java.org.apache.calcite.util.SaffronProperties.java</file>
    </fixedFiles>
  </bug>
  <bug id="2041" opendate="2017-11-8 00:00:00" fixdate="2017-11-8 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>When ReduceExpressionRule simplifies a nullable expression, allow the result to change type to NOT NULL</summary>
      <description>In some cases, the user needs to select whether or not to add casts that match nullability.One of the motivations behind this is to avoid unnecessary casts like the following example.original filter OR(AND(&gt;=($0, CAST(_UTF-16LE'2010-01-01 00:00:00 UTC'):TIMESTAMP_WITH_LOCAL_TIME_ZONE(15)), &lt;=($0, CAST(_UTF-16LE'2012-03-01 00:00:00 UTC'):TIMESTAMP_WITH_LOCAL_TIME_ZONE(15))))the optimized expression with matching nullabilityOR(AND(CAST(&gt;=($0, 2010-01-01 00:00:00)):BOOLEAN, CAST(&lt;=($0, 2012-03-01 00:00:00)):BOOLEAN))As you can see this extra cast gets into the way of following plan optimization steps.The desired expression can be obtained by turning off the nullability matching.OR(AND(&gt;=($0, 2010-01-01 00:00:00), &lt;=($0, 2012-03-01 00:00:00)))</description>
      <version>None</version>
      <fixedVersion>1.15.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.org.apache.calcite.test.RelOptRulesTest.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RexImplicationCheckerTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelOptRulesTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlOperatorBaseTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rex.RexUtil.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.rules.ValuesReduceRule.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.rules.ReduceExpressionsRule.java</file>
    </fixedFiles>
  </bug>
  <bug id="2044" opendate="2017-11-8 00:00:00" fixdate="2017-11-8 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Tweak cost of BindableTableScan to make sure Project is pushed through Aggregate</summary>
      <description>Similar to CALCITE-1876.Projects are not pushed to BindableTableScan when using ProjectableFilterableTable with aggregate functions.The reason is that the cost of BindableTableScan does not use projects (and filters), so the planner chooses a plan with Project node removed by ProjectRemoveRule.By tweaking the cost to use the number of used projects solved the problem.Any suggestion on the cost formula to take both projects and filters into account?</description>
      <version>None</version>
      <fixedVersion>1.15.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.test.ScannableTableTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.interpreter.Bindables.java</file>
    </fixedFiles>
  </bug>
  <bug id="2045" opendate="2017-11-8 00:00:00" fixdate="2017-4-8 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Support "CREATE TYPE" DDL</summary>
      <description></description>
      <version>None</version>
      <fixedVersion>1.17.0</fixedVersion>
      <type>New Feature</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site..docs.reference.md</file>
      <file type="M">site..docs.model.md</file>
      <file type="M">server.src.test.java.org.apache.calcite.test.ServerTest.java</file>
      <file type="M">server.src.test.java.org.apache.calcite.test.ServerParserTest.java</file>
      <file type="M">server.src.main.java.org.apache.calcite.sql.ddl.SqlDropObject.java</file>
      <file type="M">server.src.main.java.org.apache.calcite.sql.ddl.SqlDdlNodes.java</file>
      <file type="M">server.src.main.java.org.apache.calcite.sql.ddl.SqlCreateTable.java</file>
      <file type="M">server.src.main.codegen.includes.parserImpls.ftl</file>
      <file type="M">server.src.main.codegen.config.fmpp</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlValidatorTestCase.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlValidatorTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.ModelTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.MockCatalogReader.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.CalciteSuite.java</file>
      <file type="M">core.src.main.resources.org.apache.calcite.runtime.CalciteResource.properties</file>
      <file type="M">core.src.main.java.org.apache.calcite.util.Util.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlValidatorUtil.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlValidatorImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlKind.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlDataTypeSpec.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql2rel.StandardConvertletTable.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.schema.SchemaPlus.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.schema.Schema.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.schema.impl.DelegatingSchema.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.schema.impl.AbstractSchema.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.runtime.CalciteResource.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.prepare.RelOptTableImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.prepare.CalciteCatalogReader.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.model.ModelHandler.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.model.JsonRoot.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.model.JsonMapSchema.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.jdbc.SimpleCalciteSchema.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.jdbc.CalciteSchema.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.jdbc.CachingCalciteSchema.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.jdbc.JdbcSchema.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.enumerable.RexToLixTranslator.java</file>
    </fixedFiles>
  </bug>
  <bug id="2379" opendate="2018-6-25 00:00:00" fixdate="2018-7-25 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>CVSS dependency-check-maven fails for calcite-spark module</summary>
      <description>Check for vulnerabilities among dependencies fails for calcite-spark module."mvn install -Ppedantic -DskipTests=true" fails for lib py4j-0.10.4.jar.</description>
      <version>None</version>
      <fixedVersion>1.17.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">ubenchmark.pom.xml</file>
      <file type="M">spark.pom.xml</file>
      <file type="M">site..docs.howto.md</file>
    </fixedFiles>
  </bug>
  <bug id="2380" opendate="2018-6-25 00:00:00" fixdate="2018-6-25 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Elasticsearch, MongoDB, Druid adapters have javadoc errors</summary>
      <description>javadoc generation fails for some adapters.Commands to reproduce:$ mvn -DskipTests clean javadoc:javadoc javadoc:test-javadoc$ mvn -DskipTests clean site</description>
      <version>None</version>
      <fixedVersion>1.17.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">pom.xml</file>
      <file type="M">mongodb.src.test.java.org.apache.calcite.test.MongoAssertions.java</file>
      <file type="M">mongodb.src.test.java.org.apache.calcite.adapter.mongodb.MongoDatabaseRule.java</file>
      <file type="M">mongodb.src.test.java.org.apache.calcite.adapter.mongodb.MongoAdapterTest.java</file>
      <file type="M">mongodb.src.main.java.org.apache.calcite.adapter.mongodb.MongoToEnumerableConverter.java</file>
      <file type="M">mongodb.src.main.java.org.apache.calcite.adapter.mongodb.MongoTable.java</file>
      <file type="M">mongodb.src.main.java.org.apache.calcite.adapter.mongodb.MongoSchema.java</file>
      <file type="M">elasticsearch5.src.test.java.org.apache.calcite.test.ElasticChecker.java</file>
      <file type="M">elasticsearch5.src.test.java.org.apache.calcite.adapter.elasticsearch5.EmbeddedElasticRule.java</file>
      <file type="M">elasticsearch5.src.test.java.org.apache.calcite.adapter.elasticsearch5.EmbeddedElasticNode.java</file>
      <file type="M">elasticsearch5.src.test.java.org.apache.calcite.adapter.elasticsearch5.ElasticSearch5AdapterTest.java</file>
      <file type="M">elasticsearch5.src.main.java.org.apache.calcite.adapter.elasticsearch5.Elasticsearch5Table.java</file>
      <file type="M">elasticsearch5.src.main.java.org.apache.calcite.adapter.elasticsearch5.Elasticsearch5Schema.java</file>
      <file type="M">elasticsearch5.src.main.java.org.apache.calcite.adapter.elasticsearch5.Elasticsearch5Enumerator.java</file>
      <file type="M">elasticsearch2.src.test.java.org.apache.calcite.test.ElasticChecker.java</file>
      <file type="M">elasticsearch2.src.test.java.org.apache.calcite.adapter.elasticsearch2.EmbeddedElasticRule.java</file>
      <file type="M">elasticsearch2.src.test.java.org.apache.calcite.adapter.elasticsearch2.EmbeddedElasticNode.java</file>
      <file type="M">elasticsearch2.src.test.java.org.apache.calcite.adapter.elasticsearch2.ElasticSearch2AdapterTest.java</file>
      <file type="M">elasticsearch2.src.main.java.org.apache.calcite.adapter.elasticsearch2.Elasticsearch2Table.java</file>
      <file type="M">elasticsearch2.src.main.java.org.apache.calcite.adapter.elasticsearch2.Elasticsearch2Schema.java</file>
      <file type="M">elasticsearch2.src.main.java.org.apache.calcite.adapter.elasticsearch2.Elasticsearch2Enumerator.java</file>
    </fixedFiles>
  </bug>
  <bug id="2381" opendate="2018-6-26 00:00:00" fixdate="2018-7-26 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Update HOWTOs to clarify a few gotchas</summary>
      <description>Some issues I ran into while releasing Avatica 1.12.0 that should be clarified in the HOWTO document on the website: GPG signs using a default key (I think this is the first key, if no default is set). I had multiple keys and my Apache key was not my first key. I was not 100% sure that `-DdevelopmentVersion` should be the version after the current release. It took a while to work out how to authenticate against Apache's maven repo. See http://www.apache.org/dev/publishing-maven-artifacts.html#dev-env for solutionThe HOWTO for Calcite should also be updated to aid future release managers.</description>
      <version>None</version>
      <fixedVersion>1.17.0,avatica-1.13.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site..docs.howto.md</file>
    </fixedFiles>
  </bug>
  <bug id="2427" opendate="2018-7-24 00:00:00" fixdate="2018-4-24 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Sub-queries not supported in DML statements</summary>
      <description>It appears that subqueries are not supported in DML statements.The yield in a NPE.Respective testcase is disabled with reference to CALCITE-1527.@Ignore("CALCITE-1527")@Test public void testUpdateSubQuery() {final String sql = "update emp\n"+ "set empno = (\n"+ " select min(empno) from emp as e where e.deptno = emp.deptno)";sql(sql).ok();}  </description>
      <version>1.14.0,1.15.0,1.16.0</version>
      <fixedVersion>1.20.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.org.apache.calcite.test.SqlToRelConverterTest.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.tools.PlannerTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlToRelConverterTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql2rel.SqlToRelConverter.java</file>
    </fixedFiles>
  </bug>
  <bug id="2428" opendate="2018-7-30 00:00:00" fixdate="2018-12-30 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Cassandra unit test fails to parse JDK version string</summary>
      <description>Unit test fails because java.version string is parsed incorrectly</description>
      <version>None</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.util.TestUtil.java</file>
      <file type="M">cassandra.src.test.java.org.apache.calcite.test.CassandraAdapterTest.java</file>
    </fixedFiles>
  </bug>
</bugrepository>
