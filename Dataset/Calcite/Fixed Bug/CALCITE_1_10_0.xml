<?xml version="1.0" encoding="UTF-8"?>

<bugrepository name="CALCITE">
  <bug id="1425" opendate="2016-10-10 00:00:00" fixdate="2016-12-10 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Support two-level column structure in INSERT/UPDATE/MERGE</summary>
      <description></description>
      <version>1.10.0</version>
      <fixedVersion>1.11.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.org.apache.calcite.test.SqlToRelConverterTest.xml</file>
      <file type="M">core.src.test.resources.org.apache.calcite.test.RelOptRulesTest.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlValidatorTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlToRelConverterTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelOptRulesTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.MockCatalogReader.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlValidatorUtil.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlValidatorImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlValidator.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.ListScope.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.IdentifierNamespace.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.DelegatingScope.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlInsert.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlIdentifier.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.advise.SqlAdvisorValidator.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql2rel.SqlToRelConverter.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.schema.CustomExpansionTable.java</file>
    </fixedFiles>
  </bug>
  <bug id="1426" opendate="2016-10-10 00:00:00" fixdate="2016-10-10 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Support customized star expansion in Table</summary>
      <description>This is to support PHOENIX-3357. Phoenix allows users to define columns in arbitrary order regardless of their column families, for example,CREATE TABLE t (a_string varchar not null, cf1.a integer, cf1.b varchar, col1 integer, cf2.c varchar, cf2.d integer, col2 integer CONSTRAINT pk PRIMARY KEY (a_string)), in which columns from the same family (i.e., col1 and col2 from the default column family) are not necessarily adjacent to each other.As a result, when we return row type for a PhoenixTable, we re-order the columns in order to fit them into the two-level column structure. This works fine in most cases except when:1) "upsert into t ..." would require a different row type even after flattening (we do not have flattening so far, still need to implement CALCITE-1425).2) select * from t would return a different column order.</description>
      <version>None</version>
      <fixedVersion>1.11.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.org.apache.calcite.test.SqlToRelConverterTest.xml</file>
      <file type="M">core.src.test.resources.org.apache.calcite.test.RelOptRulesTest.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlValidatorTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlToRelConverterTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.MockCatalogReader.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlValidatorImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlValidator.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlInsert.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlIdentifier.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.advise.SqlAdvisorValidator.java</file>
    </fixedFiles>
  </bug>
  <bug id="1433" opendate="2016-10-12 00:00:00" fixdate="2016-10-12 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>avatica-server module depends on non-existent avatica test-jar</summary>
      <description>Because of CALCITE-1224, avatica artifact was renamed avatica-core (and a new avatica artifact is produced). Unfortunately, avatica-server still depends on avatica test-jar, which is now avatica-core test-jar.</description>
      <version>None</version>
      <fixedVersion>avatica-1.9.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">avatica.standalone-server.pom.xml</file>
      <file type="M">avatica.server.pom.xml</file>
      <file type="M">avatica.pom.xml</file>
    </fixedFiles>
  </bug>
  <bug id="1439" opendate="2016-10-14 00:00:00" fixdate="2016-2-14 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Handle errors during constant reduction</summary>
      <description>A literal is a constant, and so a cast of a literal is also a constant, but when we do constant reduction sometimes there are errors if the cast is not valid. For example, the queryvalues cast('' as integer)gives ExceptionInInitializerError and, to make matters worse, the Avatica JDBC driver does not catch the exception (because it is a java.lang.Error) and wrap it as a java.sql.SQLException as it ought to.Note that cast('1.2' as integer) is also invalid but cast(' -1 ' as integer) is valid.This issue probably also applies to divide-by-zero and other exceptions evaluating scalar expressions.</description>
      <version>None</version>
      <fixedVersion>1.12.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.sql.misc.iq</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RexProgramTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rex.RexExecutable.java</file>
    </fixedFiles>
  </bug>
  <bug id="1442" opendate="2016-10-14 00:00:00" fixdate="2016-10-14 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Interval fractional second precision returns wrong value</summary>
      <description>Unless I'm wrong, I believe SqlIntervalQualifer#getFractionalSecondPrecisionPreservingDefault() returns the wrong field: public int getFractionalSecondPrecision(RelDataTypeSystem typeSystem) { if (fractionalSecondPrecision == RelDataType.PRECISION_NOT_SPECIFIED) { return typeName().getDefaultScale(); } else { return fractionalSecondPrecision; } } public int getFractionalSecondPrecisionPreservingDefault() { if (useDefaultFractionalSecondPrecision()) { return RelDataType.PRECISION_NOT_SPECIFIED; } else { return startPrecision; } }</description>
      <version>None</version>
      <fixedVersion>1.11.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlValidatorTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlIntervalQualifier.java</file>
    </fixedFiles>
  </bug>
  <bug id="1444" opendate="2016-10-17 00:00:00" fixdate="2016-10-17 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Add CONVERT JDBC function</summary>
      <description>Both ODBC and JDBC spec mention a CONVERT scalar function, which is the equivalent of the CAST function.In order for JDBC and ODBC drivers to expose support for this function, calcite should support parsing it, and converting it into a CAST expression (currently, it doesn't unlike some other scalar functions).</description>
      <version>None</version>
      <fixedVersion>1.11.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site..docs.reference.md</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlOperatorBaseTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.parser.SqlParserTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlJdbcFunctionCall.java</file>
      <file type="M">core.src.main.codegen.templates.Parser.jj</file>
    </fixedFiles>
  </bug>
  <bug id="1447" opendate="2016-10-17 00:00:00" fixdate="2016-11-17 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Implement INTERSECT DISTINCT by rewriting to UNION ALL and counting</summary>
      <description>Interesect distinct will be rewritten as Rewrite: (GB-Union All-GB)-GB-FIL-Proj Example: R1 Intersect All R2 R3 = GB(R1 on all attributes + count() as c) union all GB(R2 on all attributes + count() as c) R4 = GB(R3 on all attributes + count(c) as cnt) R5 = Fil ( cnt == #branch ) R6 = Proj(R5 on all attributes)</description>
      <version>None</version>
      <fixedVersion>1.11.0</fixedVersion>
      <type>Sub-task</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.sql.misc.iq</file>
      <file type="M">core.src.test.resources.sql.dummy.iq</file>
      <file type="M">core.src.test.resources.org.apache.calcite.test.RelOptRulesTest.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelOptRulesTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.JdbcFrontLinqBackTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql2rel.SqlToRelConverter.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.plan.RelOptUtil.java</file>
    </fixedFiles>
  </bug>
  <bug id="1448" opendate="2016-10-17 00:00:00" fixdate="2016-10-17 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Add rules to flatten and prune Intersect and Minus</summary>
      <description>similar to current unionMergeRule.</description>
      <version>None</version>
      <fixedVersion>1.11.0</fixedVersion>
      <type>Sub-task</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.org.apache.calcite.test.RelOptRulesTest.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelOptRulesTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.tools.RelBuilder.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.rules.UnionMergeRule.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.rules.PruneEmptyRules.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.plan.RelOptUtil.java</file>
    </fixedFiles>
  </bug>
  <bug id="1463" opendate="2016-10-23 00:00:00" fixdate="2016-10-23 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Remove exclusions from standalone-server&amp;#39;s shaded jar</summary>
      <description>More fallout from the non-shaded+shaded client changes in CALCITE-1224.The standalone-server's shaded jar was excluding some dependencies already present because it only provided the shaded jar. When switching it to use the non-shaded artifact, the exclusions should have been removed and they were not.</description>
      <version>None</version>
      <fixedVersion>avatica-1.9.0</fixedVersion>
      <type>Task</type>
    </buginformation>
    <fixedFiles>
      <file type="M">avatica.standalone-server.pom.xml</file>
    </fixedFiles>
  </bug>
  <bug id="1464" opendate="2016-10-23 00:00:00" fixdate="2016-10-23 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Upgrade dependencies to latest in their maintenance lines</summary>
      <description>Updating jetty to 9.2.19.v20160908 is probably safe/good to do. Updating to jodatime 2.9.4 also sounds good</description>
      <version>None</version>
      <fixedVersion>avatica-1.9.0</fixedVersion>
      <type>Task</type>
    </buginformation>
    <fixedFiles>
      <file type="M">avatica.pom.xml</file>
    </fixedFiles>
  </bug>
  <bug id="1483" opendate="2016-11-8 00:00:00" fixdate="2016-11-8 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Suboptimal plan for NOT IN query</summary>
      <description>Following query generates sub-optimal plan explain plan for select * from scott.emp where deptno not in (select deptno from scott.dept where deptno = 20); Following is the planEnumerableCalc(expr#0..11=[{inputs}], expr#12=[0], expr#13=[=($t8, $t12)], expr#14=[false], expr#15=[IS NOT NULL($t11)], expr#16=[true], expr#17=[IS NULL($t7)], expr#18=[null], expr#19=[&lt;($t9, $t8)], expr#20=[CASE($t13, $t14, $t15, $t16, $t17, $t18, $t19, $t16, $t14)], expr#21=[NOT($t20)], proj#0..7=[{exprs}], $condition=[$t21]) EnumerableJoin(condition=[=($7, $10)], joinType=[left]) EnumerableCalc(expr#0..9=[{inputs}], EMPNO=[$t2], ENAME=[$t3], JOB=[$t4], MGR=[$t5], HIREDATE=[$t6], SAL=[$t7], COMM=[$t8], DEPTNO=[$t9], c=[$t0], ck=[$t1]) EnumerableJoin(condition=[true], joinType=[inner]) JdbcToEnumerableConverter JdbcAggregate(group=[{}], c=[COUNT()], ck=[COUNT($0)]) JdbcFilter(condition=[=(CAST($0):INTEGER NOT NULL, 20)]) JdbcTableScan(table=[[SCOTT, DEPT]]) JdbcToEnumerableConverter JdbcTableScan(table=[[SCOTT, EMP]]) JdbcToEnumerableConverter JdbcAggregate(group=[{0, 1}]) JdbcProject(DEPTNO=[$0], i=[true]) JdbcFilter(condition=[=(CAST($0):INTEGER NOT NULL, 20)]) JdbcTableScan(table=[[SCOTT, DEPT]])As Julian pointed out in discussion on mailing list instead of two scans for DEPT one is sufficient as clearly DEPTNO is never null.</description>
      <version>None</version>
      <fixedVersion>1.11.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.org.apache.calcite.test.SqlToRelConverterTest.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlToRelConverterTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql2rel.SqlToRelConverter.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.plan.RelOptUtil.java</file>
    </fixedFiles>
  </bug>
  <bug id="1484" opendate="2016-11-8 00:00:00" fixdate="2016-11-8 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Upgrade Apache parent POM to version 18</summary>
      <description>Upgrade Apache parent POM to version 18, which was released in May; we are currently on version 17.The differences seem to include: upgrade various plugins change http: to https: in URLs exclude DEPENDENCIES from release (related to CALCITE-741)</description>
      <version>None</version>
      <fixedVersion>1.11.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">ubenchmark.pom.xml</file>
      <file type="M">spark.pom.xml</file>
      <file type="M">pom.xml</file>
    </fixedFiles>
  </bug>
  <bug id="1485" opendate="2016-11-8 00:00:00" fixdate="2016-11-8 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Upgrade Avatica&amp;#39;s Apache parent POM to version 18</summary>
      <description>In Avatica, upgrade Apache parent POM to version 18. Details similar to CALCITE-1484.</description>
      <version>None</version>
      <fixedVersion>avatica-1.10.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">avatica.tck.pom.xml</file>
      <file type="M">avatica.standalone-server.pom.xml</file>
      <file type="M">avatica.shaded.core.pom.xml</file>
      <file type="M">avatica.server.pom.xml</file>
      <file type="M">avatica.pom.xml</file>
      <file type="M">avatica.core.pom.xml</file>
    </fixedFiles>
  </bug>
  <bug id="1502" opendate="2016-11-22 00:00:00" fixdate="2016-11-22 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>AssertionError when case statement is used with optional value and literal using ReduceExpressionsRule</summary>
      <description>AssertionError when we use case with optional value and literal using ReduceExpressionsRule:SELECT CASE WHEN 1=2 THEN cast((values(1)) as integer) ELSE 2 end from (values(1))Stack trace:java.lang.AssertionError: Internal error: Cannot add expression of different type to set:set type is RecordType(INTEGER EXPR$0) NOT NULLexpression type is RecordType(INTEGER NOT NULL EXPR$0) NOT NULLset is rel#14:LogicalProject(input=HepRelVertex#13,EXPR$0=CASE(=(1, 2), CAST($1):INTEGER, 2))expression is LogicalProject#16</description>
      <version>1.10.0</version>
      <fixedVersion>1.11.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.org.apache.calcite.test.RelOptRulesTest.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelOptRulesTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rex.RexUtil.java</file>
    </fixedFiles>
  </bug>
  <bug id="1506" opendate="2016-11-23 00:00:00" fixdate="2016-11-23 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Push OVER Clause to underlying SQL via JDBC adapter</summary>
      <description>The jdbc adapter adapter should push down the OVER clause for all dialects that support window functions. At the moment the Rel to SQL conversion ignores the 'OVER(...)'. The RexOver expression is treated as a plain RexCall and the RexOver#window attribute is not converted into SQL. For example if the following sql query (using Postgres dialect): SELECT "id", "device_id", "transaction_value", "account_id", "ts_millis", MAX("ts_millis") OVER(partition by "device_id") as "last_version_number" FROM "HAWQ"."transaction"WHERE "device_id" = 1445is pushed down to the jdbc like this:SELECT "id", "device_id", "transaction_value", "account_id", "ts_millis", MAX("ts_millis") AS "last_version_number"FROM "transaction"WHERE "device_id" = 1445The OVER clause is completely dropped! Here is the plan:JdbcToEnumerableConverter JdbcProject(id=[$0], device_id=[$1], transaction_value=[$2], account_id=[$3], ts_millis=[$4], last_version_number=[MAX($4) OVER (PARTITION BY $1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)]) JdbcFilter(condition=[=($1, 1445)]) JdbcTableScan(table=[[HAWQ, transaction]])</description>
      <version>1.10.0</version>
      <fixedVersion>1.11.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.test.JdbcAdapterTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.rel2sql.SqlImplementor.java</file>
    </fixedFiles>
  </bug>
  <bug id="1510" opendate="2016-11-24 00:00:00" fixdate="2016-2-24 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>INSERT/UPSERT should allow fewer values than columns</summary>
      <description>Currently calcite not allowing to write if the values less than number of columns. We can write the leading columns with the all values and remaining columns can be considered as null or else we can allow specifying columns and corresponding values. Ping julianhyde jamestaylor maryannxue.</description>
      <version>None</version>
      <fixedVersion>1.12.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">src.main.config.checkstyle.checker.xml</file>
      <file type="M">site..docs.reference.md</file>
      <file type="M">core.src.test.resources.org.apache.calcite.test.SqlToRelConverterTest.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlValidatorTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlToRelTestBase.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlToRelConverterTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.MockCatalogReader.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlAdvisorTest.java</file>
      <file type="M">core.src.main.resources.org.apache.calcite.runtime.CalciteResource.properties</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlValidatorTable.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlValidatorImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlDelegatingConformance.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlConformanceEnum.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlConformance.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlAbstractConformance.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.advise.SqlAdvisorValidator.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql2rel.StandardConvertletTable.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql2rel.SqlToRelConverter.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql2rel.SqlRexContext.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql2rel.DefaultValueFactory.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.schema.Wrapper.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.runtime.CalciteResource.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.prepare.RelOptTableImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.prepare.Prepare.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.prepare.CalciteSqlValidator.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.plan.RelOptTable.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.plan.Context.java</file>
    </fixedFiles>
  </bug>
  <bug id="1513" opendate="2016-11-29 00:00:00" fixdate="2016-3-29 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Correlated NOT IN query throws AssertionError</summary>
      <description>A correlated NOT IN query throws AssertionError during decorrelation. Here is a patch that reproduces the case:diff --git a/core/src/test/resources/sql/subquery.iq b/core/src/test/resources/sql/subquery.iqindex ad71655..975aae1 100644--- a/core/src/test/resources/sql/subquery.iq+++ b/core/src/test/resources/sql/subquery.iq@@ -370,6 +370,22 @@ where e.job not in ( !plan !} +# Correlated condition in NOT IN.+# Tested on Oracle.+select count(*) as c+from "scott".emp as e+where sal + 100 not in (+ select comm+ from "scott".emp+ where job = e.job);+ EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO+---------- ---------- --------- ---------- --------- ---------- ---------- ----------+ 7499 ALLEN SALESMAN 7698 20-FEB-81 1600 300 30+ 7521 WARD SALESMAN 7698 22-FEB-81 1250 500 30+ 7654 MARTIN SALESMAN 7698 28-SEP-81 1250 1400 30+ 7844 TURNER SALESMAN 7698 08-SEP-81 1500 0 30+!ok+ # [CALCITE-864] Correlation variable has incorrect row type if it is populated # by right side of a Join select *And here is the stack:java.lang.AssertionError: Internal error: While invoking method 'public org.apache.calcite.sql2rel.RelDecorrelator$Frame org.apache.calcite.sql2rel.RelDecorrelator.decorrelateRel(org.apache.calcite.rel.logical.LogicalAggregate)' at org.apache.calcite.util.Util.newInternal(Util.java:792) at org.apache.calcite.util.ReflectUtil$2.invoke(ReflectUtil.java:534) at org.apache.calcite.sql2rel.RelDecorrelator.getInvoke(RelDecorrelator.java:601) at org.apache.calcite.sql2rel.RelDecorrelator.decorrelate(RelDecorrelator.java:242) at org.apache.calcite.sql2rel.RelDecorrelator.decorrelateQuery(RelDecorrelator.java:211) at org.apache.calcite.tools.Programs$DecorrelateProgram.run(Programs.java:370) at org.apache.calcite.tools.Programs$SequenceProgram.run(Programs.java:351) at org.apache.calcite.prepare.Prepare.optimize(Prepare.java:155) at org.apache.calcite.prepare.Prepare.prepareSql(Prepare.java:286) at org.apache.calcite.prepare.Prepare.prepareSql(Prepare.java:195) at org.apache.calcite.prepare.CalcitePrepareImpl.prepare2_(CalcitePrepareImpl.java:748) at org.apache.calcite.prepare.CalcitePrepareImpl.prepare_(CalcitePrepareImpl.java:610) at org.apache.calcite.prepare.CalcitePrepareImpl.prepareSql(CalcitePrepareImpl.java:580)Caused by: java.lang.reflect.InvocationTargetException at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.apache.calcite.util.ReflectUtil$2.invoke(ReflectUtil.java:531) ... 29 moreCaused by: java.lang.AssertionError at org.apache.calcite.sql2rel.RelDecorrelator.decorrelateRel(RelDecorrelator.java:454) ... 34 more</description>
      <version>None</version>
      <fixedVersion>1.19.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.sql.sub-query.iq</file>
    </fixedFiles>
  </bug>
  <bug id="1520" opendate="2016-12-1 00:00:00" fixdate="2016-3-1 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>org.apache.calcite.avatica.AvaticaConnection: support isValid()</summary>
      <description>Currently the calss org.apache.calcite.avatica.AvaticaConnection does not support isValid(): public boolean isValid(int timeout) throws SQLException { throw helper.unsupported(); }On JasperSoft server, we created a dataSource using Calcite jdbc driver. When use JasperSoft "test connection" feature, it failed with the exception:java.sql.SQLFeatureNotSupportedException at org.apache.calcite.avatica.Helper.unsupported(Helper.java:68) at org.apache.calcite.avatica.AvaticaConnection.isValid(AvaticaConnection.java:373) at org.apache.commons.dbcp.DelegatingConnection.isValid(DelegatingConnection.java:626) at org.apache.commons.dbcp.DelegatingConnection.isValid(DelegatingConnection.java:626) at com.jaspersoft.jasperserver.api.engine.jasperreports.service.impl.JdbcDataSourceService.isConnectionValid(JdbcDataSourceService.java:102) at com.jaspersoft.jasperserver.api.engine.jasperreports.service.impl.JdbcDataSourceService.testConnection(JdbcDataSourceService.java:86) at com.jaspersoft.jasperserver.remote.connection.JdbcConnectionStrategy.createConnection(JdbcConnectionStrategy.java:76) at com.jaspersoft.jasperserver.remote.connection.JdbcConnectionStrategy.createConnection(JdbcConnectionStrategy.java:45) at com.jaspersoft.jasperserver.remote.connection.ConnectionsManager.createConnection(ConnectionsManager.java:72) at com.jaspersoft.jasperserver.jaxrs.connection.ConnectionsJaxrsService.createConnection(ConnectionsJaxrsService.java:84) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) at java.lang.reflect.Method.invoke(Unknown Source) at com.sun.jersey.spi.container.JavaMethodInvokerFactory$1.invoke(JavaMethodInvokerFactory.java:60) at com.sun.jersey.server.impl.model.method.dispatch.AbstractResourceMethodDispatchProvider$ResponseOutInvoker._dispatch(AbstractResourceMethodDispatchProvider.java:205) at com.sun.jersey.server.impl.model.method.dispatch.ResourceJavaMethodDispatcher.dispatch(ResourceJavaMethodDispatcher.java:75) at com.sun.jersey.server.impl.uri.rules.HttpMethodRule.accept(HttpMethodRule.java:302) at com.sun.jersey.server.impl.uri.rules.ResourceClassRule.accept(ResourceClassRule.java:108) at com.sun.jersey.server.impl.uri.rules.RightHandPathRule.accept(RightHandPathRule.java:147) at com.sun.jersey.server.impl.uri.rules.RootResourceClassesRule.accept(RootResourceClassesRule.java:84) at com.sun.jersey.server.impl.application.WebApplicationImpl._handleRequest(WebApplicationImpl.java:1483) at com.sun.jersey.server.impl.application.WebApplicationImpl._handleRequest(WebApplicationImpl.java:1414) at com.sun.jersey.server.impl.application.WebApplicationImpl.handleRequest(WebApplicationImpl.java:1363) at com.sun.jersey.server.impl.application.WebApplicationImpl.handleRequest(WebApplicationImpl.java:1353) at com.sun.jersey.spi.container.servlet.WebComponent.service(WebComponent.java:414) at com.sun.jersey.spi.container.servlet.ServletContainer.service(ServletContainer.java:537) at com.sun.jersey.spi.container.servlet.ServletContainer.service(ServletContainer.java:708) at javax.servlet.http.HttpServlet.service(HttpServlet.java:729) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:292) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) at com.jaspersoft.jasperserver.war.StaticFilesCacheControlFilter.doFilter(StaticFilesCacheControlFilter.java:161) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:118) at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:84) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:113) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:113) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) at com.jaspersoft.jasperserver.api.metadata.user.service.impl.MetadataAuthenticationProcessingFilter.doFilter(MetadataAuthenticationProcessingFilter.java:143) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) at com.ca.jasper.authentication.JaaSProxyAuthenticationFilter.doFilter(JaaSProxyAuthenticationFilter.java:183) at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:343) at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:260) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) at com.jaspersoft.jasperserver.multipleTenancy.MTBasicProcessingFilter.doFilter(MTBasicProcessingFilter.java:194) at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:343) at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:260) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) at com.jaspersoft.jasperserver.war.UserPreferencesFilter.doFilter(UserPreferencesFilter.java:217) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:199) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) at com.jaspersoft.jasperserver.war.NullFilter.doFilter(NullFilter.java:43) at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:343) at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:260) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) at com.ca.jasper.ext.filter.ExternalAuthenticationProxyFilter.doFilter(ExternalAuthenticationProxyFilter.java:77) at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:343) at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:260) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) at com.jaspersoft.jasperserver.war.UserPreferencesFilter.doFilter(UserPreferencesFilter.java:217) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) at com.jaspersoft.jasperserver.api.logging.filter.BasicLoggingFilter.doFilter(BasicLoggingFilter.java:57) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) at com.jaspersoft.jasperserver.api.security.JSCsrfGuardFilter.doFilter(JSCsrfGuardFilter.java:83) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) at com.jaspersoft.jasperserver.api.security.WebAppSecurityFilter.doFilter(WebAppSecurityFilter.java:80) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) at com.jaspersoft.jasperserver.war.NullFilter.doFilter(NullFilter.java:43) at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:343) at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:260) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) at com.jaspersoft.jasperserver.api.security.encryption.EncryptionFilter.doFilter(EncryptionFilter.java:150) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:87) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) at com.ca.jasper.filters.BasicRefererBasedCsrfFilter.doFilter(BasicRefererBasedCsrfFilter.java:136) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) at com.jaspersoft.ji.license.JILicenseFilter.doFilter(JILicenseFilter.java:86) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:192) at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:160) at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:343) at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:260) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) at com.jaspersoft.jasperserver.war.util.SessionDecoratorFilter.doFilter(SessionDecoratorFilter.java:63) at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:343) at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:260) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) at com.jaspersoft.jasperserver.war.util.CharacterEncodingFilter.doFilter(CharacterEncodingFilter.java:67) at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:343) at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:260) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) at com.jaspersoft.jasperserver.war.P3PFilter.doFilter(P3PFilter.java:43) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:212) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:106) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:614) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:141) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:79) at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:616) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:88) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:522) at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1095) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:672) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1500) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1456) at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source) at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Unknown Source)</description>
      <version>1.10.0</version>
      <fixedVersion>avatica-1.12.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.jdbc.CalciteRemoteDriverTest.java</file>
    </fixedFiles>
  </bug>
  <bug id="1524" opendate="2016-12-2 00:00:00" fixdate="2016-12-2 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Add a project to the planner root so that rules know which output fields are used</summary>
      <description>Add a project to the planner root so that rules know which output fields are used.One such rule is SemiJoinRule; it can only apply if it knows that no fields are used from the right-hand input, so it has to match a Project at the root of its pattern.</description>
      <version>None</version>
      <fixedVersion>1.11.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.main.java.org.apache.calcite.rel.RelRoot.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.prepare.Prepare.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.plan.RelOptMaterialization.java</file>
    </fixedFiles>
  </bug>
  <bug id="1529" opendate="2016-12-5 00:00:00" fixdate="2016-12-5 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Support CREATE TABLE in tests (and only in tests)</summary>
      <description>Support CREATE TABLE in tests. It is useful to be able to create tables with small amounts of test data for the duration of tests. We should add CREATE TABLE the same way that we added ALTER SYSTEM UPLOAD JAR in CALCITE-1384. Also, make it available to Quidem tests via a connection specification and schema called BLANK.</description>
      <version>None</version>
      <fixedVersion>1.11.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site..docs.reference.md</file>
      <file type="M">pom.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.QuidemTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.CalciteAssert.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.parser.SqlParserTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.parser.parserextensiontesting.ExtensionSqlParserTest.java</file>
      <file type="M">core.src.test.codegen.includes.parserImpls.ftl</file>
      <file type="M">core.src.test.codegen.config.fmpp</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlDataTypeSpec.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.prepare.CalcitePrepareImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.config.CalciteConnectionProperty.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.config.CalciteConnectionConfigImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.config.CalciteConnectionConfig.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.enumerable.EnumerableTableScan.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.enumerable.EnumerableTableModify.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.enumerable.EnumerableRelImplementor.java</file>
      <file type="M">core.src.main.codegen.templates.Parser.jj</file>
      <file type="M">core.src.main.codegen.config.fmpp</file>
    </fixedFiles>
  </bug>
  <bug id="1534" opendate="2016-12-8 00:00:00" fixdate="2016-12-8 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Allow compound identifiers in INSERT target column list</summary>
      <description>Since CALCITE-1425, the assumption of column names always being simple qualifiers in INSERT/UPDATE target column list has been removed, which means SqlValidator and Sql2RelConverter can handle compound identifiers in those places. Right now we are going to add parser support for compound identifiers.</description>
      <version>1.10.0</version>
      <fixedVersion>1.11.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlValidatorTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlToRelConverterTest.java</file>
      <file type="M">core.src.main.codegen.templates.Parser.jj</file>
    </fixedFiles>
  </bug>
  <bug id="1540" opendate="2016-12-15 00:00:00" fixdate="2016-12-15 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Support multiple columns in PARTITION BY clause of window function</summary>
      <description>When I add multiple partition columns to a window function: @Test public void testSelect() throws SQLException { checkSql("model", "select NAME,DEPTNO,count(*) over (partition by NAME,DEPTNO) from EMPS"); }Following exception is thrown:java.sql.SQLException: Error while executing SQL "select NAME,DEPTNO,count(*) over (partition by NAME,DEPTNO) from EMPS": Error while compiling generated Java code:However the document from calcite.apache.org/docs/reference.html states multiple partition columns should be allowed:windowSpec: [ windowName ] '(' [ ORDER BY orderItem [, orderItem ]* ] [ PARTITION BY expression [, expression ]* ] [ RANGE numericOrIntervalExpression { PRECEDING | FOLLOWING } | ROWS numericExpression { PRECEDING | FOLLOWING } ] ')'After searching it seems no one is reporting the same issue. I'm opening this JIAR as a placeholder, will try to fix this issue</description>
      <version>1.10.0</version>
      <fixedVersion>1.11.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.sql.winagg.iq</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.enumerable.PhysTypeImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.enumerable.PhysType.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.enumerable.EnumerableWindow.java</file>
    </fixedFiles>
  </bug>
  <bug id="1546" opendate="2016-12-20 00:00:00" fixdate="2016-1-20 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Wrong plan for NOT IN sub-queries with disjunction</summary>
      <description>Query:select * from emp where sal = 4 OR empno NOT IN (select deptno from dept)Plan:LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8]) LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8]) LogicalFilter(condition=[OR(=($5, 4), NOT(CASE(IS NOT NULL($10), true, false)))]) LogicalJoin(condition=[=($0, $9)], joinType=[left]) LogicalTableScan(table=[[CATALOG, SALES, EMP]]) LogicalAggregate(group=[{0, 1}]) LogicalProject(DEPTNO=[$0], i=[true]) LogicalProject(DEPTNO=[$0]) LogicalTableScan(table=[[CATALOG, SALES, DEPT]])There is no null check branch i.e. with count(&amp;#42;), count(c) in the plan. This produces wrong results if deptno is null in dept.</description>
      <version>None</version>
      <fixedVersion>1.12.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.sql.blank.iq</file>
      <file type="M">core.src.test.resources.org.apache.calcite.test.RelOptRulesTest.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RexTransformerTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelOptRulesTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rex.LogicVisitor.java</file>
    </fixedFiles>
  </bug>
  <bug id="1547" opendate="2016-12-20 00:00:00" fixdate="2016-1-20 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Release Calcite 1.11.0</summary>
      <description>Release Apache Calcite 1.11.0. The plan is to release in early January, target code freeze on Wed Dec 28th.</description>
      <version>None</version>
      <fixedVersion>1.11.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site..docs.howto.md</file>
      <file type="M">site..docs.history.md</file>
      <file type="M">README</file>
      <file type="M">pom.xml</file>
      <file type="M">NOTICE</file>
    </fixedFiles>
  </bug>
  <bug id="1548" opendate="2016-12-21 00:00:00" fixdate="2016-12-21 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Instantiate function objects once per query</summary>
      <description>If a user-defined function is based on a class and its methods are non-static then it needs to be instantiated; at present the code generator seems to instantiate it once per iteration, but it should be instantiated in a static member, therefore once per query.</description>
      <version>None</version>
      <fixedVersion>1.11.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">linq4j.src.test.java.org.apache.calcite.linq4j.test.ExpressionTest.java</file>
      <file type="M">linq4j.src.main.java.org.apache.calcite.linq4j.tree.DeterministicCodeOptimizer.java</file>
      <file type="M">linq4j.src.main.java.org.apache.calcite.linq4j.tree.BlockBuilder.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.Smalls.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.UdfTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.enumerable.ReflectiveCallNotNullImplementor.java</file>
    </fixedFiles>
  </bug>
  <bug id="1549" opendate="2016-12-21 00:00:00" fixdate="2016-1-21 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Improve error message when table or column not found</summary>
      <description>When a table is not found in a query, the current message makes it difficult to tell among several possibilities: the schema was incorrect, the schema was correct but had wrong case, the table was incorrect, the table was correct but had wrong case. Given a query, sayselect * from schema1.table1, schema2.table2, table3we should give an error that discriminates between those possibilities for "schema1.table1", and also for "table3" looking in the default schema.</description>
      <version>None</version>
      <fixedVersion>1.12.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.sql.misc.iq</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.UtilTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlValidatorTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlToRelTestBase.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.ReflectiveSchemaTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.MultiJdbcSchemaJoinTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.MockCatalogReader.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.LatticeTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.JdbcTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.ExceptionMessageTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.CollectionTypeTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlAdvisorTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.DefaultSqlTestFactory.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.prepare.LookupOperatorOverloadsTest.java</file>
      <file type="M">core.src.main.resources.org.apache.calcite.runtime.CalciteResource.properties</file>
      <file type="M">core.src.main.java.org.apache.calcite.util.Util.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.WithScope.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlValidatorUtil.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlValidatorScope.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlValidatorImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlValidatorCatalogReader.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlQualified.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.OrderByScope.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.ListScope.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.IdentifierNamespace.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.EmptyScope.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.DelegatingSqlValidatorCatalogReader.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.DelegatingScope.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.AbstractNamespace.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlIdentifier.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql2rel.SqlToRelConverter.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.schema.Table.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.runtime.CalciteResource.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.prepare.RelOptTableImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.prepare.Prepare.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.prepare.CalciteCatalogReader.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.jdbc.JavaTypeFactoryImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.jdbc.CalciteSchema.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.enumerable.RexImpTable.java</file>
    </fixedFiles>
  </bug>
  <bug id="1552" opendate="2016-12-22 00:00:00" fixdate="2016-12-22 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Add RAND function, returning DOUBLE values in the range 0..1</summary>
      <description>Add RAND function, returning DOUBLE values in the range 0..1. It has variants RAND() and RAND(seed).Also, add RAND_INTEGER(seed, bound), support for a seed when generating random integers.To support seeds, the random function needs to have state. The random number generator is initialized, using the seed, on first use, and subsequent calls use the same random number generator. So, we are building on CALCITE-1548.</description>
      <version>None</version>
      <fixedVersion>1.11.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site..docs.reference.md</file>
      <file type="M">core.src.test.resources.sql.misc.iq</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlOperatorBaseTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.util.BuiltInMethod.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.fun.SqlStdOperatorTable.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.fun.SqlRandInteger.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.runtime.SqlFunctions.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.enumerable.RexImpTable.java</file>
    </fixedFiles>
  </bug>
  <bug id="1557" opendate="2016-12-31 00:00:00" fixdate="2016-1-31 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Add missing support for numerical JDBC functions</summary>
      <description>Calcite advertises support for all numerical functions but only have implementations for some (ABS, EXP, LOG, LOG10, MOD, POWER)It would be a nice-to have to extend the support so that all functions are covered.</description>
      <version>None</version>
      <fixedVersion>1.12.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site..docs.reference.md</file>
      <file type="M">core.src.test.resources.sql.misc.iq</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlFunctionsTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlOperatorBaseTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.type.OperandTypes.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlJdbcFunctionCall.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.fun.SqlStringContextVariable.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.fun.SqlStdOperatorTable.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.runtime.SqlFunctions.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.enumerable.RexImpTable.java</file>
      <file type="M">core.src.main.codegen.templates.Parser.jj</file>
    </fixedFiles>
  </bug>
  <bug id="1561" opendate="2017-1-4 00:00:00" fixdate="2017-1-4 01:00:00" resolution="Unresolved">
    <buginformation>
      <summary>Intermittent test failures</summary>
      <description>A few tests are currently failing intermittently.1. UdfTestUdfTest.testUserDefinedFunction:162 Expected: is &lt;9&gt; but: was &lt;10&gt;2. StreamTest.testInfiniteStreamsDoNotBufferInMemoryFAILURE! - in org.apache.calcite.test.StreamTesttestInfiniteStreamsDoNotBufferInMemory(org.apache.calcite.test.StreamTest)Time elapsed: 0.218 sec &lt;&lt;&lt; ERROR!java.lang.RuntimeException: exception while executing [select stream * fromorders]atorg.apache.calcite.test.StreamTest.testInfiniteStreamsDoNotBufferInMemory(StreamTest.java:237)Caused by: java.util.NoSuchElementExceptionatorg.apache.calcite.test.StreamTest.testInfiniteStreamsDoNotBufferInMemory(StreamTest.java:237)I don't consider any of them serious &amp;#8211; they are test issues, not product correctness issues &amp;#8211; but they are inconvenient because false negatives waste developer time.</description>
      <version>None</version>
      <fixedVersion>None</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">pig.src.test.java.org.apache.calcite.test.PigRelBuilderStyleTest.java</file>
      <file type="M">pig.pom.xml</file>
    </fixedFiles>
  </bug>
  <bug id="1562" opendate="2017-1-4 00:00:00" fixdate="2017-1-4 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Update findbugs jsr305</summary>
      <description>If we update the version of jsr305 that we use, we also obtain clarity on the license of the artifact to assuage any concerns.</description>
      <version>None</version>
      <fixedVersion>1.12.0</fixedVersion>
      <type>Task</type>
    </buginformation>
    <fixedFiles>
      <file type="M">pom.xml</file>
    </fixedFiles>
  </bug>
  <bug id="1567" opendate="2017-1-7 00:00:00" fixdate="2017-1-7 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>JDK9 support for Avatica</summary>
      <description>Make sure Avatica can build, run tests, and generate javadoc in JDK9.The corresponding issue for Calcite is CALCITE-1258.</description>
      <version>None</version>
      <fixedVersion>avatica-1.10.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">avatica.tck.src.main.java.org.apache.calcite.avatica.tck.tests.BaseTckTest.java</file>
      <file type="M">avatica.server.src.test.java.org.apache.calcite.avatica.server.HttpServerBuilderTest.java</file>
      <file type="M">avatica.server.src.test.java.org.apache.calcite.avatica.server.HandlerFactoryTest.java</file>
      <file type="M">avatica.server.src.test.java.org.apache.calcite.avatica.server.AbstractAvaticaHandlerTest.java</file>
      <file type="M">avatica.server.src.test.java.org.apache.calcite.avatica.jdbc.StatementInfoTest.java</file>
      <file type="M">avatica.server.src.test.java.org.apache.calcite.avatica.jdbc.JdbcMetaTest.java</file>
      <file type="M">avatica.pom.xml</file>
      <file type="M">avatica.metrics.src.test.java.org.apache.calcite.avatica.metrics.MetricsSystemLoaderTest.java</file>
      <file type="M">avatica.metrics-dropwizardmetrics3.src.test.java.org.apache.calcite.avatica.metrics.dropwizard3.DropwizardTimerTest.java</file>
      <file type="M">avatica.metrics-dropwizardmetrics3.src.test.java.org.apache.calcite.avatica.metrics.dropwizard3.DropwizardMetricsSystemTest.java</file>
      <file type="M">avatica.metrics-dropwizardmetrics3.src.test.java.org.apache.calcite.avatica.metrics.dropwizard3.DropwizardMeterTest.java</file>
      <file type="M">avatica.metrics-dropwizardmetrics3.src.test.java.org.apache.calcite.avatica.metrics.dropwizard3.DropwizardHistogramTest.java</file>
      <file type="M">avatica.core.src.test.java.org.apache.calcite.avatica.remote.ProtobufHandlerTest.java</file>
      <file type="M">avatica.core.src.test.java.org.apache.calcite.avatica.remote.KerberosConnectionTest.java</file>
      <file type="M">avatica.core.src.test.java.org.apache.calcite.avatica.remote.AvaticaHttpClientTest.java</file>
      <file type="M">avatica.core.src.test.java.org.apache.calcite.avatica.remote.AvaticaCommonsHttpClientImplTest.java</file>
      <file type="M">avatica.core.src.test.java.org.apache.calcite.avatica.remote.AbstractHandlerTest.java</file>
      <file type="M">avatica.core.src.test.java.org.apache.calcite.avatica.QueryStateTest.java</file>
      <file type="M">avatica.core.src.test.java.org.apache.calcite.avatica.AvaticaStatementTest.java</file>
      <file type="M">avatica.core.src.test.java.org.apache.calcite.avatica.AvaticaConnectionTest.java</file>
    </fixedFiles>
  </bug>
  <bug id="1568" opendate="2017-1-7 00:00:00" fixdate="2017-1-7 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Upgrade Mockito, and re-enable tests</summary>
      <description>Re-enable tests disabled in JDK9 due to Mockito bug. See CALCITE-1567 and SOLR-9893 for details.</description>
      <version>None</version>
      <fixedVersion>avatica-1.10.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">avatica.tck.src.main.java.org.apache.calcite.avatica.tck.tests.BaseTckTest.java</file>
      <file type="M">avatica.server.src.test.java.org.apache.calcite.avatica.server.HttpServerBuilderTest.java</file>
      <file type="M">avatica.server.src.test.java.org.apache.calcite.avatica.server.HandlerFactoryTest.java</file>
      <file type="M">avatica.server.src.test.java.org.apache.calcite.avatica.server.AbstractAvaticaHandlerTest.java</file>
      <file type="M">avatica.server.src.test.java.org.apache.calcite.avatica.jdbc.StatementInfoTest.java</file>
      <file type="M">avatica.server.src.test.java.org.apache.calcite.avatica.jdbc.JdbcMetaTest.java</file>
      <file type="M">avatica.server.pom.xml</file>
      <file type="M">avatica.pom.xml</file>
      <file type="M">avatica.metrics.src.test.java.org.apache.calcite.avatica.metrics.MetricsSystemLoaderTest.java</file>
      <file type="M">avatica.metrics.pom.xml</file>
      <file type="M">avatica.metrics-dropwizardmetrics3.src.test.java.org.apache.calcite.avatica.metrics.dropwizard3.DropwizardTimerTest.java</file>
      <file type="M">avatica.metrics-dropwizardmetrics3.src.test.java.org.apache.calcite.avatica.metrics.dropwizard3.DropwizardMetricsSystemTest.java</file>
      <file type="M">avatica.metrics-dropwizardmetrics3.src.test.java.org.apache.calcite.avatica.metrics.dropwizard3.DropwizardMeterTest.java</file>
      <file type="M">avatica.metrics-dropwizardmetrics3.src.test.java.org.apache.calcite.avatica.metrics.dropwizard3.DropwizardHistogramTest.java</file>
      <file type="M">avatica.metrics-dropwizardmetrics3.pom.xml</file>
      <file type="M">avatica.core.src.test.java.org.apache.calcite.avatica.remote.ProtobufHandlerTest.java</file>
      <file type="M">avatica.core.src.test.java.org.apache.calcite.avatica.remote.KerberosConnectionTest.java</file>
      <file type="M">avatica.core.src.test.java.org.apache.calcite.avatica.remote.AvaticaHttpClientTest.java</file>
      <file type="M">avatica.core.src.test.java.org.apache.calcite.avatica.remote.AvaticaCommonsHttpClientImplTest.java</file>
      <file type="M">avatica.core.src.test.java.org.apache.calcite.avatica.remote.AbstractHandlerTest.java</file>
      <file type="M">avatica.core.src.test.java.org.apache.calcite.avatica.QueryStateTest.java</file>
      <file type="M">avatica.core.src.test.java.org.apache.calcite.avatica.AvaticaStatementTest.java</file>
      <file type="M">avatica.core.src.test.java.org.apache.calcite.avatica.AvaticaConnectionTest.java</file>
      <file type="M">avatica.core.pom.xml</file>
    </fixedFiles>
  </bug>
  <bug id="1569" opendate="2017-1-9 00:00:00" fixdate="2017-1-9 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Code generation for fields of type java.sql.Date</summary>
      <description>Date condition can generates Integer == Integer, which is always false. Therefore a join condition that should match values fails to match them. Run the below query on calcite 1.10.select l.cal_dt , sum(left_join_gvm) as left_join_sum , sum(inner_join_gvm) as inner_join_sumfrom ( select test_kylin_fact.cal_dt, sum(price) as left_join_gvm from test_kylin_fact group by test_kylin_fact.cal_dt ) l , ( select test_kylin_fact.cal_dt, sum(price) as inner_join_gvm from test_kylin_fact group by test_kylin_fact.cal_dt ) iwhere l.cal_dt = i.cal_dt -- this conditiongroup by l.cal_dtThe where condition generates Baz code like below./* 284 */ final org.apache.calcite.linq4j.AbstractEnumerable child1 = new org.apache.calcite.linq4j.AbstractEnumerable(){/* 285 */ public org.apache.calcite.linq4j.Enumerator enumerator() {/* 286 */ return new org.apache.calcite.linq4j.Enumerator(){/* 287 */ public final org.apache.calcite.linq4j.Enumerator inputEnumerator = _inputEnumerable1.enumerator();/* 288 */ public void reset() {/* 289 */ inputEnumerator.reset();/* 290 */ }/* 291 */ /* 292 */ public boolean moveNext() {/* 293 */ while (inputEnumerator.moveNext()) {/* 294 */ final Object[] current = (Object[]) inputEnumerator.current();/* 295 */ final Integer inp0_ = (Integer) current[0];/* 296 */ final Integer inp2_ = (Integer) current[2];/* 297 */ if (inp0_ != null &amp;&amp; inp2_ != null &amp;&amp; inp0_ == inp2_) {/* 298 */ return true;/* 299 */ }/* 300 */ }/* 301 */ return false;/* 302 */ }/* 303 */ /* 304 */ public void close() {/* 305 */ inputEnumerator.close();/* 306 */ }/* 307 */ /* 308 */ public Object current() {/* 309 */ final Object[] current = (Object[]) inputEnumerator.current();/* 310 */ return new Object[] {/* 311 */ current[0],/* 312 */ current[1],/* 313 */ current[3]};/* 314 */ }/* 315 */ /* 316 */ };/* 317 */ }/* 318 */ /* 319 */ };The problem is if (inp0_ != null &amp;&amp; inp2_ != null &amp;&amp; inp0_ == inp2_) is always false, by using == to compare two Integers.</description>
      <version>1.10.0</version>
      <fixedVersion>1.12.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.test.ReflectiveSchemaTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.runtime.SqlFunctions.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.enumerable.RexToLixTranslator.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.enumerable.PhysTypeImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.enumerable.JavaRowFormat.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.enumerable.EnumerableTableScan.java</file>
    </fixedFiles>
  </bug>
  <bug id="1575" opendate="2017-1-13 00:00:00" fixdate="2017-1-13 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Literals may lose precision during expression reduction</summary>
      <description></description>
      <version>1.11.0,1.10.0</version>
      <fixedVersion>1.12.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.org.apache.calcite.test.RelOptRulesTest.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelOptRulesTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rex.RexUtil.java</file>
    </fixedFiles>
  </bug>
  <bug id="1576" opendate="2017-1-14 00:00:00" fixdate="2017-1-14 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Use protobuf-maven-plugin</summary>
      <description>Use https://github.com/xolstice/protobuf-maven-pluginCan remove the need for the script presently in tree.</description>
      <version>None</version>
      <fixedVersion>avatica-1.10.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">avatica.standalone-server.pom.xml</file>
      <file type="M">avatica.pom.xml</file>
      <file type="M">avatica.noop-driver.pom.xml</file>
      <file type="M">avatica.metrics-dropwizardmetrics3.pom.xml</file>
      <file type="M">avatica.core.src.main.scripts.generate-protobuf.sh</file>
      <file type="M">avatica.core.src.main.java.org.apache.calcite.avatica.proto.Responses.java</file>
      <file type="M">avatica.core.src.main.java.org.apache.calcite.avatica.proto.Requests.java</file>
      <file type="M">avatica.core.src.main.java.org.apache.calcite.avatica.proto.Common.java</file>
      <file type="M">avatica.core.pom.xml</file>
    </fixedFiles>
  </bug>
  <bug id="1586" opendate="2017-1-18 00:00:00" fixdate="2017-1-18 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>JDBC adapter generates wrong SQL if UNION has more than two inputs</summary>
      <description>JDBC adapter generates wrong SQL if set operation (UNION, INTERSECT or MINUS) has more than two inputs. In union example, after UnionMergeRule, the union input is convert to three input, and rel-to-sql convert result is wrong.input sql SELECT *FROM (SELECT \"product_id\"FROM \"foodmart\".\"product\"UNION ALLSELECT \"product_id\"FROM \"foodmart\".\"sales_fact_1997\")UNION ALLSELECT \"product_class_id\" AS \"PRODUCT_ID\"FROM \"foodmart\".\"product_class\" output sql SELECT \"product_id\"FROM \"foodmart\".\"product\"UNION ALLSELECT \"product_id\"FROM \"foodmart\".\"sales_fact_1997\" the last union query is lost.</description>
      <version>1.10.0</version>
      <fixedVersion>1.12.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.rel.rel2sql.RelToSqlConverterTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.rel2sql.SqlImplementor.java</file>
    </fixedFiles>
  </bug>
</bugrepository>
