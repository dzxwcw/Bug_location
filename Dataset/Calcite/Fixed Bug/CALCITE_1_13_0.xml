<?xml version="1.0" encoding="UTF-8"?>

<bugrepository name="CALCITE">
  <bug id="1773" opendate="2017-5-3 00:00:00" fixdate="2017-5-3 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Add Test sql validator test for Pattern skip syntax in MATCH_RECOGNIZE</summary>
      <description>Add some test case for sqlValidatorTest for pattern skip function in match_recognize.</description>
      <version>1.13.0</version>
      <fixedVersion>1.13.0</fixedVersion>
      <type>Test</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.util.UtilTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlValidatorTestCase.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlValidatorMatchTest.java</file>
      <file type="M">core.src.main.resources.org.apache.calcite.runtime.CalciteResource.properties</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlValidatorImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.MatchRecognizeScope.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.runtime.CalciteResource.java</file>
    </fixedFiles>
  </bug>
  <bug id="1778" opendate="2017-5-8 00:00:00" fixdate="2017-5-8 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Query with "WHERE CASE" throws AssertionError "Cast for just nullability not allowed"</summary>
      <description>The following query throws "Cast for just nullability not allowed", just after ProjectFilterTransposeRule is invoked.select count(*)from empwhere case when mgr &lt; 10 then true else false end</description>
      <version>None</version>
      <fixedVersion>1.13.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.org.apache.calcite.test.RelOptRulesTest.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelOptRulesTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.tools.RelBuilder.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rex.RexSimplify.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.rules.ReduceExpressionsRule.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.rules.FilterProjectTransposeRule.java</file>
    </fixedFiles>
  </bug>
  <bug id="1781" opendate="2017-5-9 00:00:00" fixdate="2017-5-9 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Allow expression in CUBE and ROLLUP</summary>
      <description>Currently we only allow columns as arguments to CUBE and ROLLUP operators, whereas we allow expressions in the GROUP BY clause. This change would also allow expressions as arguments to CUBE and ROLLUP. Example:// the following are valid, and will remain validselect deptno from emp group by deptno; select deptno +1 from emp group by deptno + 1;select deptno from emp group by cube(deptno);select deptno from emp group by rollup(deptno);// the following are currently invalid, but would be validselect deptno +1 from emp group by cube(deptno + 1, empno - 1);select deptno +1 from emp group by rollup(deptno + 1, empno - 1);Note that as of CALCITE-1306, and with SqlConformance.isGroupByOrdinal enabled, select deptno from emp group by cube(1) should be valid because 1 is interpreted as an ordinal in the SELECT clause, not an expression.</description>
      <version>None</version>
      <fixedVersion>1.13.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.sql.agg.iq</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlValidatorTest.java</file>
    </fixedFiles>
  </bug>
  <bug id="1802" opendate="2017-5-22 00:00:00" fixdate="2017-5-22 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Add post-aggregation step for Union in materialized view rewriting</summary>
      <description>Follow-up on CALCITE-1795.Rewriting for Aggregate queries needs a post-aggregation step that is not currently added.Query:SELECT empid, deptname, SUM(salary) AS sFROM empsJOIN depts ON (emps.deptno = depts.deptno)WHERE salary &gt; 10000GROUP BY empid, deptname;Materialized view definition:SELECT empid, deptname, SUM(salary) AS sFROM empsJOIN depts ON (emps.deptno = depts.deptno)WHERE salary &gt; 12000GROUP BY empid, deptname;Rewriting:SELECT empid, deptname, SUM(s)FROM (SELECT empid, deptname, sFROM mvUNION ALLSELECT empid, deptname, SUM(salary) AS sFROM empsJOIN depts ON (emps.deptno = depts.deptno)WHERE salary &gt; 10000 AND salary &lt;= 12000GROUP BY empid, deptname) subqGROUP BY empid, deptname;</description>
      <version>None</version>
      <fixedVersion>1.13.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site..docs.materialized.views.md</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.MaterializationTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.rules.AbstractMaterializedViewRule.java</file>
    </fixedFiles>
  </bug>
  <bug id="1847" opendate="2017-6-18 00:00:00" fixdate="2017-7-18 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Queries fail in the Cassandra adapter</summary>
      <description>It seems like there has been a change with when getRowType is called. Not sure exactly what changed, but the Cassandra adapter relied on the old behaviour.</description>
      <version>1.13.0</version>
      <fixedVersion>1.13.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">cassandra.src.main.java.org.apache.calcite.adapter.cassandra.CassandraTable.java</file>
    </fixedFiles>
  </bug>
  <bug id="1864" opendate="2017-6-29 00:00:00" fixdate="2017-7-29 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Allow NULL literal as argument</summary>
      <description>Even though the SQL standard does not allow raw (non-casted) NULL literals, most databases do. So we should allow 1 = null or select * from emp where empno &gt; null. Of course, these expressions always return UNKNOWN.</description>
      <version>None</version>
      <fixedVersion>1.14.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.sql.misc.iq</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlValidatorTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlOperatorBaseTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlValidatorImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.type.SqlTypeUtil.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.type.SqlTypeFactoryImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.type.SameOperandTypeChecker.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlOperator.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.type.RelDataTypeFactory.java</file>
    </fixedFiles>
  </bug>
  <bug id="1886" opendate="2017-7-12 00:00:00" fixdate="2017-7-12 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Support "LIMIT [offset,] row_count", per MySQL</summary>
      <description>CALCITE support limit offset SQL grammar in CALCITE-43: [LIMIT { count | ALL}] [OFFSET start { ROW | ROWS}]AlsoLIMIT {[offset,] row_count}is popular used, especially in MySQL, such as:select * from tableA order by id limit 100,10;User should transform the existing SQLs until calcite support LIMIT {[offset,] row_count}</description>
      <version>None</version>
      <fixedVersion>1.14.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site..docs.reference.md</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.parser.SqlParserTest.java</file>
      <file type="M">core.src.main.resources.org.apache.calcite.runtime.CalciteResource.properties</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlConformanceEnum.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlConformance.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlAbstractConformance.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.runtime.CalciteResource.java</file>
      <file type="M">core.src.main.codegen.templates.Parser.jj</file>
    </fixedFiles>
  </bug>
  <bug id="1907" opendate="2017-7-27 00:00:00" fixdate="2017-7-27 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Table function with 1 column gives ClassCastException</summary>
      <description>If a table function has 1 column and is used under a Filter or Aggregate, the query gives ClassCastException when executed:java.lang.RuntimeException: exception while executing [select *from table("s"."fibonacci"())] at org.apache.calcite.test.CalciteAssert$AssertQuery.returns(CalciteAssert.java:1270) at org.apache.calcite.test.CalciteAssert$AssertQuery.returns(CalciteAssert.java:1249) at org.apache.calcite.test.TableFunctionTest.testUserDefinedTableFunction6(TableFunctionTest.java:381) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:51) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)Caused by: java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to java.lang.Long at org.apache.calcite.avatica.util.AbstractCursor$LongAccessor.getLong(AbstractCursor.java:550) at org.apache.calcite.avatica.AvaticaResultSet.getLong(AvaticaResultSet.java:277) at org.apache.calcite.test.TableFunctionTest$1.apply(TableFunctionTest.java:387) at org.apache.calcite.test.TableFunctionTest$1.apply(TableFunctionTest.java:382) at org.apache.calcite.test.CalciteAssert.assertQuery(CalciteAssert.java:533) at org.apache.calcite.test.CalciteAssert$AssertQuery.returns(CalciteAssert.java:1266)The cause is a slight difference what the enumerable to iterable converter requires (arrays if there is more than one column, scalars is there is 1 column) and the specification of table functions (always return arrays).Up until now we have been masking the problem by applying "slice" to the output of table functions. Which is fine if the output goes straight into the JDBC result set, but not fine if there are other operators, such as Filter or Aggregate, downstream.</description>
      <version>None</version>
      <fixedVersion>1.14.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.util.Smalls.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.UdfTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.JdbcTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.CalciteSuite.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlValidatorImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.enumerable.EnumerableTableFunctionScan.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.enumerable.EnumerableRelImplementor.java</file>
    </fixedFiles>
  </bug>
  <bug id="1909" opendate="2017-7-28 00:00:00" fixdate="2017-8-28 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Output rowType of Match should include PARTITION BY and ORDER BY columns</summary>
      <description>According to the documentation, the output rowType should also include partition by key columns and order by key columns.MATCH_RECOGNIZE is called the row pattern output table. The shape (row type) of the row pattern output table depends on the choice of ONE ROW PER MATCH or ALL ROWS PER MATCH: If ONE ROW PER MATCH is specied or implied, then the columns of the row pattern output table are the row pattern partitioning columns in their order of declaration, followed by the row pattern measure columns in their order of declaration. Since a table must have at least one column, this implies that there must be at least one row pattern partitioning column or one row pattern measure column. If ALL ROWS PER MATCH is speci ed, then the columns of the row pattern output table are the row pattern partitioning columns in their order of declaration, the ordering columns in their order of declaration, the row pattern measure columns in their order of declaration, and nally any remaining columns of the row pattern input table, in the order they occur in the row pattern input table.Currently, partition key columns and order by key columns are not included in the output row type.</description>
      <version>None</version>
      <fixedVersion>1.14.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.org.apache.calcite.test.SqlToRelConverterTest.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlToRelConverterTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlValidatorImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.type.RelDataTypeFactory.java</file>
    </fixedFiles>
  </bug>
  <bug id="1911" opendate="2017-7-31 00:00:00" fixdate="2017-8-31 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Support WITHIN clause in MATCH_RECOGNIZE</summary>
      <description>Window is an important feature for pattern detection, it defines the time duration for the events to match a pattern. Here is an example from doc:SELECT T.Ac2, T.Bc2, T.Cc2 FROM S MATCH_RECOGNIZE( MEASURES A.c2 as Ac2, B.c2 as Bc2, C.c2 as Cc2 PATTERN (A (B+ | C)) within 3000 milliseconds DEFINE A as A.c1=10 or A.c1=25, B as B.c1=20 or B.c1=15 or B.c1=25, C as C.c1=15 ) as T</description>
      <version>None</version>
      <fixedVersion>1.14.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site..docs.reference.md</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlValidatorMatchTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.parser.SqlParserTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rel.rel2sql.RelToSqlConverterTest.java</file>
      <file type="M">core.src.main.resources.org.apache.calcite.runtime.CalciteResource.properties</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlValidatorImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlMatchRecognize.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlIntervalQualifier.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql2rel.SqlToRelConverter.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.runtime.CalciteResource.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rex.RexLiteral.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.rel2sql.SqlImplementor.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.rel2sql.RelToSqlConverter.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.logical.LogicalMatch.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.core.RelFactories.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.core.Match.java</file>
      <file type="M">core.src.main.codegen.templates.Parser.jj</file>
    </fixedFiles>
  </bug>
  <bug id="1912" opendate="2017-8-1 00:00:00" fixdate="2017-3-1 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Support "FOR SYSTEM_TIME AS OF" in regular queries</summary>
      <description>As discussed in mailling list&amp;#91;1&amp;#93;, we hope to support "FOR SYSTEM_TIME AS OF" in Calcite to retrieve table contents as of a given point in time. &amp;#91;1&amp;#93; https://lists.apache.org/thread.html/f877f356a8365bf74ea7d8e4a171224104d653cf73861afb2901a58f@%3Cdev.calcite.apache.org%3E</description>
      <version>None</version>
      <fixedVersion>1.19.0</fixedVersion>
      <type>New Feature</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site..docs.reference.md</file>
      <file type="M">site..docs.algebra.md</file>
      <file type="M">core.src.test.resources.org.apache.calcite.test.SqlToRelConverterTest.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.StreamTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlValidatorTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlToRelConverterTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelBuilderTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.catalog.MockCatalogReaderSimple.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.catalog.MockCatalogReader.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.CalciteAssert.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlAdvisorTest.java</file>
      <file type="M">core.src.main.resources.org.apache.calcite.runtime.CalciteResource.properties</file>
      <file type="M">core.src.main.java.org.apache.calcite.tools.RelBuilder.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlValidatorTable.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlValidatorImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlLateralOperator.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlKind.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql2rel.SqlToRelConverter.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql2rel.RelStructuredTypeFlattener.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.schema.Schema.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.runtime.CalciteResource.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.metadata.RelMdDistribution.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.metadata.RelMdCollation.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.core.RelFactories.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.prepare.RelOptTableImpl.java</file>
      <file type="M">core.src.main.codegen.templates.Parser.jj</file>
    </fixedFiles>
  </bug>
  <bug id="1916" opendate="2017-8-1 00:00:00" fixdate="2017-7-1 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Use TPC-DS generator and run tests against TPC-DS at small scale</summary>
      <description>Use TPC-DS generator and run tests against TPC-DS at small scale. I previously started one at https://github.com/julianhyde/tpcds but Teradata have written a better one at https://github.com/Teradata/tpcds. We can use it in the same way that we use https://github.com/airlift/tpch for TPC-H.</description>
      <version>None</version>
      <fixedVersion>1.17.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">pom.xml</file>
      <file type="M">plus.src.test.java.org.apache.calcite.adapter.tpcds.TpcdsTest.java</file>
      <file type="M">plus.src.main.java.org.apache.calcite.adapter.tpcds.TpcdsSchemaFactory.java</file>
      <file type="M">plus.src.main.java.org.apache.calcite.adapter.tpcds.TpcdsSchema.java</file>
      <file type="M">plus.pom.xml</file>
    </fixedFiles>
  </bug>
  <bug id="1945" opendate="2017-8-16 00:00:00" fixdate="2017-8-16 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Allow custom return types for AVG/VARIANCE/STDDEV/COVAR</summary>
      <description>For example, return types of AVG() is the input type. So, if the input is INT/BIGINT type, AVG() is always truncated. Depending on the database, some database follow this behavior while others (e.g. Oracle/MySQL/etc.) do not and return floating point values for AVG(). Similar for other functions mentioned here.</description>
      <version>None</version>
      <fixedVersion>1.14.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.sql.agg.iq</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlOperatorBaseTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.type.ReturnTypes.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlKind.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.fun.SqlStdOperatorTable.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.fun.SqlCovarAggFunction.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.fun.SqlAvgAggFunction.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql2rel.StandardConvertletTable.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.runtime.SqlFunctions.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.type.RelDataTypeSystemImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.type.RelDataTypeSystem.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.rules.AggregateReduceFunctionsRule.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.rel2sql.SqlImplementor.java</file>
    </fixedFiles>
  </bug>
  <bug id="1946" opendate="2017-8-16 00:00:00" fixdate="2017-10-16 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Dialects lacking support for nested aggregations should use sub select instead</summary>
      <description>Below query, containing 2 SUM aggregation functions and sub-select, gets converted to a SQL that fails when executed in various SQL engines.SQLSELECT SUM("net_weight1") AS "net_weight_converted"FROM ( SELECT SUM(" net_weight") AS "net_weight1" FROM "foodmart"."product" GROUP BY "product_id")Expected:SELECT SUM("net_weight1") AS "net_weight_converted"FROM (SELECT "product_id", SUM("net_weight") AS "net_weight1" FROM "foodmart"."product" GROUP BY "product_id") AS "t0"Actual:SELECT SUM(SUM("net_weight")) AS "net_weight_converted"FROM "foodmart"."product"GROUP BY "product_id"Returned errors: MySQL 5.1.73 Invalid use of group function MemSQL 5.5.8: [HY000][1111] Invalid use of group function HP Vertica: 7.2.1-0: [42803][2135] [Vertica][VJDBC](2135) ERROR: Aggregate function calls may not be nested java.lang.RuntimeException: com.vertica.support.exceptions.SyntaxErrorException: [Vertica][VJDBC](2135) ERROR: Aggregate function calls may not be nested PostgreSQL 9.6: ERROR: aggregate function calls cannot be nestedTest Case @Test public void testEnginesLackingSupportForNestedAggregationsShouldUseSubSelectInstead() { final String query = "select\n" + " SUM(\"net_weight1\") as \"net_weight_converted\"\n" + " from (" + " select\n" + " SUM(\"net_weight\") as \"net_weight1\"\n" + " from \"foodmart\".\"product\"\n" + " group by \"product_id\")"; final String expectedOracle = "SELECT SUM(SUM(\"net_weight\")) \"net_weight_converted\"\n" + "FROM \"foodmart\".\"product\"\n" + "GROUP BY \"product_id\""; final String expectedMySQL = "SELECT SUM(`net_weight1`) AS `net_weight_converted`\n" + "FROM (SELECT `product_id`, SUM(`net_weight`) AS `net_weight1`\n" + "FROM `foodmart`.`product`\n" + "GROUP BY `product_id`) AS `t0`"; final String expectedVertica = "SELECT SUM(\"net_weight1\") AS \"net_weight_converted\"\n" + "FROM (SELECT \"product_id\", SUM(\"net_weight\") AS \"net_weight1\"\n" + "FROM \"foodmart\".\"product\"\n" + "GROUP BY \"product_id\") AS \"t0\""; final String expectedPostgresql = "SELECT SUM(\"net_weight1\") AS \"net_weight_converted\"\n" + "FROM (SELECT \"product_id\", SUM(\"net_weight\") AS \"net_weight1\"\n" + "FROM \"foodmart\".\"product\"\n" + "GROUP BY \"product_id\") AS \"t0\""; sql(query) .dialect(DatabaseProduct.ORACLE.getDialect()) .ok(expectedOracle) .dialect(DatabaseProduct.MYSQL.getDialect()) .ok(expectedMySQL) .dialect(DatabaseProduct.VERTICA.getDialect()) .ok(expectedVertica) .dialect(DatabaseProduct.POSTGRESQL.getDialect()) .ok(expectedPostgresql); }</description>
      <version>1.13.0</version>
      <fixedVersion>1.15.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.rel.rel2sql.RelToSqlConverterTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlDialect.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.rel2sql.SqlImplementor.java</file>
    </fixedFiles>
  </bug>
  <bug id="1947" opendate="2017-8-16 00:00:00" fixdate="2017-9-16 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Add time/timestamp with local time zone types to optimizer</summary>
      <description>Implementation would be similar to PostgreSQL (the time/timestamp with timezone types do not store the timezone) and conversion from/to timezone-less types follows similar semantics.https://www.postgresql.org/docs/9.6/static/functions-datetime.htmlThis would also allow us to integrate easily with Hive and Druid, which follow similar storage models/semantics for timestamp with timezone.Follow-up work will be needed to introduce these new types in Avatica and extend Calcite SQL parser.</description>
      <version>None</version>
      <fixedVersion>1.14.0</fixedVersion>
      <type>New Feature</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site..docs.reference.md</file>
      <file type="M">druid.src.test.java.org.apache.calcite.test.DruidDateRangeRulesTest.java</file>
      <file type="M">druid.src.test.java.org.apache.calcite.test.DruidAdapterIT.java</file>
      <file type="M">druid.src.test.java.org.apache.calcite.adapter.druid.DruidQueryFilterTest.java</file>
      <file type="M">druid.src.main.java.org.apache.calcite.adapter.druid.TimeExtractionFunction.java</file>
      <file type="M">druid.src.main.java.org.apache.calcite.adapter.druid.TimeExtractionDimensionSpec.java</file>
      <file type="M">druid.src.main.java.org.apache.calcite.adapter.druid.DruidTableFactory.java</file>
      <file type="M">druid.src.main.java.org.apache.calcite.adapter.druid.DruidRules.java</file>
      <file type="M">druid.src.main.java.org.apache.calcite.adapter.druid.DruidQuery.java</file>
      <file type="M">druid.src.main.java.org.apache.calcite.adapter.druid.DruidDateTimeUtils.java</file>
      <file type="M">druid.src.main.java.org.apache.calcite.adapter.druid.DruidConnectionImpl.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RexProgramTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.CalciteAssert.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.jdbc.CalciteRemoteDriverTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.util.TimeString.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.util.TimestampString.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.util.DateString.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.util.BuiltInMethod.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.type.SqlTypeName.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.type.SqlTypeFamily.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.type.SqlTypeAssignmentRules.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlJdbcDataTypeName.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql2rel.StandardConvertletTable.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.schema.Schemas.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.runtime.SqlFunctions.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rex.RexSimplify.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rex.RexLiteral.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rex.RexBuilder.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.type.RelDataTypeSystemImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.rules.SortProjectTransposeRule.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.metadata.RelMdSize.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.jdbc.JavaTypeFactoryImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.enumerable.RexToLixTranslator.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.enumerable.RexImpTable.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rex.RexBuilderTest.java</file>
    </fixedFiles>
  </bug>
  <bug id="1952" opendate="2017-8-17 00:00:00" fixdate="2017-8-17 01:00:00" resolution="Duplicate">
    <buginformation>
      <summary>Apache Calcite 1.13.0 produced null pointer exception compared to 1.12.0</summary>
      <description>Using Apache Calcite on Windows and trying to query the DEPTS.csv used on the website tutorial I get a NullPointerException when using Calcite Core 1.13.0 but when I use 1.12.0 the issue disappears.Properties info = new Properties(); info.put("model", "../src/test/resources/files.json"); info.setProperty("lex", "JAVA"); Connection connection = DriverManager.getConnection("jdbc:calcite:", info); Statement stmt = connection.createStatement(); String sql = "select * from FILES.DEPTS"; ResultSet rs = stmt.executeQuery(sql); while(rs.next()) { System.out.println(rs.getString(1)); }And the exception is as follows:-java.sql.SQLException: Error while executing SQL "select * from FILES.DEPTS": null at org.apache.calcite.avatica.Helper.createException(Helper.java:56) at org.apache.calcite.avatica.Helper.createException(Helper.java:41) at org.apache.calcite.avatica.AvaticaStatement.executeInternal(AvaticaStatement.java:156) at org.apache.calcite.avatica.AvaticaStatement.executeQuery(AvaticaStatement.java:218) at za.co.bb8.CalciteTests.testConnection(CalciteTests.java:24) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)Caused by: java.lang.NullPointerException at org.apache.calcite.plan.volcano.VolcanoPlanner.validate(VolcanoPlanner.java:891) at org.apache.calcite.plan.volcano.VolcanoPlanner.register(VolcanoPlanner.java:866) at org.apache.calcite.plan.volcano.VolcanoPlanner.ensureRegistered(VolcanoPlanner.java:883) at org.apache.calcite.plan.volcano.VolcanoPlanner.ensureRegistered(VolcanoPlanner.java:101) at org.apache.calcite.rel.AbstractRelNode.onRegister(AbstractRelNode.java:336) at org.apache.calcite.plan.volcano.VolcanoPlanner.registerImpl(VolcanoPlanner.java:1496)Below is the files.json{ "version": "1.0", "defaultSchema": "XXX", "schemas": [ { "name": "FILES", "type": "custom", "factory": "org.apache.calcite.adapter.file.FileSchemaFactory", "operand": { "directory": "files" } } ]}</description>
      <version>1.13.0</version>
      <fixedVersion>1.14.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">file.src.test.java.org.apache.calcite.adapter.file.FileReaderTest.java</file>
    </fixedFiles>
  </bug>
  <bug id="1954" opendate="2017-8-17 00:00:00" fixdate="2017-8-17 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>SqlValidator need to maintain forceNullable across joins and renaming</summary>
      <description>In the following query below, SqlValidator return rowtype with the second column as NOT NULL. Since this is a left outer join, it should be nullable.select * from (select row_number() over (order by sal) from emp) as emp1(r1) left outer join (select dense_rank() over(order by sal) from emp) as emp2(r2) on (emp1.r1 = emp2.r2)</description>
      <version>None</version>
      <fixedVersion>1.14.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlValidatorTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlValidatorImpl.java</file>
    </fixedFiles>
  </bug>
  <bug id="1984" opendate="2017-9-13 00:00:00" fixdate="2017-11-13 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Incorrect rewriting with materialized views using DISTINCT in aggregate functions</summary>
      <description>I had written a test as follows . It runs to succeed . But , the result seems not right . The “count distinct” aggregation should not be changed to “count”.@Test public void testAggregateMaterializationOnCountDistinctQuery1() { checkMaterialize( "select \"deptno\", \"empid\" ,\"salary\"\n" + "from \"emps\" group by \"deptno\", \"empid\",\"salary\"", "select \"deptno\", count( distinct \"empid\")" + "from (select \"deptno\", \"empid\" \n" + "from \"emps\" group by \"deptno\", \"empid\") group by \"deptno\"", HR_FKUK_MODEL, CalciteAssert.checkResultContains( "EnumerableAggregate(group=[{0}], S=[COUNT($1)])\n" + " EnumerableTableScan(table=[[hr, m0]]")); }</description>
      <version>1.13.0</version>
      <fixedVersion>1.15.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.test.MaterializationTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.rules.AbstractMaterializedViewRule.java</file>
    </fixedFiles>
  </bug>
  <bug id="2019" opendate="2017-10-20 00:00:00" fixdate="2017-11-20 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>In Druid adapter, push COUNT(__time) as COUNT(*)</summary>
      <description>Druid Time column is not null by default, thus we can transform select count(__time) from table to select count(*) from table</description>
      <version>None</version>
      <fixedVersion>1.15.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">druid.src.test.java.org.apache.calcite.test.DruidAdapterIT.java</file>
      <file type="M">druid.src.main.java.org.apache.calcite.adapter.druid.DruidTable.java</file>
    </fixedFiles>
  </bug>
  <bug id="2020" opendate="2017-10-23 00:00:00" fixdate="2017-3-23 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Upgrade org.incava java-diff</summary>
      <description>Upgrade org.incava java-diff from 1.1 to 1.1.1.The license changed from 2-clause BSD to Apache. The package changed from org.incava.util.diff to org.incava.diff.The code is on github at https://github.com/jpace/java-diff.</description>
      <version>None</version>
      <fixedVersion>1.16.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">pom.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.DiffTestCase.java</file>
    </fixedFiles>
  </bug>
  <bug id="2027" opendate="2017-11-1 00:00:00" fixdate="2017-3-1 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Drop support for Java 7 (JDK 1.7)</summary>
      <description>Drop support for Java 7 (also known as JDK 1.7): The code would no longer compile under JDK 7 Compiler would have source 1.8 target 1.8 Class files would run on JDK 8 and higher Developers can use Java 8 syntax such as lambdas and default methodsWe would continue to build and run under JDK 8 and 9.I think it would be best to wait a while before converting existing code to Java 8 style (e.g. converting SAM anonymous classes to lambdas) because code changes might be extensive.I expect there will be cases that we want to change interfaces so that they are easier to use as lambdas. Let's make those changes cautiously when we come across them, and mark existing interfaces and methods deprecated until we remove them in 2.0.Let's give at least one release notice of this change. In 1.15 (the next release) let's announce that this will be the last release that supports Java 7. So this will be fixed for 1.16.</description>
      <version>None</version>
      <fixedVersion>1.16.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site..docs.howto.md</file>
      <file type="M">site.develop.index.md</file>
      <file type="M">pom.xml</file>
      <file type="M">mongodb.src.main.java.org.apache.calcite.adapter.mongodb.MongoEnumerator.java</file>
      <file type="M">.travis.yml</file>
    </fixedFiles>
  </bug>
  <bug id="2049" opendate="2017-11-14 00:00:00" fixdate="2017-12-14 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Release Calcite 1.15.0</summary>
      <description>Release Calcite 1.15.0.Target date for RC and vote is Nov 27th (just after Thanksgiving), with release date possibly first week of December. I volunteer to be release manager.</description>
      <version>None</version>
      <fixedVersion>1.15.0</fixedVersion>
      <type>Task</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site..docs.index.md</file>
      <file type="M">site..docs.howto.md</file>
      <file type="M">site..docs.history.md</file>
      <file type="M">site.develop.index.md</file>
      <file type="M">README</file>
      <file type="M">pom.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelMetadataTest.java</file>
    </fixedFiles>
  </bug>
  <bug id="2050" opendate="2017-11-14 00:00:00" fixdate="2017-11-14 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Exception when pushing postaggregates into Druid</summary>
      <description>After Calcite is upgraded to 1.14 and the rule to push post-aggregations to Druid is enabled, the following query will fail:EXPLAINSELECT language, robot, sum(added) - sum(delta) AS aFROM druid_table_1WHERE extract (week from `__time`) IN (10,11) AND robot='Bird Call'GROUP BY language, robot;The error we get is the following:Cannot add expression of different type to set:set type is RecordType(VARCHAR(2147483647) CHARACTER SET "UTF-16LE" COLLATE "ISO-8859-1$en_US$primary" language, VARCHAR(2147483647) CHARACTER SET "UTF-16LE" COLLATE "ISO-8859-1$en_US$primary" robot, DOUBLE a) NOT NULLexpression type is RecordType(VARCHAR(2147483647) CHARACTER SET "UTF-16LE" COLLATE "ISO-8859-1$en_US$primary" language, DOUBLE postagg#0) NOT NULLset is rel#1507:HiveProject.HIVE.[](input=HepRelVertex#1514,language=$0,robot=CAST(_UTF-16LE'Bird Call'):VARCHAR(2147483647) CHARACTER SET "UTF-16LE" COLLATE "ISO-8859-1$en_US$primary",a=-($1, $2))expression is DruidQuery#1516</description>
      <version>None</version>
      <fixedVersion>1.15.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">druid.src.test.java.org.apache.calcite.test.DruidAdapterIT.java</file>
      <file type="M">druid.src.main.java.org.apache.calcite.adapter.druid.DruidRules.java</file>
    </fixedFiles>
  </bug>
  <bug id="2052" opendate="2017-11-15 00:00:00" fixdate="2017-11-15 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Remove SQL code style from MV documentation</summary>
      <description>As it is not rendered properly in website.</description>
      <version>None</version>
      <fixedVersion>1.15.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site..docs.materialized.views.md</file>
    </fixedFiles>
  </bug>
  <bug id="2071" opendate="2017-11-29 00:00:00" fixdate="2017-12-29 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Query with IN and OR in WHERE clause returns wrong result</summary>
      <description>Query in this test returns the wrong result (it returns empty result): @Test @Ignore public void testWhereInOr() throws Exception { CalciteAssert.hr() .query("select \"empid\"\n" + "from \"hr\".\"emps\" t\n" + " where (\"empid\" in (select \"empid\" from \"hr\".\"emps\") \n" + " or \"empid\" in (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, " + " 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25) )\n" + " and \"empid\" in (100, 200, 150)") .returns("empid=100\n" + "empid=200\n" + "empid=150\n"); }Without condition in or operator\"empid\" in (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25) it returns the right result.</description>
      <version>None</version>
      <fixedVersion>1.16.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.sql.sub-query.iq</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.JdbcTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql2rel.SqlToRelConverter.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.metadata.RelMdCollation.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.plan.RelOptUtil.java</file>
    </fixedFiles>
  </bug>
  <bug id="2178" opendate="2018-2-14 00:00:00" fixdate="2018-2-14 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Extend expression simplifier to work on datetime CEIL/FLOOR functions</summary>
      <description>Extend expression simplifier to support:FLOOR(FLOOR(CAST( '2010-01-10 00:00:00' AS TIMESTAMP) TO HOUR) TO DAY) =&gt; FLOOR(CAST( '2010-01-10 00:00:00' AS TIMESTAMP) TO DAY)</description>
      <version>None</version>
      <fixedVersion>1.16.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.test.RexImplicationCheckerTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rex.RexSimplify.java</file>
    </fixedFiles>
  </bug>
  <bug id="2180" opendate="2018-2-15 00:00:00" fixdate="2018-2-15 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Invalid code generated for negative of byte and short values</summary>
      <description>Invalid code is generated for negative of byte and short values. The reason is that, in Java, if b is a value of type byte, then -b has type int; similarly if b has type short. The code generator needs to accommodate for this.The query select -deptno from dept demonstrates the problem, since deptno has SQL type TINYINT.</description>
      <version>None</version>
      <fixedVersion>1.16.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">linq4j.src.test.java.org.apache.calcite.linq4j.test.ExpressionTest.java</file>
      <file type="M">linq4j.src.main.java.org.apache.calcite.linq4j.tree.Expressions.java</file>
      <file type="M">core.src.test.resources.sql.misc.iq</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.enumerable.RexImpTable.java</file>
    </fixedFiles>
  </bug>
  <bug id="2181" opendate="2018-2-16 00:00:00" fixdate="2018-4-16 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Release Calcite 1.16.0</summary>
      <description>Release Calcite 1.16.0</description>
      <version>None</version>
      <fixedVersion>1.16.0</fixedVersion>
      <type>Task</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site..docs.howto.md</file>
      <file type="M">site..docs.history.md</file>
      <file type="M">README</file>
      <file type="M">pom.xml</file>
      <file type="M">NOTICE</file>
    </fixedFiles>
  </bug>
  <bug id="2878" opendate="2019-2-27 00:00:00" fixdate="2019-2-27 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Avoid use of new RuntimeException(e) in tests</summary>
      <description>new RuntimeException(e) adds very little info in tests, and it makes stacktraces harder to read.So it makes sense to just sneaky-throw in those cases, especially for test purposes</description>
      <version>None</version>
      <fixedVersion>1.19.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">splunk.src.test.java.org.apache.calcite.test.SplunkAdapterTest.java</file>
      <file type="M">plus.src.test.java.org.apache.calcite.adapter.os.OsAdapterTest.java</file>
      <file type="M">pig.src.test.java.org.apache.calcite.test.PigRelBuilderStyleTest.java</file>
      <file type="M">piglet.src.test.java.org.apache.calcite.test.CalciteHandler.java</file>
      <file type="M">piglet.pom.xml</file>
      <file type="M">mongodb.src.test.java.org.apache.calcite.test.MongoAssertions.java</file>
      <file type="M">mongodb.src.test.java.org.apache.calcite.adapter.mongodb.MongoAdapterTest.java</file>
      <file type="M">file.src.test.java.org.apache.calcite.adapter.file.SqlTest.java</file>
      <file type="M">example.csv.src.test.java.org.apache.calcite.test.CsvTest.java</file>
      <file type="M">example.csv.pom.xml</file>
      <file type="M">elasticsearch.src.test.java.org.apache.calcite.adapter.elasticsearch.Projection2Test.java</file>
      <file type="M">elasticsearch.src.test.java.org.apache.calcite.adapter.elasticsearch.EmbeddedElasticsearchNode.java</file>
      <file type="M">elasticsearch.src.test.java.org.apache.calcite.adapter.elasticsearch.ElasticSearchAdapterTest.java</file>
      <file type="M">druid.src.test.java.org.apache.calcite.test.DruidAdapterIT2.java</file>
      <file type="M">druid.src.test.java.org.apache.calcite.test.DruidAdapterIT.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.TestUtil.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.tools.FrameworksTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.TableFunctionTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.StreamTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlToRelTestBase.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlToRelConverterExtendedTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlTestGen.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelMetadataTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.ReflectiveSchemaTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.Matchers.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.LatticeTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.JdbcTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.JdbcFrontLinqBackTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.JdbcFrontJdbcBackTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.JdbcAdapterTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.DiffTestCase.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.CalciteAssert.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlOperatorBaseTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.AbstractSqlTester.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.parser.SqlParserTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rex.RexSqlStandardConvertletTableTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rel.rel2sql.RelToSqlConverterTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.profile.ProfilerTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.plan.RelWriterTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.jdbc.CalciteRemoteDriverTest.java</file>
    </fixedFiles>
  </bug>
  <bug id="2881" opendate="2019-2-28 00:00:00" fixdate="2019-3-28 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Add the JSON_PRETTY function</summary>
      <description>``` JSON_PRETTY(json_doc) ```Returns the pretty formatted JSON document. Returns `NULL` if any argument is `NULL` or if JSON document is invalid.Example Sql:```sql SELECT JSON_PRETTY(v) AS c1 FROM (VALUES ('{"a": [10, true],"b": [10, true]}')) as t(v) limit 10 ```Result:c1{ "a" : [ 10, true ], "b" : [ 10, true ] }</description>
      <version>None</version>
      <fixedVersion>1.19.0</fixedVersion>
      <type>Sub-task</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site..docs.reference.md</file>
      <file type="M">server.src.main.codegen.config.fmpp</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlValidatorTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlJsonFunctionsTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.JdbcTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlOperatorBaseTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.parser.SqlParserTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rel.rel2sql.RelToSqlConverterTest.java</file>
      <file type="M">core.src.test.codegen.config.fmpp</file>
      <file type="M">core.src.main.resources.org.apache.calcite.runtime.CalciteResource.properties</file>
      <file type="M">core.src.main.java.org.apache.calcite.util.BuiltInMethod.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.fun.SqlStdOperatorTable.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.runtime.SqlFunctions.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.runtime.CalciteResource.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.enumerable.RexImpTable.java</file>
      <file type="M">core.src.main.codegen.templates.Parser.jj</file>
      <file type="M">core.src.main.codegen.config.fmpp</file>
      <file type="M">babel.src.main.codegen.config.fmpp</file>
    </fixedFiles>
  </bug>
</bugrepository>
