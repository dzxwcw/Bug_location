<?xml version="1.0" encoding="UTF-8"?>

<bugrepository name="CALCITE">
  <bug id="2240" opendate="2018-4-5 00:00:00" fixdate="2018-4-5 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Extend rule to push predicates into CASE statement</summary>
      <description>CaseShuttle may make the optimization but the functions return value doesn't depend on that.For the following query the =1 is not pushed into the case.select empno from emp where case when sal &gt; 1000 then empno else sal end = 1</description>
      <version>None</version>
      <fixedVersion>1.17.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.org.apache.calcite.test.RelOptRulesTest.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelOptRulesTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.rules.ReduceExpressionsRule.java</file>
    </fixedFiles>
  </bug>
  <bug id="2291" opendate="2018-5-1 00:00:00" fixdate="2018-6-1 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Add rule to push Project past Correlate</summary>
      <description>Correlate is not derived from Join so we need a rule similar to ProjectJoinTransposeRule to push Project to under Correlate.</description>
      <version>None</version>
      <fixedVersion>1.17.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.org.apache.calcite.test.SqlToRelConverterTest.xml</file>
      <file type="M">core.src.test.resources.org.apache.calcite.test.RelOptRulesTest.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlToRelTestBase.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlToRelConverterTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelOptTestBase.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelOptRulesTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlUnnestOperator.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql2rel.SqlToRelConverter.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.rules.PushProjector.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.core.Uncollect.java</file>
    </fixedFiles>
  </bug>
  <bug id="2303" opendate="2018-5-8 00:00:00" fixdate="2018-6-8 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>In EXTRACT function, support MICROSECONDS, MILLISECONDS, EPOCH, ISODOW, ISOYEAR and DECADE time units</summary>
      <description>Here CALCITE-1177 were supported new units however such test @Test public void testDecadeFunction() throws Exception { ExpressionChecker checker = new ExpressionChecker() .addExpr("EXTRACT(DECADE FROM ts)", 199L) ; checker.buildRunAndCheck(); }failed like Extract for time unit: DECADE not supported!SQL:&gt;SELECT EXTRACT(DECADE FROM ts) FROM PCOLLECTIONMay 08, 2018 1:34:58 PM org.apache.beam.sdk.extensions.sql.impl.planner.BeamQueryPlanner validateAndConvertINFO: SQL:SELECT EXTRACT(DECADE FROM `PCOLLECTION`.`ts`)FROM `PCOLLECTION` AS `PCOLLECTION`May 08, 2018 1:34:58 PM org.apache.beam.sdk.extensions.sql.impl.planner.BeamQueryPlanner convertToBeamRelINFO: SQLPlan&gt;LogicalProject(EXPR$0=[EXTRACT(FLAG(DECADE), $0)]) BeamIOSourceRel(table=[[PCOLLECTION]])java.lang.RuntimeException: org.apache.beam.sdk.Pipeline$PipelineExecutionException: java.lang.UnsupportedOperationException: Extract for time unit: DECADE not supported! at org.apache.beam.sdk.extensions.sql.integrationtest.BeamSqlBuiltinFunctionsIntegrationTestBase$ExpressionChecker.buildRunAndCheck(BeamSqlBuiltinFunctionsIntegrationTestBase.java:167) at org.apache.beam.sdk.extensions.sql.integrationtest.BeamSqlDateFunctionsIntegrationTest.testDecadeFunction(BeamSqlDateFunctionsIntegrationTest.java:66) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.apache.beam.sdk.testing.TestPipeline$1.evaluate(TestPipeline.java:317) at org.junit.rules.RunRules.evaluate(RunRules.java:20) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)Caused by: org.apache.beam.sdk.Pipeline$PipelineExecutionException: java.lang.UnsupportedOperationException: Extract for time unit: DECADE not supported! at org.apache.beam.runners.direct.DirectRunner$DirectPipelineResult.waitUntilFinish(DirectRunner.java:349) at org.apache.beam.runners.direct.DirectRunner$DirectPipelineResult.waitUntilFinish(DirectRunner.java:319) at org.apache.beam.runners.direct.DirectRunner.run(DirectRunner.java:210) at org.apache.beam.runners.direct.DirectRunner.run(DirectRunner.java:66) at org.apache.beam.sdk.Pipeline.run(Pipeline.java:311) at org.apache.beam.sdk.testing.TestPipeline.run(TestPipeline.java:346) at org.apache.beam.sdk.testing.TestPipeline.run(TestPipeline.java:328) at org.apache.beam.sdk.extensions.sql.integrationtest.BeamSqlBuiltinFunctionsIntegrationTestBase$ExpressionChecker.buildRunAndCheck(BeamSqlBuiltinFunctionsIntegrationTestBase.java:165) ... 25 moreCaused by: java.lang.UnsupportedOperationException: Extract for time unit: DECADE not supported! at org.apache.beam.sdk.extensions.sql.impl.interpreter.operator.date.BeamSqlExtractExpression.evaluate(BeamSqlExtractExpression.java:92) at org.apache.beam.sdk.extensions.sql.impl.interpreter.BeamSqlFnExecutor.execute(BeamSqlFnExecutor.java:505) at org.apache.beam.sdk.extensions.sql.impl.transform.BeamSqlProjectFn.processElement(BeamSqlProjectFn.java:57)I guess here org.apache.calcite.avatica.util.DateTimeUtils#julianExtract should be added something likecase DECADE: return year &gt; 0 ? (year + 9) / 10 : (year - 9) / 10;or do I do something not right?</description>
      <version>None</version>
      <fixedVersion>1.17.0,avatica-1.13.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site..docs.reference.md</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlOperatorBaseTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlIntervalQualifier.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.enumerable.RexImpTable.java</file>
      <file type="M">core.src.main.codegen.templates.Parser.jj</file>
    </fixedFiles>
  </bug>
  <bug id="2304" opendate="2018-5-8 00:00:00" fixdate="2018-7-8 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>In Babel parser, allow Hive-style syntax "LEFT SEMI JOIN"</summary>
      <description>In Babel parser, allow Hive-style syntax "LEFT SEMI JOIN".This case is a fairly modest extension to syntax, and can be used as a template for other changes to the Babel parser.</description>
      <version>None</version>
      <fixedVersion>1.17.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">server.src.main.codegen.config.fmpp</file>
      <file type="M">core.src.test.codegen.config.fmpp</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlValidatorImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlJoin.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.JoinType.java</file>
      <file type="M">core.src.main.codegen.templates.Parser.jj</file>
      <file type="M">core.src.main.codegen.config.fmpp</file>
      <file type="M">babel.src.test.resources.sql.select.iq</file>
      <file type="M">babel.src.main.codegen.includes.parserImpls.ftl</file>
      <file type="M">babel.src.main.codegen.config.fmpp</file>
    </fixedFiles>
  </bug>
  <bug id="2320" opendate="2018-5-21 00:00:00" fixdate="2018-5-21 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>UDF in WHERE expression incorrectly pushed down to jdbc schema</summary>
      <description>Checks whether CHOOSENCUSTOMFUNCTION function is properly computed and not passed to subschema, like jdbcSELECT * FROM SIMPLE_CUSTOMER WHERE email = CHOOSENCUSTOMER();where CHOOSENCUSTOMER is UDF leads to Caused by: java.lang.RuntimeException: while executing SQL [SELECT "FIRSTNAME", "LASTNAME", "EMAIL"&gt; FROM "CUSTOMER"&gt; WHERE "EMAIL" = "CHOOSENCUSTOMER"()]&gt; at org.apache.calcite.runtime.ResultSetEnumerable.enumerator(ResultSetEnumerable.java:153)&gt; at org.apache.calcite.linq4j.AbstractEnumerable.iterator(AbstractEnumerable.java:33)&gt; at org.apache.calcite.avatica.MetaImpl.createCursor(MetaImpl.java:90)&gt; at org.apache.calcite.avatica.AvaticaResultSet.execute(AvaticaResultSet.java:174)&gt; at org.apache.calcite.jdbc.CalciteResultSet.execute(CalciteResultSet.java:67)&gt; at org.apache.calcite.jdbc.CalciteResultSet.execute(CalciteResultSet.java:44)&gt; at org.apache.calcite.avatica.AvaticaConnection$1.execute(AvaticaConnection.java:630)&gt; at org.apache.calcite.jdbc.CalciteMetaImpl.prepareAndExecute(CalciteMetaImpl.java:619)&gt; at org.apache.calcite.avatica.AvaticaConnection.prepareAndExecuteInternal(AvaticaConnection.java:638)&gt; at org.apache.calcite.avatica.AvaticaStatement.executeInternal(AvaticaStatement.java:149)&gt; ... 24 more&gt; Caused by: java.sql.SQLSyntaxErrorException: user lacks privilege or object not found: CHOOSENCUSTOMER&gt; at org.hsqldb.jdbc.JDBCUtil.sqlException(Unknown Source)&gt; at org.hsqldb.jdbc.JDBCUtil.sqlException(Unknown Source)&gt; at org.hsqldb.jdbc.JDBCStatement.fetchResult(Unknown Source)&gt; at org.hsqldb.jdbc.JDBCStatement.execute(Unknown Source)&gt; at org.apache.commons.dbcp.DelegatingStatement.execute(DelegatingStatement.java:264)&gt; at org.apache.commons.dbcp.DelegatingStatement.execute(DelegatingStatement.java:264)&gt; at org.apache.calcite.runtime.ResultSetEnumerable.enumerator(ResultSetEnumerable.java:143)&gt; ... 33 more&gt; Caused by: org.hsqldb.HsqlException: user lacks privilege or object not found: CHOOSENCUSTOMER&gt; at org.hsqldb.error.Error.error(Unknown Source)&gt; at org.hsqldb.error.Error.error(Unknown Source)&gt; at org.hsqldb.Routine.getMethods(Unknown Source)&gt; at org.hsqldb.Routine.createRoutines(Unknown Source)&gt; at org.hsqldb.ParserDQL.readColumnOrFunctionExpression(Unknown Source)&gt; at org.hsqldb.ParserDQL.XreadSimpleValueExpressionPrimary(Unknown Source)&gt; at org.hsqldb.ParserDQL.XreadAllTypesValueExpressionPrimary(Unknown Source)&gt; at org.hsqldb.ParserDQL.XreadAllTypesPrimary(Unknown Source)&gt; at org.hsqldb.ParserDQL.XreadAllTypesFactor(Unknown Source)&gt; at org.hsqldb.ParserDQL.XreadAllTypesTerm(Unknown Source)&gt; at org.hsqldb.ParserDQL.XreadAllTypesCommonValueExpression(Unknown Source)&gt; at org.hsqldb.ParserDQL.XreadRowOrCommonValueExpression(Unknown Source)&gt; at org.hsqldb.ParserDQL.XreadRowValuePredicand(Unknown Source)&gt; at org.hsqldb.ParserDQL.XreadPredicateRightPart(Unknown Source)&gt; at org.hsqldb.ParserDQL.XreadBooleanPrimaryOrNull(Unknown Source)</description>
      <version>1.16.0,1.17.0</version>
      <fixedVersion>1.17.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">plus.src.test.resources.sql.functions.iq</file>
      <file type="M">plus.src.main.resources.chinook.chinook.json</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.jdbc.JdbcRules.java</file>
    </fixedFiles>
  </bug>
  <bug id="2327" opendate="2018-5-25 00:00:00" fixdate="2018-8-25 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>In 3 valued logic mode (b and not b) may not be simplified to false</summary>
      <description>currently its simplified to false; but that is not correct when a is unknown</description>
      <version>None</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.test.RexProgramTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rex.RexSimplify.java</file>
    </fixedFiles>
  </bug>
  <bug id="2334" opendate="2018-5-29 00:00:00" fixdate="2018-5-29 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Extend simplification of expressions with CEIL function over date types</summary>
      <description>CALCITE-2332 disables simplification of CEIL function due to correctness issues.We need new logic to enable simplification of CEIL function on date types.</description>
      <version>1.17.0</version>
      <fixedVersion>1.17.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.test.RexImplicationCheckerTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rex.RexSimplify.java</file>
    </fixedFiles>
  </bug>
  <bug id="2338" opendate="2018-5-30 00:00:00" fixdate="2018-3-30 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Make Simplification API more conservative</summary>
      <description>Currently many lower level simplification methods are visible.While I was porting CALCITE-2247 to a branch near 1.16 I've bumped into an issue because of the fact that by calling a specific simplify method may leave out some otherwise applicable simplifications.For master there is already an extra safety feature by the presence of CALCITE-2205; it seems like using less entry points may even lead to better simplifications - by changing this; a filter have been removed.https://github.com/kgyrtkirk/calcite/commit/2e29a659792f6bd9419dc0f97bf5a3bdd9f6f2cc</description>
      <version>None</version>
      <fixedVersion>1.19.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.org.apache.calcite.test.RelOptRulesTest.xml</file>
      <file type="M">core.src.main.java.org.apache.calcite.tools.RelBuilder.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rex.RexUtil.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rex.RexSimplify.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.metadata.RelMdPredicates.java</file>
    </fixedFiles>
  </bug>
  <bug id="2345" opendate="2018-5-31 00:00:00" fixdate="2018-5-31 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>add tests using Fongo to Mongo Adapter</summary>
      <description>Better test coverage for unit tests using Fongo which is in-memory implementation of Mongo API.</description>
      <version>None</version>
      <fixedVersion>1.17.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">mongodb.src.test.resources.mongo-zips-model.json</file>
      <file type="M">mongodb.src.test.resources.mongo-foodmart-model.json</file>
      <file type="M">mongodb.src.test.resources.zips-mini.json</file>
      <file type="M">mongodb.src.test.java.org.apache.calcite.test.MongoAdapterIT.java</file>
      <file type="M">mongodb.src.test.java.org.apache.calcite.adapter.mongodb.MongoDatabaseRule.java</file>
      <file type="M">mongodb.src.test.java.org.apache.calcite.adapter.mongodb.MongoAdapterTest.java</file>
      <file type="M">elasticsearch5.src.test.resources.zips-mini.json</file>
      <file type="M">elasticsearch5.src.test.resources.log4j2.xml</file>
      <file type="M">elasticsearch5.src.test.java.org.apache.calcite.adapter.elasticsearch5.EmbeddedElasticsearchNode.java</file>
      <file type="M">elasticsearch5.src.test.java.org.apache.calcite.adapter.elasticsearch5.ElasticSearch5AdapterTest.java</file>
      <file type="M">elasticsearch2.src.test.resources.zips-mini.json</file>
      <file type="M">elasticsearch2.src.test.java.org.apache.calcite.test.ElasticChecker.java</file>
      <file type="M">elasticsearch2.src.test.java.org.apache.calcite.adapter.elasticsearch2.EmbeddedElasticRule.java</file>
      <file type="M">elasticsearch2.src.test.java.org.apache.calcite.adapter.elasticsearch2.EmbeddedElasticNode.java</file>
      <file type="M">elasticsearch2.src.test.java.org.apache.calcite.adapter.elasticsearch2.ElasticSearch2AdapterTest.java</file>
      <file type="M">elasticsearch2.src.main.java.org.apache.calcite.adapter.elasticsearch2.Elasticsearch2Enumerator.java</file>
      <file type="M">druid.src.test.java.org.apache.calcite.test.DruidAdapterIT2.java</file>
      <file type="M">druid.src.test.java.org.apache.calcite.test.DruidAdapterIT.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.UtilTest.java</file>
      <file type="M">pom.xml</file>
      <file type="M">mongodb.src.main.java.org.apache.calcite.adapter.mongodb.MongoSchema.java</file>
      <file type="M">mongodb.pom.xml</file>
    </fixedFiles>
  </bug>
  <bug id="2387" opendate="2018-6-28 00:00:00" fixdate="2018-6-28 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Date/timestamp cast expressions in Druid adapter may use wrong timezone</summary>
      <description>Follow-up for CALCITE-2286. Timezone should be set correctly by Druid when there is a cast for timestamp type vs timestamp with local time zone.</description>
      <version>1.17.0</version>
      <fixedVersion>1.17.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">druid.src.test.java.org.apache.calcite.test.DruidAdapterIT2.java</file>
      <file type="M">druid.src.main.java.org.apache.calcite.adapter.druid.DruidSqlCastConverter.java</file>
    </fixedFiles>
  </bug>
  <bug id="2388" opendate="2018-6-29 00:00:00" fixdate="2018-6-29 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Upgrade to dbcp2 version 2.4.0</summary>
      <description>Upgrade from apache commons-dbcp 1.4 to commons-dbcp2 2.4.0.</description>
      <version>None</version>
      <fixedVersion>1.17.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">pom.xml</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.jdbc.JdbcUtils.java</file>
      <file type="M">core.pom.xml</file>
    </fixedFiles>
  </bug>
  <bug id="2405" opendate="2018-7-9 00:00:00" fixdate="2018-11-9 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>In Babel parser: allow to use some reserved keyword as identifier</summary>
      <description>I have some case of incompatibility between MySQL (actually on HerdDB which is a replacement for MySQL) and Calcite around reserved identifiers. Allow a schema with name 'default' Allow a column name with name 'value'  </description>
      <version>1.17.0</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>New Feature</type>
    </buginformation>
    <fixedFiles>
      <file type="M">server.src.main.codegen.config.fmpp</file>
      <file type="M">pom.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.parser.SqlParserTest.java</file>
      <file type="M">core.src.test.codegen.config.fmpp</file>
      <file type="M">core.src.main.java.org.apache.calcite.prepare.PlannerImpl.java</file>
      <file type="M">core.src.main.codegen.templates.Parser.jj</file>
      <file type="M">core.src.main.codegen.config.fmpp</file>
      <file type="M">babel.src.test.java.org.apache.calcite.test.BabelParserTest.java</file>
      <file type="M">babel.src.main.codegen.config.fmpp</file>
    </fixedFiles>
  </bug>
  <bug id="2416" opendate="2018-7-16 00:00:00" fixdate="2018-8-16 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Assertion error when determining monotonicity</summary>
      <description>CREATE TABLE test ( x integer, y integer);SELECT 2 * 2 * x FROM test; Causes:Exception in thread "main" java.lang.AssertionError: Internal error: invalid literal: 2 * 2 Re-raising CALCITE-1504 which was fixed via CALCITE-1486</description>
      <version>1.15.0,1.16.0,1.17.0</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlOperatorBaseTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlLiteral.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.fun.SqlMonotonicBinaryOperator.java</file>
    </fixedFiles>
  </bug>
  <bug id="2442" opendate="2018-8-3 00:00:00" fixdate="2018-2-3 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Cassandra unit test intermittent failures</summary>
      <description>We have noticed that there are failures due to : Wrong parsing of new JDK version scheme (by calcite and cassandra dependencies like jamm). 10-ea vs 10.0.2 Cassandra startup timeout on Linux Jenkins CI server. Contrary to github travis CI (the one which validates PRs), it takes about 20s for embedded cassandra to start (still under investigation). Sergey Nuyanzin reported that CassandraUnit leaves .toDelete folder in maven module folder (cassandra/) rather than target/ where all build and temporary files should be located. Not a failure but annoyance.</description>
      <version>None</version>
      <fixedVersion>1.22.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">cassandra.src.test.resources.logback-test.xml</file>
      <file type="M">cassandra.src.test.java.org.apache.calcite.test.CassandraAdapterTest.java</file>
      <file type="M">cassandra.src.test.java.org.apache.calcite.test.CassandraAdapterDataTypesTest.java</file>
      <file type="M">cassandra.src.test.java.org.apache.calcite.test.AbstractCassandraAdapterTest.java</file>
      <file type="M">cassandra.gradle.properties</file>
    </fixedFiles>
  </bug>
  <bug id="2450" opendate="2018-8-7 00:00:00" fixdate="2018-1-7 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>RexSimplify: reorder predicates to a canonical form as a part of RexSimplify</summary>
      <description>Certain optimizations are easier to perform when input expressions are in a canonical form.For instance: more duplicates can be found in AND/OR lists, case branches, etc.Note: this reordering is supposed to happen in RexSimplify only. In other words, RexBuilder would still produce "non-canonical" expressions.It is expected that RexSimplify might alter the expression, so if it converts 5=x to x=5 it should be just fine.The suggested rules are to be discussed, yet the following might be fine:1) For AND, OR, IN: put "simpler" nodes first. The weight of a node could be either .toString().length() or a number of child nodes or something like that.The motivation is to simplify logic that handles "duplicate" entries. It won't have to consider "both alternatives" all over the place.2) For comparison with literals put literal as the second argument3) For binary comparison, put node with less weight to the left</description>
      <version>1.17.0</version>
      <fixedVersion>1.22.0</fixedVersion>
      <type>Sub-task</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.tools.PlannerTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.tools.FrameworksTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RexTransformerTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelMetadataTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.MaterializationTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rex.RexProgramTestBase.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rex.RexProgramTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rex.RexProgramBuilderBase.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rel.rules.DateRangeRulesTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.materialize.LatticeSuggesterTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlKind.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rex.RexNode.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rex.RexCall.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.RelWriter.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.externalize.RelWriterImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.externalize.RelJsonWriter.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.config.CalciteSystemProperty.java</file>
    </fixedFiles>
  </bug>
  <bug id="2457" opendate="2018-8-8 00:00:00" fixdate="2018-11-8 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Upgrade to JUnit 5</summary>
      <description>JUnit 5 brings multiple useful features so tests are easier to read and write.Is there something that blocks upgrading to JUnit 5?By upgrade I mean bumping up the dependency version and creating new tests with JUnit 5 features.Relevant features of JUnit 5: dynamic test, nested tests, parameterized testshttps://twitter.com/nipafx/status/1027095088059559936</description>
      <version>None</version>
      <fixedVersion>1.22.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.AbstractSqlTester.java</file>
      <file type="M">plus.src.test.java.org.apache.calcite.test.PlusSuite.java</file>
      <file type="M">file.src.test.java.org.apache.calcite.adapter.file.FileSuite.java</file>
      <file type="M">core.src.test.kotlin.org.apache.calcite.TestKtTest.kt</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.TestUtil.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.CalciteSuite.java</file>
      <file type="M">plus.src.test.java.org.apache.calcite.chinook.EndToEndTest.java</file>
      <file type="M">mongodb.gradle.properties</file>
      <file type="M">linq4j.gradle.properties</file>
      <file type="M">geode.gradle.properties</file>
      <file type="M">elasticsearch.gradle.properties</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.CoreQuidemTest.java</file>
      <file type="M">core.build.gradle.kts</file>
      <file type="M">cassandra.gradle.properties</file>
      <file type="M">splunk.src.test.java.org.apache.calcite.test.SplunkAdapterTest.java</file>
      <file type="M">spark.src.test.java.org.apache.calcite.test.SparkAdapterTest.java</file>
      <file type="M">server.src.test.java.org.apache.calcite.test.ServerTest.java</file>
      <file type="M">server.src.test.java.org.apache.calcite.test.ServerQuidemTest.java</file>
      <file type="M">server.src.test.java.org.apache.calcite.test.ServerParserTest.java</file>
      <file type="M">plus.src.test.java.org.apache.calcite.materialize.TpcdsLatticeSuggesterTest.java</file>
      <file type="M">plus.src.test.java.org.apache.calcite.chinook.RemotePreparedStatementParametersTest.java</file>
      <file type="M">plus.src.test.java.org.apache.calcite.adapter.tpch.TpchTest.java</file>
      <file type="M">plus.src.test.java.org.apache.calcite.adapter.tpcds.TpcdsTest.java</file>
      <file type="M">plus.src.test.java.org.apache.calcite.adapter.os.OsAdapterTest.java</file>
      <file type="M">pig.src.test.java.org.apache.calcite.test.PigRelBuilderStyleTest.java</file>
      <file type="M">pig.src.test.java.org.apache.calcite.test.PigAdapterTest.java</file>
      <file type="M">piglet.src.test.java.org.apache.calcite.test.PigScriptTest.java</file>
      <file type="M">piglet.src.test.java.org.apache.calcite.test.PigRelTestBase.java</file>
      <file type="M">piglet.src.test.java.org.apache.calcite.test.PigRelOpTest.java</file>
      <file type="M">piglet.src.test.java.org.apache.calcite.test.PigRelExTest.java</file>
      <file type="M">piglet.src.test.java.org.apache.calcite.test.PigletTest.java</file>
      <file type="M">piglet.src.test.java.org.apache.calcite.test.Fluent.java</file>
      <file type="M">mongodb.src.test.java.org.apache.calcite.test.MongoAssertions.java</file>
      <file type="M">mongodb.src.test.java.org.apache.calcite.adapter.mongodb.MongoAdapterTest.java</file>
      <file type="M">linq4j.src.test.java.org.apache.calcite.linq4j.tree.TypeTest.java</file>
      <file type="M">linq4j.src.test.java.org.apache.calcite.linq4j.test.PrimitiveTest.java</file>
      <file type="M">linq4j.src.test.java.org.apache.calcite.linq4j.test.OptimizerTest.java</file>
      <file type="M">linq4j.src.test.java.org.apache.calcite.linq4j.test.LookupImplTest.java</file>
      <file type="M">linq4j.src.test.java.org.apache.calcite.linq4j.test.Linq4jTest.java</file>
      <file type="M">linq4j.src.test.java.org.apache.calcite.linq4j.test.JoinPreserveOrderTest.java</file>
      <file type="M">linq4j.src.test.java.org.apache.calcite.linq4j.test.InlinerTest.java</file>
      <file type="M">linq4j.src.test.java.org.apache.calcite.linq4j.test.ExpressionTest.java</file>
      <file type="M">linq4j.src.test.java.org.apache.calcite.linq4j.test.DeterministicTest.java</file>
      <file type="M">linq4j.src.test.java.org.apache.calcite.linq4j.test.CorrelateJoinTest.java</file>
      <file type="M">linq4j.src.test.java.org.apache.calcite.linq4j.test.BlockBuilderTest.java</file>
      <file type="M">linq4j.src.test.java.org.apache.calcite.linq4j.MemoryEnumerableTest.java</file>
      <file type="M">linq4j.src.test.java.org.apache.calcite.linq4j.function.FunctionTest.java</file>
      <file type="M">kafka.src.test.java.org.apache.calcite.adapter.kafka.KafkaAdapterTest.java</file>
      <file type="M">geode.src.test.java.org.apache.calcite.adapter.geode.rel.GeodeAssertions.java</file>
      <file type="M">file.src.test.java.org.apache.calcite.adapter.file.SqlTest.java</file>
      <file type="M">file.src.test.java.org.apache.calcite.adapter.file.FileReaderTest.java</file>
      <file type="M">example.function.src.test.java.org.apache.calcite.test.ExampleFunctionTest.java</file>
      <file type="M">example.csv.src.test.java.org.apache.calcite.test.CsvTest.java</file>
      <file type="M">elasticsearch.src.test.java.org.apache.calcite.test.ElasticsearchChecker.java</file>
      <file type="M">elasticsearch.src.test.java.org.apache.calcite.adapter.elasticsearch.QueryBuildersTest.java</file>
      <file type="M">elasticsearch.src.test.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchVersionTest.java</file>
      <file type="M">elasticsearch.src.test.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchJsonTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.UtilTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.TestUtilTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.SourceTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.Smalls.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.ReflectVisitorTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.PrecedenceClimbingParserTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.PermutationTestCase.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.PartiallyOrderedSetTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.mapping.MappingTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.ImmutableBitSetTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.graph.DirectedGraphTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.ChunkListTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.BitSetsTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.tools.PlannerTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.tools.FrameworksTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.UdtTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.UdfTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.TypeCoercionTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.TypeCoercionConverterTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.TableInRootSchemaTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.TableFunctionTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.StreamTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlValidatorTestCase.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlValidatorTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlValidatorMatchTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlValidatorFeatureTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlValidatorDynamicTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlToRelTestBase.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlToRelConverterTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlToRelConverterExtendedTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlStatisticProviderTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlOperatorBindingTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlLineTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlLimitsTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlJsonFunctionsTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlHintsConverterTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlFunctionsTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlAdvisorJdbcTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.ScannableTableTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RexTransformerTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RexShuttleTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RexProgramTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RexImplicationCheckerTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelOptTestBase.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelOptRulesTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelMetadataTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelMdPercentageOriginalRowsTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelMdColumnOriginsTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelBuilderTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.ReflectiveSchemaTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.QuidemTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.PigRelBuilderTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.MutableRelTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.MultiJdbcSchemaJoinTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.ModelTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.MaterializationTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.LinqFrontJdbcBackTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.LatticeTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.JdbcTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.JdbcFrontLinqBackTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.JdbcFrontJdbcBackTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.JdbcFrontJdbcBackLinqMiddleTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.JdbcAdapterTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.InterpreterTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.InduceGroupingTypeTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.HepPlannerTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.fuzzer.RexProgramFuzzyTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.FilteratorTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.ExceptionMessageTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.enumerable.EnumerableRepeatUnionTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.enumerable.EnumerableRepeatUnionHierarchyTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.enumerable.EnumerableJoinTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.enumerable.EnumerableHashJoinTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.enumerable.EnumerableCorrelateTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.enumerable.EnumerableBatchNestedLoopJoinTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.DiffTestCase.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.DiffRepository.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.CollectionTypeTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.CalciteResourceTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.CalciteAssert.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.validate.SqlValidatorUtilTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.validate.LexEscapeTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.validate.LexCaseSensitiveTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.type.SqlTypeUtilTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.type.SqlTypeFactoryTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.type.RelDataTypeSystemTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlTypeNameTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlTests.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlRuntimeTester.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlPrettyWriterTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlOperatorBaseTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlAdvisorTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.DocumentationTest.java</file>
      <file type="M">build.gradle.kts</file>
      <file type="M">core.src.main.java.org.apache.calcite.config.CalciteSystemProperty.java</file>
      <file type="M">druid.build.gradle.kts</file>
      <file type="M">druid.gradle.properties</file>
      <file type="M">druid.src.test.java.org.apache.calcite.adapter.druid.DruidQueryFilterTest.java</file>
      <file type="M">druid.src.test.java.org.apache.calcite.test.DruidAdapter2IT.java</file>
      <file type="M">druid.src.test.java.org.apache.calcite.test.DruidAdapterIT.java</file>
      <file type="M">druid.src.test.java.org.apache.calcite.test.DruidChecker.java</file>
      <file type="M">druid.src.test.java.org.apache.calcite.test.DruidDateRangeRulesTest.java</file>
      <file type="M">gradle.properties</file>
      <file type="M">babel.src.test.java.org.apache.calcite.test.BabelParserTest.java</file>
      <file type="M">babel.src.test.java.org.apache.calcite.test.BabelQuidemTest.java</file>
      <file type="M">babel.src.test.java.org.apache.calcite.test.BabelTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.adapter.clone.ArrayTableTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.adapter.enumerable.EnumUtilsTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.adapter.enumerable.PhysTypeTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.adapter.enumerable.TypeFinderTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.jdbc.CalciteRemoteDriverTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.jdbc.JavaTypeFactoryTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.materialize.LatticeSuggesterTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.plan.RelOptPlanReaderTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.plan.RelOptUtilTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.plan.RelTraitTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.plan.RelWriterTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.plan.volcano.CollationConversionTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.plan.volcano.ComboRuleTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.plan.volcano.TraitConversionTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.plan.volcano.TraitPropagationTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.plan.volcano.VolcanoPlannerTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.plan.volcano.VolcanoPlannerTraitTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.prepare.LookupOperatorOverloadsTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.profile.ProfilerTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rel.logical.ToLogicalConverterTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rel.rel2sql.RelToSqlConverterStructsTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rel.rel2sql.RelToSqlConverterTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rel.RelCollationTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rel.RelDistributionTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rel.rules.DateRangeRulesTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rel.rules.EnumerableLimitRuleTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rel.rules.SortRemoveRuleTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rex.RexBuilderTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rex.RexExecutorTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rex.RexSqlStandardConvertletTableTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.runtime.AutomatonTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.runtime.BinarySearchTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.runtime.DeterministicAutomatonTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.runtime.EnumerablesTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.parser.parserextensiontesting.ExtensionSqlParserTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.parser.SqlParserTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.SqlSetOptionOperatorTest.java</file>
    </fixedFiles>
  </bug>
  <bug id="2458" opendate="2018-8-8 00:00:00" fixdate="2018-9-8 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Evaluate use of Kotlin for unit tests</summary>
      <description>It looks like Kotlin might simplify writing tests: 1) Calcite tests often create expressions (linq4j, rex, sql, etc), and the order of elements is "backwards".For instance, "x AND (y OR z)" becomes and(x, or(y, z)) at best. Writing and updating such code is a bit tedious. It seems like AND and OR could be infix functions (see https://kotlinlang.org/docs/reference/functions.html#infix-notation )2) extension functions Calcite tests often tend to create DSLs for testing (e.g. CalciteAssert, Tester, and so on). The idea there is to enable fluent APIs and somehow tame the complexity. The problem there is Java is not that suitable for building DSLs.Extension methods in Kotlin allow to "add a method to existing class", and it might be helpful for cases like parser.parse("...").assertConvertsTo("...") where assertConvertsTo is an extension method (in Java it could be a static method in CalciteAssert class)3) data classes. Apparently, Calcite deals with data, and data classes could help here as well.4) default parameters5) multiline string literalsI think it would be much better to co-locate SqlToRel test code and its expected results, so one can see the test code and expectations.6) Re Checkstyle: there's a standard code style for Kotlin (and it can be verified automatically), however I am not sure we could configure it in the way we have Checkstyle rules. Calcite uses parenthesis a lot, and I am not sure how Kotlin would deal with it.It looks like adding Kotlin as a &lt;scope&gt;test&lt;/scope&gt; should not be a problem, so I wonder if that is feasible.PS. Using Kotlin for regular Calcite code is a different story, and I am not sure I want to open that discussion (well, I would love to, yet it might be a major change with ripples here and there). I just think it should be safer to try writing some TEST code for Calcite in Kotlin, then evaluate it for other cases (if necessary at all).</description>
      <version>1.17.0</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">pom.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.CalciteSuite.java</file>
      <file type="M">core.pom.xml</file>
    </fixedFiles>
  </bug>
  <bug id="2460" opendate="2018-8-9 00:00:00" fixdate="2018-7-9 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Implement TO_BASE64 and FROM_BASE64 functions</summary>
      <description>refer to mysql TO_BASE64 function : https://dev.mysql.com/doc/refman/5.6/en/string-functions.html#function_to-base64</description>
      <version>None</version>
      <fixedVersion>1.21.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site..docs.reference.md</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlFunctionsTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlOperatorBaseTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.util.BuiltInMethod.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.fun.SqlLibraryOperators.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.runtime.SqlFunctions.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.enumerable.RexImpTable.java</file>
    </fixedFiles>
  </bug>
  <bug id="2475" opendate="2018-8-19 00:00:00" fixdate="2018-9-19 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>SqlAdvisor: support MINUS</summary>
      <description></description>
      <version>1.17.0</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlAdvisorTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.advise.SqlSimpleParser.java</file>
    </fixedFiles>
  </bug>
  <bug id="2476" opendate="2018-8-19 00:00:00" fixdate="2018-9-19 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>SqlAdvisor: lack of hints when sub-query has STAR (simplifySql produces 0 AS "*")</summary>
      <description>SimpleSqlParser.purgeSelectExprsKeepAliases tries to replace expressions in select clause with aliases, and it often produces invalid SQL:select * from dummy is replaced with select 0 AS "*" from dummy which is invalidselect a.x+ b.y from dummy is replaced with select 0 AS "b.y" from dummy and so on.Testcase:select ax^ from (select * from dummy a)Actual output:SELECT ax _suggest_ FROM ( SELECT 0 AS * FROM dummy a )I'm inclined to comment purgeSelectExprsKeepAliases out for now.</description>
      <version>1.17.0</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlAdvisorTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.advise.SqlSimpleParser.java</file>
    </fixedFiles>
  </bug>
  <bug id="2477" opendate="2018-8-19 00:00:00" fixdate="2018-9-19 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>SqlAdvisor: scalar sub-query support</summary>
      <description>select ax^ from (select (select * from dummy) axc from dummy a)After simplify:SELECT ax _suggest_ FROM ( SELECT ( SELECT * FROM dummy ) axc FROM dummy a ) )Note the extra closing brace.TL;DR: consumeQuery assumes axc FROM dummy... is a "union-kind of" continuation of a query started in select *....The solution is keep advancing in consumeQuery only if known tokens are ahead (e.g. union, intersect, ...)</description>
      <version>1.17.0</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlAdvisorTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.advise.SqlSimpleParser.java</file>
    </fixedFiles>
  </bug>
  <bug id="2478" opendate="2018-8-19 00:00:00" fixdate="2018-9-19 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>SqlAdvisor: purge from_clause when _suggest_ token is located in one of the from sub-queries</summary>
      <description>Testcase:select axc from (select (select ^ from dummy) axc from dummy a), dummy bExpected output:SELECT * FROM ( SELECT ( SELECT _suggest_ FROM dummy ) axc FROM dummy a )Actual output:SELECT * FROM ( SELECT ( SELECT _suggest_ FROM dummy ) axc FROM dummy a ) , dummy b</description>
      <version>1.17.0</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlAdvisorTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.advise.SqlSimpleParser.java</file>
    </fixedFiles>
  </bug>
  <bug id="2486" opendate="2018-8-23 00:00:00" fixdate="2018-9-23 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Upgrade Apache parent POM to version 21</summary>
      <description>Apache parent POM 21 has just been released. It generates .sha512 checksums during release with Maven Release Plugin.We should investigate using it for the next release (1.18). Also investigate upgrading Avatica for its next release (1.13).</description>
      <version>None</version>
      <fixedVersion>avatica-1.13.0,1.18.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">pom.xml</file>
      <file type="M">mongodb.pom.xml</file>
      <file type="M">geode.pom.xml</file>
      <file type="M">example.csv.pom.xml</file>
      <file type="M">elasticsearch.pom.xml</file>
    </fixedFiles>
  </bug>
  <bug id="2496" opendate="2018-8-28 00:00:00" fixdate="2018-7-28 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>EXTRACT function: MILLI/MICRO/NANOSECOND parts of a DATE must be zero</summary>
      <description>There was already a similar issue CALCITE-2324 but I'm sorry I did not take into account 3 time units. Now I want to cover them here. So all existing Timeunits from org.apache.calcite.avatica.util.TimeUnit which are less than a day will be covered</description>
      <version>1.17.0</version>
      <fixedVersion>1.21.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlOperatorBaseTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.enumerable.RexImpTable.java</file>
      <file type="M">core.src.main.codegen.templates.Parser.jj</file>
    </fixedFiles>
  </bug>
  <bug id="2497" opendate="2018-8-28 00:00:00" fixdate="2018-8-28 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Update Janino version to 3.0.9</summary>
      <description>Update Janino version to 3.0.9 where was fixed https://github.com/janino-compiler/janino/issues/47, and remove workaround made in CALCITE-2261 because of this issue.</description>
      <version>1.17.0</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Task</type>
    </buginformation>
    <fixedFiles>
      <file type="M">pom.xml</file>
      <file type="M">core.src.main.java.org.apache.calcite.schema.SchemaPlus.java</file>
    </fixedFiles>
  </bug>
  <bug id="2498" opendate="2018-8-28 00:00:00" fixdate="2018-9-28 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>geode adapter wrongly quotes booleans as strings (&amp;#39;true&amp;#39; / &amp;#39;false&amp;#39;)</summary>
      <description>Geode should keep booleans as is (without quoting them).// SQL (calcite). original queryselect * from geode where isActive = true// OQL (geode query) resultselect * from /region where isActive = 'true'  Boolean literals are natively supported by geode and calcite should not convert them to SQL strings.  </description>
      <version>None</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">geode.src.main.java.org.apache.calcite.adapter.geode.rel.GeodeFilter.java</file>
    </fixedFiles>
  </bug>
  <bug id="2504" opendate="2018-8-29 00:00:00" fixdate="2018-9-29 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Add randomized test for better code coverage of rex node create and simplification</summary>
      <description></description>
      <version>1.17.0</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Sub-task</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.test.CalciteSuite.java</file>
    </fixedFiles>
  </bug>
  <bug id="2510" opendate="2018-8-30 00:00:00" fixdate="2018-7-30 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Add CHR built-in function (Oracle only)</summary>
      <description>Adding CHR() function support, available in Oracle &amp; PostgreSqlhttps://docs.oracle.com/cd/B19306_01/server.102/b14200/functions019.htmhttps://www.postgresql.org/docs/9.4/static/functions-string.html </description>
      <version>None</version>
      <fixedVersion>1.21.0</fixedVersion>
      <type>Task</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site..docs.reference.md</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlOperatorBaseTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.type.ReturnTypes.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.fun.SqlLibraryOperators.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.runtime.SqlFunctions.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.enumerable.RexImpTable.java</file>
    </fixedFiles>
  </bug>
  <bug id="2514" opendate="2018-8-31 00:00:00" fixdate="2018-9-31 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Add SqlIdentifier conversion to ITEM operator for dynamic tables in ExtendedExpander</summary>
      <description>SqlIdentifier is not converted to ITEM operator for dynamic tables in ExtendedExpander and thus query returns wrong results. Happens when isGroupByAlias is set to true in SQL conformance.Query example:select n_regionkey, max(min(n_nationkey)) over(partition by n_regionkey)from (select * from SALES.NATION)group by n_regionkeyIncorrect logical plan:LogicalProject(N_REGIONKEY=[ITEM($0, 'N_REGIONKEY')], EXPR$1=[MAX($1) OVER (PARTITION BY ITEM($0, 'N_REGIONKEY') RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)]) LogicalAggregate(group=[{0}], agg#0=[MIN($1)]) LogicalProject(**=[$0], $f1=[ITEM($0, 'N_NATIONKEY')]) LogicalProject(**=[$0]) LogicalTableScan(table=[[CATALOG, SALES, NATION]])Correct logical plan:LogicalProject(N_REGIONKEY=[$0], EXPR$1=[MAX($1) OVER (PARTITION BY $0 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)]) LogicalAggregate(group=[{0}], agg#0=[MIN($1)]) LogicalProject(N_REGIONKEY=[ITEM($0, 'N_REGIONKEY')], $f1=[ITEM($0, 'N_NATIONKEY')]) LogicalProject(**=[$0]) LogicalTableScan(table=[[CATALOG, SALES, NATION]])</description>
      <version>1.17.0</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.org.apache.calcite.test.SqlToRelConverterTest.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlToRelConverterTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlValidatorImpl.java</file>
    </fixedFiles>
  </bug>
  <bug id="2518" opendate="2018-8-31 00:00:00" fixdate="2018-9-31 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Add failOnWarnings to maven-javadoc-plugin configuration</summary>
      <description>It would catch javadoc warnings automatically in CI</description>
      <version>1.17.0</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">pom.xml</file>
      <file type="M">core.src.main.java.org.apache.calcite.util.Bug.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.plan.volcano.RuleQueue.java</file>
    </fixedFiles>
  </bug>
  <bug id="2528" opendate="2018-9-4 00:00:00" fixdate="2018-9-4 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Support Aggregates in ElasticSearch Adapter</summary>
      <description>Translate SQL GROUP BY and aggregate functions sum / min / max into Elastic Terms and Metric aggregations.Examplesselect col1, sum(col2), max(col3) from elastic group by col1select count(*) from elastic</description>
      <version>None</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">elasticsearch.src.test.java.org.apache.calcite.test.ElasticsearchChecker.java</file>
      <file type="M">elasticsearch.src.test.java.org.apache.calcite.adapter.elasticsearch.QueryBuildersTest.java</file>
      <file type="M">elasticsearch.src.test.java.org.apache.calcite.adapter.elasticsearch.ProjectionTest.java</file>
      <file type="M">elasticsearch.src.test.java.org.apache.calcite.adapter.elasticsearch.EmbeddedElasticsearchPolicy.java</file>
      <file type="M">elasticsearch.src.test.java.org.apache.calcite.adapter.elasticsearch.ElasticSearchAdapterTest.java</file>
      <file type="M">elasticsearch.src.test.java.org.apache.calcite.adapter.elasticsearch.BooleanLogicTest.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.QueryBuilders.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.PredicateAnalyzer.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchToEnumerableConverter.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchTableScan.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchTable.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchSort.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchSchema.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchRules.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchRel.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchProject.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchMethod.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchFilter.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchEnumerators.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchConstants.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.AbstractElasticsearchTable.java</file>
      <file type="M">elasticsearch.pom.xml</file>
    </fixedFiles>
  </bug>
  <bug id="2529" opendate="2018-9-4 00:00:00" fixdate="2018-12-4 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>linq4j should promote integer to floating point when generating function calls</summary>
      <description>For example, I get "RuntimeException: while resolving method 'atan2&amp;#91;double, int&amp;#93;'" when trying to execute a query with "ATAN2(c_double, 2)" (where c_double is a column containing the double type). atan2&amp;#91;double, double&amp;#93; should resolve as a valid implementation in this case.</description>
      <version>None</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">linq4j.src.test.java.org.apache.calcite.linq4j.test.PrimitiveTest.java</file>
      <file type="M">linq4j.src.main.java.org.apache.calcite.linq4j.tree.Primitive.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlOperatorBaseTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.runtime.SqlFunctions.java</file>
    </fixedFiles>
  </bug>
  <bug id="2543" opendate="2018-9-9 00:00:00" fixdate="2018-9-9 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Upgrade SQLLine to 1.5.0</summary>
      <description>Upgrade SQLLine to 1.5.0.</description>
      <version>None</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">pom.xml</file>
    </fixedFiles>
  </bug>
  <bug id="2570" opendate="2018-9-19 00:00:00" fixdate="2018-9-19 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Upgrade forbiddenapis to 2.6 for JDK 11 support</summary>
      <description>forbiddenapis 2.6 was released 2 days ago with support for JDK 11</description>
      <version>None</version>
      <fixedVersion>avatica-1.13.0,1.18.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">pom.xml</file>
    </fixedFiles>
  </bug>
  <bug id="2572" opendate="2018-9-19 00:00:00" fixdate="2018-9-19 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>SUBSTRING function fails if start position is less than 1</summary>
      <description>Calcite substring throws a IndexOutOfBoundsException with a position less than 1. Per the SQL standard, the position should be treated as the larger of the provided value and 1, however many implementations treat negative values as starting from the end of the string.Extended standard:https://docs.oracle.com/cd/B19306_01/server.102/b14200/functions162.htmhttps://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_substringhttps://spark.apache.org/docs/2.3.0/api/sql/index.html#substringhttps://www.sqlite.org/lang_corefunc.html#substrFollow the standard:https://docs.microsoft.com/en-us/sql/t-sql/functions/substring-transact-sql?view=sql-server-2017https://www.postgresql.org/docs/9.1/static/functions-string.html</description>
      <version>None</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlOperatorBaseTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.runtime.SqlFunctions.java</file>
    </fixedFiles>
  </bug>
  <bug id="2574" opendate="2018-9-19 00:00:00" fixdate="2018-9-19 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Download pages must include instructions for verifying the integrity of files directly.</summary>
      <description>The announcement for Avatica-Go 3.2.0 was rejected because the download page did not include instructions for verifying the integrity of files. I believe having a link to the documentation is not enough.See Apache Atlas' download page for a valid example: http://atlas.apache.org/Downloads.html</description>
      <version>None</version>
      <fixedVersion>avatica-1.13.0,1.18.0,avatica-go-4.0.0</fixedVersion>
      <type>Task</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site.downloads.index.md</file>
    </fixedFiles>
  </bug>
  <bug id="2575" opendate="2018-9-19 00:00:00" fixdate="2018-12-19 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Release Calcite 1.18.0</summary>
      <description>Release Calcite 1.18.0.</description>
      <version>None</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site..docs.howto.md</file>
      <file type="M">site..docs.history.md</file>
      <file type="M">README</file>
      <file type="M">pom.xml</file>
    </fixedFiles>
  </bug>
  <bug id="2577" opendate="2018-9-19 00:00:00" fixdate="2018-9-19 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Update URLs on download page to HTTPS</summary>
      <description></description>
      <version>None</version>
      <fixedVersion>avatica-1.13.0,1.18.0</fixedVersion>
      <type>Task</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site.downloads.index.md</file>
    </fixedFiles>
  </bug>
  <bug id="2578" opendate="2018-9-20 00:00:00" fixdate="2018-9-20 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Support ANY_VALUE Aggregate Function in ElasticSearch Adapter</summary>
      <description>Sometimes it is useful to return a single value from a multi-set (bucket).SELECT foo, ANY_VALUE(bar) FROM elastic GROUP BY foo</description>
      <version>None</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">elasticsearch.src.test.java.org.apache.calcite.adapter.elasticsearch.AggregationTest.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchTable.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchProject.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchJson.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchFilter.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchAggregate.java</file>
    </fixedFiles>
  </bug>
  <bug id="2585" opendate="2018-9-21 00:00:00" fixdate="2018-9-21 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Support NOT Operator in ElasticSearch Adapter</summary>
      <description>NOT boolean expressions should be correctly processed by Calcite (ES adapter): select * from elastic where not foo = 1select * from elastic where not foo in (1, 2, 3)select * from elastic where foo not in (1, 2, 3)select * from elastic where not (foo in (1, 2, 3) and bar in (42, 43, 44))In elastic, they're converted to must_not BoolQuery.</description>
      <version>None</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">elasticsearch.src.test.java.org.apache.calcite.adapter.elasticsearch.ElasticSearchAdapterTest.java</file>
      <file type="M">elasticsearch.src.test.java.org.apache.calcite.adapter.elasticsearch.BooleanLogicTest.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.PredicateAnalyzer.java</file>
    </fixedFiles>
  </bug>
  <bug id="2588" opendate="2018-9-23 00:00:00" fixdate="2018-9-23 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Run Geode Adapter tests with an Embedded Instance</summary>
      <description>Similar to what has been done for Mongo / Elastic and Cassandra, allow Geode tests to run as part of CI build.</description>
      <version>1.17.0</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">geode.src.test.resources.model2.json</file>
      <file type="M">geode.src.test.resources.model.json</file>
      <file type="M">geode.src.test.resources.model-zips.json</file>
      <file type="M">geode.src.test.resources.model-with-classes.json</file>
      <file type="M">geode.src.test.resources.model-geode-pg-federation.json</file>
      <file type="M">geode.src.test.resources.model-bookshop.json</file>
      <file type="M">geode.src.test.resources.model-bookshop-all.json</file>
      <file type="M">geode.src.test.java.org.apache.calcite.adapter.geode.rel.GeodeZipsIT.java</file>
      <file type="M">geode.src.test.java.org.apache.calcite.adapter.geode.rel.GeodeAdapterIT.java</file>
      <file type="M">geode.src.test.java.org.apache.calcite.adapter.geode.rel.GeodeAdapterBookshopIT.java</file>
      <file type="M">geode.src.test.java.org.apache.calcite.adapter.geode.rel.BaseGeodeAdapterIT.java</file>
      <file type="M">geode.src.main.java.org.apache.calcite.adapter.geode.util.GeodeUtils.java</file>
      <file type="M">geode.src.main.java.org.apache.calcite.adapter.geode.simple.GeodeSimpleSchema.java</file>
      <file type="M">geode.src.main.java.org.apache.calcite.adapter.geode.rel.GeodeToEnumerableConverter.java</file>
      <file type="M">geode.src.main.java.org.apache.calcite.adapter.geode.rel.GeodeTableScan.java</file>
      <file type="M">geode.src.main.java.org.apache.calcite.adapter.geode.rel.GeodeTable.java</file>
      <file type="M">geode.src.main.java.org.apache.calcite.adapter.geode.rel.GeodeSort.java</file>
      <file type="M">geode.src.main.java.org.apache.calcite.adapter.geode.rel.GeodeSchemaFactory.java</file>
      <file type="M">geode.src.main.java.org.apache.calcite.adapter.geode.rel.GeodeSchema.java</file>
      <file type="M">geode.src.main.java.org.apache.calcite.adapter.geode.rel.GeodeRules.java</file>
      <file type="M">geode.src.main.java.org.apache.calcite.adapter.geode.rel.GeodeRel.java</file>
      <file type="M">geode.src.main.java.org.apache.calcite.adapter.geode.rel.GeodeProject.java</file>
      <file type="M">geode.src.main.java.org.apache.calcite.adapter.geode.rel.GeodeFilter.java</file>
      <file type="M">geode.src.main.java.org.apache.calcite.adapter.geode.rel.GeodeAggregate.java</file>
      <file type="M">geode.pom.xml</file>
    </fixedFiles>
  </bug>
  <bug id="259" opendate="2014-6-18 00:00:00" fixdate="2014-5-18 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Using sub-queries in CASE statement against JDBC tables generates invalid Oracle SQL</summary>
      <description>1. select e.NAME,(CASE e.dept_ID WHEN (Select d.id from PV_ADMIN.dept d where d.id = e.dept_id) THEN (Select d.name from PV_ADMIN.dept d where d.id = e.dept_id) ELSE 'DepartmentNotFound' END ) AS DEPTNAME from PV_ADMIN.EMP e;2. select e.NAME, CASE WHEN e.dept_ID = (select d.ID from PV_ADMIN.dept d where d.NAME = 'SALES') then 'SALES' ELSE 'Not Matched.' END as department from PV_ADMIN.EMP e ;---------------- Imported from GitHub ----------------Url: https://github.com/julianhyde/optiq/issues/259Created by: kunal-mahaleLabels: duplicate, Created at: Fri Apr 25 06:41:04 CEST 2014State: open</description>
      <version>None</version>
      <fixedVersion>1.3.0-incubating</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.test.JdbcAdapterTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.jdbc.JdbcRules.java</file>
    </fixedFiles>
  </bug>
  <bug id="2590" opendate="2018-9-23 00:00:00" fixdate="2018-9-23 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Remove redundant CAST when operand has exactly the same type as it is casted to</summary>
      <description></description>
      <version>1.17.0</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.sql.sub-query.iq</file>
      <file type="M">core.src.test.resources.sql.misc.iq</file>
      <file type="M">core.src.test.resources.org.apache.calcite.test.RelOptRulesTest.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RexProgramTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelOptRulesTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rex.RexSimplify.java</file>
    </fixedFiles>
  </bug>
  <bug id="2596" opendate="2018-9-26 00:00:00" fixdate="2018-12-26 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>AssertionError: Not-null boxed primitive should come back as primitive when translating correlated variables</summary>
      <description>Queries introducing correlated variables on boxed primitive fields throw an assertion error when they are translated to generated code in the Enumerable convention.For example, consider the following query where e.commission is a field of type Integer:SELECT empid FROM emps e WHERE NOT EXISTS (SELECT 1 FROM depts d WHERE d.deptno=e.commission) </description>
      <version>1.17.0</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.test.enumerable.EnumerableCorrelateTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.enumerable.RexToLixTranslator.java</file>
    </fixedFiles>
  </bug>
  <bug id="2601" opendate="2018-9-29 00:00:00" fixdate="2018-5-29 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Add REVERSE function</summary>
      <description>Returns the string str with the order of the characters reversed.I think ’Reverse‘ seems to be a generic function. </description>
      <version>None</version>
      <fixedVersion>1.20.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site..docs.reference.md</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlOperatorBaseTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.util.BuiltInMethod.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlKind.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlJdbcFunctionCall.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.fun.SqlLibraryOperators.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.runtime.SqlFunctions.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.enumerable.RexImpTable.java</file>
    </fixedFiles>
  </bug>
  <bug id="2611" opendate="2018-10-4 00:00:00" fixdate="2018-10-4 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Linq4j code generation failure if one side of an OR contains unknown</summary>
      <description>This is rather strange...it needs also an and below which contains the unknown.Running the following query: !connect jdbc:calcite:model=target/test-classes/model.json admin adminselect (EMPID = 3 and unknown) or ( EMPID = 3) from emps;results in a compilation exception;the main problem is that there is an interesting field:static final Object $L4J$C$_null = !null;full exception:0: jdbc:calcite:model=target/test-classes/mod&gt; select (cast(EMPID as integer) = 3 and unknown) or not ( cast(EMPID as integer) = 3) from emps;Error: Error while executing SQL "select (cast(EMPID as integer) = 3 and unknown) or not ( cast(EMPID as integer) = 3) from emps": Error while compiling generated Java code:org.apache.calcite.DataContext root;public org.apache.calcite.linq4j.Enumerable bind(final org.apache.calcite.DataContext root0) { root = root0; final org.apache.calcite.rel.RelNode v1stashed = (org.apache.calcite.rel.RelNode) root.get("v1stashed"); final org.apache.calcite.interpreter.Interpreter interpreter = new org.apache.calcite.interpreter.Interpreter( root, v1stashed); return new org.apache.calcite.linq4j.AbstractEnumerable(){ public org.apache.calcite.linq4j.Enumerator enumerator() { return new org.apache.calcite.linq4j.Enumerator(){ public final org.apache.calcite.linq4j.Enumerator inputEnumerator = interpreter.enumerator(); public void reset() { inputEnumerator.reset(); } public boolean moveNext() { return inputEnumerator.moveNext(); } public void close() { inputEnumerator.close(); } public Object current() { final Integer inp5_ = (Integer) ((Object[]) inputEnumerator.current())[5]; return inp5_ != null &amp;&amp; inp5_.intValue() != 3 ? Boolean.TRUE : inp5_ != null || $L4J$C$_null || inp5_ == null ? (Boolean) null : Boolean.FALSE; } static final Object $L4J$C$_null = !null; }; } };}public Class getElementType() { return java.lang.Boolean.class;} (state=,code=0)</description>
      <version>None</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">linq4j.src.test.java.org.apache.calcite.linq4j.test.BlockBuilderTest.java</file>
      <file type="M">linq4j.src.main.java.org.apache.calcite.linq4j.tree.OptimizeShuttle.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.ReflectiveSchemaTest.java</file>
    </fixedFiles>
  </bug>
  <bug id="2624" opendate="2018-10-12 00:00:00" fixdate="2018-8-12 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Add a rule to copy a sort below a join operator</summary>
      <description>Currently, the only rule that allows a sort to traverse a binary operator is the SortJoinTransposeRule. The rule was introduced mainly to push limits in the case of left and right outer joins (see CALCITE-831).I assume that the main reason that we don't have more rules is that sorts with limits and offsets cannot be pushed safely below many types of join operators. However, in many cases, it is possible and beneficial for optimization purposes to just push the sort without the limit and offset. Since we do not know in advance if the join operator preserves the order we cannot remove (that is why I am saying copy and not transpose) the sort operator on top of the join. The latter is not really a problem since the SortRemoveRule can detect such cases and remove the sort if it is redundant.A few concrete examples where this optimization makes sense are outlined below: allow the sort to be later absorbed by an index scan and disappear from the plan (Sort + Tablescan =&gt; IndexScan with RelCollation); allow operators that require sorted inputs to be exploited more easily (e.g., merge join); allow the sort to be performed on a possibly smaller result (assuming that the physical binary operator that is going to be used preserves the order of left/right input and the top sort operator can be removed entirely).I propose to add a new rule (e.g., SortCopyBelowJoinRule, SortJoinCopyBelowRule) which allows a sort to be copied to the left or right (or to both if it is rather easy to decompose the sort) of a join operator (excluding the limit and offset attributes) if the respective inputs are not already sorted.</description>
      <version>1.17.0</version>
      <fixedVersion>1.21.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.org.apache.calcite.test.RelOptRulesTest.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelOptRulesTest.java</file>
    </fixedFiles>
  </bug>
  <bug id="2625" opendate="2018-10-12 00:00:00" fixdate="2018-1-12 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>ROW_NUMBER, RANK generating Invalid SQL</summary>
      <description>The SQL standard says:- If &lt;ntile function&gt;, &lt;lead or lag function&gt;, &lt;rank function type&gt; or ROW_NUMBER is specified, then: … The window framing clause of WDX shall not be present.So, Calcite should not print the Window Frames when such functions are used.</description>
      <version>None</version>
      <fixedVersion>1.19.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.rel.rel2sql.RelToSqlConverterTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.rel2sql.SqlImplementor.java</file>
    </fixedFiles>
  </bug>
  <bug id="2631" opendate="2018-10-18 00:00:00" fixdate="2018-10-18 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>General improvements in case simplification</summary>
      <description>followup of CALCITE-1413 https://github.com/apache/calcite/commit/b470a0cd4572c9f6c4c0e9b51926b97c5af58d3f#commentsto address the following things: fuse branch removal logics with case branch simplification postpone condition simplification during branch compaction removal to avoid re-simplification of the same subtree if multiple branches are removed</description>
      <version>None</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.org.apache.calcite.test.RelOptRulesTest.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RexProgramTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelOptRulesTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rex.RexSimplify.java</file>
    </fixedFiles>
  </bug>
  <bug id="2651" opendate="2018-10-31 00:00:00" fixdate="2018-11-31 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Use scrolling by default in ElasticSearch adapter</summary>
      <description>Currently elastic adapter returns 10 rows (default ES limit) for queries of type select * from elastic which is inconsistent with other adapters and SQL standard.Apply Scrolling API for non-aggregate queries (without grouping or aggregate functions).</description>
      <version>None</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">elasticsearch.src.test.java.org.apache.calcite.adapter.elasticsearch.EmbeddedElasticsearchPolicy.java</file>
      <file type="M">elasticsearch.src.test.java.org.apache.calcite.adapter.elasticsearch.ElasticSearchAdapterTest.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchTable.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchSchema.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchJson.java</file>
      <file type="M">elasticsearch.pom.xml</file>
    </fixedFiles>
  </bug>
  <bug id="2655" opendate="2018-11-6 00:00:00" fixdate="2018-11-6 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Enable Travis to test against JDK 12</summary>
      <description>The docker hub Maven image recently added support for JDK 12.</description>
      <version>None</version>
      <fixedVersion>avatica-1.13.0,1.18.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">ubenchmark.pom.xml</file>
      <file type="M">pom.xml</file>
      <file type="M">cassandra.src.test.java.org.apache.calcite.test.CassandraAdapterTest.java</file>
      <file type="M">.travis.yml</file>
    </fixedFiles>
  </bug>
  <bug id="2658" opendate="2018-11-7 00:00:00" fixdate="2018-3-7 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Introducing more ReduceExpressionRules</summary>
      <description>It is useful to have rules reducing Exchange/Sort/SortExchange keys, e.g.,SELECT key,value FROM (SELECT 1 AS key, value FROM src) r DISTRIBUTE BY key;can be reduced to SELECT 1 AS key, value FROM src; # Since singleton requirement may already required by SELECT.SELECT key,value FROM (SELECT 1 AS key, value FROM src) r ORDER BY key;can be reduced toSELECT 1 AS key, value FROM src; # Since ordering on constant is useless.</description>
      <version>None</version>
      <fixedVersion>1.20.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.org.apache.calcite.test.RelOptRulesTest.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelOptRulesTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.prepare.CalcitePrepareImpl.java</file>
    </fixedFiles>
  </bug>
  <bug id="2663" opendate="2018-11-9 00:00:00" fixdate="2018-12-9 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>CREATE FUNCTION and DROP FUNCTION DDL commands</summary>
      <description>support create function and drop function statement like apache hive:CREATE [OR REPLACE] FUNCTION [IF NOT EXISTS] [db_name.]function_name AS class_name  [USING JAR|FILE|ARCHIVE 'file_uri' [, JAR|FILE|ARCHIVE 'file_uri'] ];DROP FUNCTION [IF EXISTS] function_name;   </description>
      <version>1.16.0,1.17.0</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site..docs.reference.md</file>
      <file type="M">server.src.test.java.org.apache.calcite.test.ServerParserTest.java</file>
      <file type="M">server.src.main.java.org.apache.calcite.sql.ddl.SqlDropObject.java</file>
      <file type="M">server.src.main.java.org.apache.calcite.sql.ddl.SqlDdlNodes.java</file>
      <file type="M">server.src.main.codegen.includes.parserImpls.ftl</file>
      <file type="M">server.src.main.codegen.config.fmpp</file>
      <file type="M">core.src.test.java.org.apache.calcite.util.UtilTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.parser.SqlUnParserTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.parser.SqlParserTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.util.Util.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.validate.SqlValidatorUtil.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.SqlKind.java</file>
    </fixedFiles>
  </bug>
  <bug id="2687" opendate="2018-11-20 00:00:00" fixdate="2018-11-20 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Is distinct from could lead to Exceptions in ReduceExpressionRule</summary>
      <description>Test: @Test public void testReduceConstants4() throws Exception { HepProgram program = new HepProgramBuilder() .addRuleInstance(ReduceExpressionsRule.PROJECT_INSTANCE) .addRuleInstance(ReduceExpressionsRule.FILTER_INSTANCE) .addRuleInstance(ReduceExpressionsRule.JOIN_INSTANCE) .build(); String sql = "select e.mgr is not distinct from f.mgr from emp e join emp f on (e.mgr=f.mgr) where e.mgr is null"; sql(sql).with(program) .check(); }Unfortunately the exception doesn't have a stacktrace by default; just some type:org.apache.calcite.adapter.enumerable.RexToLixTranslator$AlwaysNullTranslation is not possible at this point: https://github.com/apache/calcite/blob/d32ee5c320938b5c34ce09df2276c9570c27a301/core/src/main/java/org/apache/calcite/adapter/enumerable/RexToLixTranslator.java#L746the underlying rexNode is:CAST(null):INTEGER NOT NULLwhich is problematic</description>
      <version>None</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.org.apache.calcite.test.SqlToRelConverterTest.xml</file>
      <file type="M">core.src.test.resources.org.apache.calcite.test.RelOptRulesTest.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelOptRulesTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.plan.RelOptUtil.java</file>
    </fixedFiles>
  </bug>
  <bug id="2689" opendate="2018-11-20 00:00:00" fixdate="2018-12-20 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>ES Adapter. Grouping on date / number fields fails</summary>
      <description>For Terms Aggregation missing value has to have same type as group key:select max(amount), date from orders group by date -- date column is of type date (in ES)Currently single (text) key is used _MISSING_ which fails when grouping on non-string fields (eg. dates, numbers or booleans).When using missing (value) query converter should consider field type.This logic should be reviewed once we migrate to composite aggregations (available since 6.1 see PR26800)</description>
      <version>None</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">elasticsearch.src.test.java.org.apache.calcite.adapter.elasticsearch.ScrollingTest.java</file>
      <file type="M">elasticsearch.src.test.java.org.apache.calcite.adapter.elasticsearch.BooleanLogicTest.java</file>
      <file type="M">elasticsearch.src.test.java.org.apache.calcite.adapter.elasticsearch.AggregationTest.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.Scrolling.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchTransport.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchTable.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchJson.java</file>
      <file type="M">elasticsearch.pom.xml</file>
    </fixedFiles>
  </bug>
  <bug id="2695" opendate="2018-11-22 00:00:00" fixdate="2018-11-22 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Simplify casts which are only widening nullability</summary>
      <description>There are cases in which casts are added; but they are not neccessary. @Test public void testSimplifyRedundantCast() { RexNode expr = cast(isTrue(vBoolNotNull()), tBoolean(true)); assertThat(expr.getType().isNullable(), is(true)); RexNode result = simplify.simplifyUnknownAs(expr, RexUnknownAs.UNKNOWN); assertThat(result.getType().isNullable(), is(false)); }</description>
      <version>None</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.sql.sub-query.iq</file>
      <file type="M">core.src.test.resources.sql.some.iq</file>
      <file type="M">core.src.test.resources.sql.agg.iq</file>
      <file type="M">core.src.test.resources.org.apache.calcite.test.SqlToRelConverterTest.xml</file>
      <file type="M">core.src.test.resources.org.apache.calcite.test.RelOptRulesTest.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RexProgramTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.JdbcTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rex.RexSimplify.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rex.RexProgramBuilder.java</file>
    </fixedFiles>
  </bug>
  <bug id="2699" opendate="2018-11-23 00:00:00" fixdate="2018-12-23 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>TIMESTAMPADD function handles TIME incorrectly</summary>
      <description>Two errors occur when timestampadd(MINUTE, 1, time '01:00:00') is executed: The return result can only be of TimeStamp type and is expected to be of Time type The return value is 1970-01-01 01:01:00, and the expectation is 01:01:00 I think it should meet the following conditions:expressionExpect the resulttimestampadd(MINUTE, -1, time '00:00:00')23:59:00timestampadd(MINUTE, 1, time '00:00:00')00:01:00timestampadd(MINUTE, 1, time '23:59:59')00:00:59timestampadd(SECOND, 1, time '23:59:59')00:00:00timestampadd(HOUR, 1, time '23:59:59')00:59:59timestampadd(DAY, -1, time '23:59:59')23:59:59timestampadd(WEEK, -1, time '23:59:59')23:59:59timestampadd(MONTH, -1, time '23:59:59')23:59:59timestampadd(QUARTER, -1, time '23:59:59')23:59:59timestampadd(YEAR, -1, time '23:59:59')23:59:59</description>
      <version>1.17.0</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site..docs.reference.md</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.test.SqlOperatorBaseTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.fun.SqlTimestampAddFunction.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.enumerable.RexImpTable.java</file>
    </fixedFiles>
  </bug>
  <bug id="2719" opendate="2018-11-29 00:00:00" fixdate="2018-12-29 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>MySQL does not support cast to BIGINT type</summary>
      <description>Cast to BIGING is not supported in MySQL. The trick is to use CAST to SIGNED INT. When accepted I will try to fix this.</description>
      <version>1.17.0</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.rel.rel2sql.RelToSqlConverterTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.sql.dialect.MysqlSqlDialect.java</file>
    </fixedFiles>
  </bug>
  <bug id="2721" opendate="2018-12-2 00:00:00" fixdate="2018-6-2 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Support parsing of DOT + MEMBER_FUNCTION</summary>
      <description>Support parsing of &lt;DOT&gt; + &lt;MEMBER_FUNCTION&gt; parsing Similar to ExampleSELECT t.complex_col.member_func() FROM tbl;For more details please see: Member Function</description>
      <version>None</version>
      <fixedVersion>1.20.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlValidatorTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.sql.parser.SqlParserTest.java</file>
      <file type="M">core.src.main.codegen.templates.Parser.jj</file>
    </fixedFiles>
  </bug>
  <bug id="2727" opendate="2018-12-6 00:00:00" fixdate="2018-1-6 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>MV rewriting bails out incorrectly when a view does not contain any table reference</summary>
      <description>When we iterate through all applicable materializations trying to rewrite the given query, if there are no table references in a given MV, we bail out from the onMatch method instead of simply skipping the MV.</description>
      <version>None</version>
      <fixedVersion>1.19.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.main.java.org.apache.calcite.rel.rules.AbstractMaterializedViewRule.java</file>
    </fixedFiles>
  </bug>
  <bug id="2729" opendate="2018-12-7 00:00:00" fixdate="2018-3-7 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Introducing WindowReduceExpressionRule</summary>
      <description>Introducing WindowExpressionRules, for example:select sum(sal) over (partition by deptno order by sal) from src where sal=5000can be reduced to select sum(5000) over (partition by deptno) from src where sal=5000</description>
      <version>None</version>
      <fixedVersion>1.20.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.org.apache.calcite.test.RelOptRulesTest.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelOptRulesTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.rules.ReduceExpressionsRule.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.prepare.CalcitePrepareImpl.java</file>
    </fixedFiles>
  </bug>
  <bug id="2730" opendate="2018-12-7 00:00:00" fixdate="2018-12-7 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>RelBuilder incorrectly simplifies a filter with duplicate conjunction to empty</summary>
      <description>Regression from 1.17.</description>
      <version>None</version>
      <fixedVersion>1.18.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.resources.org.apache.calcite.test.RelOptRulesTest.xml</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelBuilderTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rex.RexSimplify.java</file>
    </fixedFiles>
  </bug>
  <bug id="2732" opendate="2018-12-7 00:00:00" fixdate="2018-1-7 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Upgrade postgresql driver version</summary>
      <description>We are still using the JDBC 3 version (9.3-1102-jdbc3). Not sure if anyone has run the compatibility tests in calcite-test-dataset with Postgresql recently, but I get an java.lang.AbstractMethodError message for several of them. We can move to the JDBC 4.1 implementation 9.3-1102-jdbc41 (I verified that this fixes the issue).</description>
      <version>None</version>
      <fixedVersion>1.19.0</fixedVersion>
      <type>Test</type>
    </buginformation>
    <fixedFiles>
      <file type="M">pom.xml</file>
    </fixedFiles>
  </bug>
  <bug id="2733" opendate="2018-12-7 00:00:00" fixdate="2018-1-7 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Use catalog and schema from JDBC connection string to retrieve tables if specified</summary>
      <description>From JDBC 4.1, catalog and schema can be retrieved from the connection object. When we retrieve the table objects using the JDBC connection, I believe we could try to get catalog and schema from connection object if they have not been specified by user. If they are not in the connection object either, null will be passed.</description>
      <version>None</version>
      <fixedVersion>1.19.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.test.JdbcAdapterTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.jdbc.JdbcSchema.java</file>
    </fixedFiles>
  </bug>
  <bug id="2734" opendate="2018-12-11 00:00:00" fixdate="2018-8-11 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>MongoDB adapter tutorial is out of date</summary>
      <description>Hey all,    I am trying to learn Calcite via MongoDB adapter, and I found there is a related tutorial section in HOWTO,].  But it seems to be a little out of date now, I found several issues at least:1. model file: mongo-zips-model.json  has been renamed into mongo-models.json.2. data source file zips.json doesn't include all the data required in the models.json file.3. the MongoDB adapter can not be directly used, because there is a log related bug when execute command ``!connect jdbc:calcite:model=mongodb/target/test-classes/mongo-model.json admin admin``, related output:```SLF4J: Detected both log4j-over-slf4j.jar AND slf4j-log4j12.jar on the class path, preempting StackOverflowError.SLF4J: See also http://www.slf4j.org/codes.html#log4jDelegationLoop for more details.Caused by: java.lang.NoClassDefFoundError: Could not initialize class org.apache.log4j.Log4jLoggerFactory```   </description>
      <version>1.17.0</version>
      <fixedVersion>1.21.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">site..docs.howto.md</file>
    </fixedFiles>
  </bug>
  <bug id="2759" opendate="2018-12-29 00:00:00" fixdate="2018-12-29 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Update maven-remote-resources-plugin to 1.6.0</summary>
      <description></description>
      <version>1.17.0</version>
      <fixedVersion>1.19.0</fixedVersion>
      <type>Sub-task</type>
    </buginformation>
    <fixedFiles>
      <file type="M">pom.xml</file>
    </fixedFiles>
  </bug>
  <bug id="2814" opendate="2019-1-29 00:00:00" fixdate="2019-1-29 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>ElasticSearch adapter. Fix "group by" when using raw item access (eg. _MAP[&amp;#39;a.b.c&amp;#39;])</summary>
      <description>The following query is still failing in elastic due to field / item mappingselect max(_MAP['a']), _MAP['b'] from elastic group by _MAP['b']</description>
      <version>None</version>
      <fixedVersion>1.19.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">elasticsearch.src.test.java.org.apache.calcite.adapter.elasticsearch.ElasticSearchAdapterTest.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchToEnumerableConverter.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchTable.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchSort.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchRel.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchMethod.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchEnumerators.java</file>
      <file type="M">elasticsearch.src.main.java.org.apache.calcite.adapter.elasticsearch.ElasticsearchAggregate.java</file>
    </fixedFiles>
  </bug>
  <bug id="3433" opendate="2019-10-21 00:00:00" fixdate="2019-11-21 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>EQUALS operator between date/timestamp types returns false if the type is nullable</summary>
      <description>sqlselect time0 = time1from (select timestamp'2000-12-30 21:07:32' as time0, timestamp'2000-12-30 21:07:32' as time1 union all select cast(null as timestamp) as time0, cast(null as timestamp) as time1)answer is falsebut sqlselect time0 = time1from(select timestamp'2000-12-30 21:07:32' as time0, timestamp'2000-12-30 21:07:32'as time1)answer is true </description>
      <version>1.17.0,1.18.0,1.19.0,1.20.0,1.21.0</version>
      <fixedVersion>1.22.0</fixedVersion>
      <type>Bug</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.test.JdbcTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.adapter.enumerable.RexImpTable.java</file>
    </fixedFiles>
  </bug>
  <bug id="3473" opendate="2019-11-4 00:00:00" fixdate="2019-12-4 01:00:00" resolution="Fixed">
    <buginformation>
      <summary>Getting unique result for table scan should contain key column(s)</summary>
      <description>Currently,  mq.getUniqueKeys() for TableScan returns empty.However, for table with key column(s) defined, we can refer uniqueness on key column(s), so the result should contain key column(s)</description>
      <version>None</version>
      <fixedVersion>1.22.0</fixedVersion>
      <type>Improvement</type>
    </buginformation>
    <fixedFiles>
      <file type="M">core.src.test.java.org.apache.calcite.test.SqlToRelTestBase.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.RelMetadataTest.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.test.catalog.MockCatalogReader.java</file>
      <file type="M">core.src.test.java.org.apache.calcite.rel.rel2sql.RelToSqlConverterStructsTest.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.schema.Statistics.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.schema.Statistic.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.rel.metadata.RelMdUniqueKeys.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.prepare.RelOptTableImpl.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.plan.RelOptTable.java</file>
      <file type="M">core.src.main.java.org.apache.calcite.plan.RelOptAbstractTable.java</file>
    </fixedFiles>
  </bug>
</bugrepository>
